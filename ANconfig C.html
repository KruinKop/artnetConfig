HTTP/1.1 200 OK
Connection: close
Content-Type: text/html
Acces-Control-Allow-Origin: *

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Art-Net configurator</title>
</head>
<style>
    /* Resets all the style rules applied by browser 

   http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
    */

    html, body, div, span, applet, object, iframe,
    h1, h2, h3, h4, h5, h6, p, blockquote, pre,
    a, abbr, acronym, address, big, cite, code,
    del, dfn, em, img, ins, kbd, q, s, samp,
    small, strike, strong, sub, sup, tt, var,
    b, u, i, center,
    dl, dt, dd, ol, ul, li,
    fieldset, form, label, legend,
    table, caption, tbody, tfoot, thead, tr, th, td,
    article, aside, canvas, details, embed, 
    figure, figcaption, footer, header, hgroup, 
    menu, nav, output, ruby, section, summary,
    time, mark, audio, video {
    	margin: 0;
    	padding: 0;
    	border: 0;
    	font-size: 100%;
    	/* font: inherit; */
    	vertical-align: baseline;
    }
    /* HTML5 display-role reset for older browsers */
    article, aside, details, figcaption, figure, 
    footer, header, hgroup, menu, nav, section {
    	display: block;
    }
    body {
    	line-height: 1;
    }
    ol, ul {
    	list-style: none;
    }
    blockquote, q {
    	quotes: none;
    }
    blockquote:before, blockquote:after,
    q:before, q:after {
    	content: '';
    	content: none;
    }
    table {
    	border-collapse: collapse;
    	border-spacing: 0;
    }
    
    /* ============= Style rules defined by us ============== */
    /* ======= starting with some custom properties ========= */

    :root {
        /* font */
        --font-nav-title: 'Reddit', sans-serif;
        --font-regular: 'Roboto', sans-serif;

        /* font sizes */
        --font-size-xxl: 4rem;
        --font-size-xl: 2.5rem;
        --font-size-large: 2rem;
        --font-size-medium: 1.4rem;
        --font-size-small: 0.9rem;
        --font-size-xs: 0.7rem;

        /* spacing */
        --grid-nav-width: 200px;
        --banner-height: 85px;
        --padding-small: 15px;
        --padding-medium: 20px;
        --padding-large: 30px;
    }   

    body {
        /* colors */
        --ll-yellow: #FFF200;
        --ll-light-yellow: #F8EB00;
        --ll-yellow-font: #F8EB00;
        --ll-mustard: #B9AF00;
        --bg-coal: #363633;
        --bg-dmx-box: #2F2F2F;
        --bg-grey: #82827B;
        --bg-input-grey: #82827B;
        --bg-button-grey: #5d5d44;
        --bg-grey-focus: #777761;
        --bg-grey-pressed: #63635e;
        --bg-card-grey: #4d4d4d;
        --bg-error-red: #8a3838;
        --bg-status-green: #2Aff00;

        background-color: var(--bg-coal);
        display: grid;
        grid-template-columns: var(--grid-nav-width) 1fr;
        grid-template-rows: var(--banner-height) calc(100vh - var(--banner-height) - var(--padding-small));
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10 and IE 11 */
        user-select: none; /* Standard syntax */ 

        
        input[type=number]::-webkit-inner-spin-button {
            opacity: 1
        }

    }

    body.light {
        --ll-yellow: rgb(82, 82, 82);
        --ll-light-yellow: #4d4d4d;
        --ll-mustard: #efde89;
        --ll-yellow-font: #646464;
        --nav-font: #4d4d4d;
        --bg-coal: #f5f2ec;
        --bg-dmx-box: #6f5239;
        --bg-grey: #ebddc3;
        --bg-input-grey: #fdf4e3;
        --bg-button-grey: #f0f0e7;
        --bg-grey-focus: #e8ddb2;
        --bg-grey-pressed: #cdbd8c;
        --bg-light-card-grey: #DDDDDD;
        --bg-light-address: #FDFFF9;
        --bg-card-grey: #d8ccb5;
        --bg-error-red: #d28383;
    }

    nav, .info, #banner span, #title {
        font-family: var(--font-regular);
    }

    #title h2:nth-child(2), h1 {
        color: var(--bg-coal);
    }

    #title h2 {
        font-weight: 400;
    }

    .info {
        color: var(--ll-light-yellow)
    }

    /*==================================== Banner ==================================== */
    
    header {
        display: grid;
        position: relative;
        grid-row: 1/2;
        grid-column: 1/3;
        grid-template-columns: subgrid;
        margin: var(--padding-small) var(--padding-small) 0 var(--padding-small);
        min-width: 620px;
        background-color: var(--ll-mustard); 
        border-radius: 20px;
        box-shadow: 5px 10px 15px rgba(0,0,0,0.5);
        z-index: 100;
    }

    .light header {
        box-shadow: 5px 10px 15px rgba(179, 179, 179, 0.5);
    }

    #banner {
        display: grid;
        column-gap: var(--padding-small);
        grid-column: 2/3;
        grid-template-columns: clamp(29px, 5vw, 50px) repeat(2, 40px) auto 50px var(--padding-small);
        align-items: center;
    }

    #eth1 {
        position: relative;
        grid-column: 2/3;
    }

    #eth2 {
        position: relative;
        grid-column: 3/4;
    }

    h1 {
        grid-row: 1;
        grid-column: 4/5;
        justify-self: center;
        position: relative;
        bottom: 2px;
        font-size: var(--font-size-xl);
        font-family: 'Courier New', Courier, monospace;
        font-weight: 400;
        color: #363633;
    }

    h3 {
        font-weight: 300;
        word-break: break-all;
    }

    /* ============= Dark mode switch ============== */

    #dark-mode-switch {
        grid-column: 5/6;
    }

    #dark-mode-switch label {
        width: 70px;
        height: 30px;
        position: relative;
        bottom: 4px;
        display: block;
        background-color: var(--bg-coal);
        border-radius: 200px;
        box-shadow: inset 0px 5px 15px rgba(0,0,0,0.4), inset 0px -5px 15px rgba(255,255,255,0.4);
        cursor: pointer;
        transition: 0.3s;
    }

    #dark-mode-switch label:after{
        content: "";
        width: 25px;
        height: 25px;
        position: absolute;
        top: 2.5px;
        left :2.5px;
        background: linear-gradient(180deg, #777, #3a3a3a);
        border-radius: 40px;
        box-shadow: 0px 5px 10px rgba(0,0,0,0.2);
        transition: 0.3s;
    }

    #dark-mode-switch input, #edit input {
        width: 0;
        height: 0;
        visibility: hidden;
    }

    #dark-mode-switch input:checked + label {
        background-color: var(--bg-coal);
    }

    #dark-mode-switch input:checked + label:after {
        left: calc(100% - 2.5px);
        transform: translateX(-100%);
        background: linear-gradient(270deg, var(--bg-grey-focus), var(--bg-card-grey));
    }

    #dark-mode-switch label:hover:after {
        width: 35px;
    }

    #dark-mode-switch label svg {
        position: absolute;
        width: 20px;
        top: 5px;
        z-index: 100;
    }

    #dark-mode-switch label svg.sun {
        width: 25px;
        left: 43px;
        top: 3px;
        fill: #7e7e7e;
        transition: 0.3s;
    }

    #dark-mode-switch label svg.moon {
        left: 5px;
        fill: #dbdbdb;
        transition: 0.3s;
    }

    #dark-mode-switch input:checked + label svg.sun {
        fill: #fff;
        transition: 0.3s;

    }

    #dark-mode-switch input:checked + label svg.moon {
        fill: #7e7e7e;
        transition: 0.3s;
    }

    /* ============= Edit mode switch ============== */

    .e-button {
        height: 25px;
        width: 25px;
        background-color: var(--bg-button-grey);
        border: 2px solid var(--ll-yellow);
        color: var(--ll-yellow);
        border-radius: 100%;
    }

    #pen {
        height: 20px;
        width: 20px;
        padding: 5px;
    }

    .e-button:hover{
        cursor: pointer;
        background-color: var(--bg-grey-focus);
    }

    .e-button:active {
        background-color: var(--bg-grey-pressed)
    }



    /*==================================== Navbar ==================================== */

    #sidebar {
        display: grid;
        grid-template-rows: 100px 10fr 1fr;
        grid-row: 1/2;
        grid-column: 1/2;
        margin: var(--padding-small) 0 var(--padding-small) var(--padding-small);
        height: calc(100vh - 2*var(--padding-small));
        min-height: calc(520px + var(--padding-large) + var(--banner-height) - var(--padding-small));
        min-width: 120px;
        background-color: var(--bg-grey);
        border-radius: 20px;
        z-index: 101;
    }

    #sidebar.light {
        background-color: var(--bg-light-grey);
    }

    nav {
        padding-top: var(--padding-large);
        grid-column: 1;
        grid-row: 2;      
        font-size: 2rem;
        overflow-y: auto;
        overflow-x: hidden;
        direction: rtl;
    }

    nav ul {
        direction: ltr;
    }

    #title {
        grid-column:1;
        grid-row: 1;
    }

    #title h2 {
        grid-row:1/2;
        font-size: var(--font-size-large);
        text-align: right;
        margin-right: 10px;
    }

    /* Lux-Lumen */
    #title h2:nth-child(1), #info {
        color: var(--ll-yellow);
    }

    .light #title h2:nth-child(1), .light #info {
        color: var(--ll-yellow-font);
    }

    /* Art-Net node */
    #title h2:nth-child(2) {
        position: relative;
        z-index: 101;
    }

    #edit {
        z-index: 1000;
        grid-column: 4;
        justify-self: center;
        align-self: end;
        grid-row: 1;
        position: relative;
        top: 20px;
        left: 130px;
    }

    #edit label {
        position: relative;
        bottom: 9px;
        left: 20px;
    }

    #node-list {
        display: flex;
        flex-direction: column;
    }

    .node {
        z-index: 101;
        font-size: var(--font-size-medium);
        padding: var(--padding-small) 0 var(--padding-small) var(--padding-small);
        color: var(--bg-coal);
        transition: transform 0.3s ease-out;
    }

    .light .node {
        color: var(--nav-font);
    }

    .node.disconnected h3 {
        opacity: 25%;
    }

    .node:hover {
        cursor: pointer;
        transform: translateX(-5px);
    }

    .info {
        display: none;
        font-size: var(--font-size-small);
    }

    .node-list #status {
        display: none;
    }

    .info li {
        margin-top: 0.5rem;
    }

    .info p {
        display: inline;
    }

    .info.config {
        font-size: var(--font-size-xs);
        flex-direction: column;
        display: flex;
        justify-content: center;
        align-items: center;
        grid-row: 3/4;
    }

    /* ============= Selected node ============== */

    .node.selected {
        position: relative;
        margin-left: var(--padding-small);
        margin-right: -1px;
        border-radius: 10px 0px 0px 10px;
        background-color: var(--bg-coal);
        color: var(--ll-yellow);
        z-index: 5;
    }

    .node.selected:hover {
        transform: none;
    }

    .node h2 {
        font-weight: 200;
    }

    .node.selected #name {
        word-break: break-all;
    }

    .node.selected.disconnected h3 {
        opacity: 100%;
    }

    .node.selected .info {
        margin-top: var(--padding-small);
        display: block;
    }

    .node.selected #top-curve {
        position: relative;
    }

    .node.selected #top-curve:before{
        position: absolute;
        content: "";
        left: calc(var(--grid-nav-width) - 75px);
        bottom: 15px;
        width: 30px;
        height: 30px;
        background-color: var(--bg-coal);
    }

    .node.selected #top-curve:after {
        content: "";
        position: absolute;
        left: calc(var(--grid-nav-width) - 105px);
        bottom: 15px;
        width: 60px;
        height: 60px;
        background-color: var(--bg-grey);
        border-radius: 100%;
    }

    .node.selected #bottom-curve {
        position: relative;
    }

    .node.selected #bottom-curve:before {
        content:"";
        position: absolute;
        left: calc(var(--grid-nav-width) - 75px);
        top: 15px;
        width: 30px;
        height: 30px;
        background-color: var(--bg-coal);
    }

    .node.selected #bottom-curve:after {
        content:"";
        position: absolute;
        left: calc(var(--grid-nav-width) - 105px);
        top: 15px;
        width: 60px;
        height: 60px;
        border-radius: 100%;
        background-color: var(--bg-grey);
    }

    .node.selected #status{
        float: left;
        margin-top: 9px;
        margin-right: 5px;
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background-color: var(--bg-status-green);
    }
    
    .node.disconnected #status{
        background-color: red;
    }

    .node form {
        cursor: default;
        /* margin-top: -20px; */
        min-width: 90px;
        height: 100%;
    }

    .node .form-label {
        font-size: var(--font-size-small);
    }

    input, select {
        color: (var(--ll-yellow));
        border: 2px solid var(--ll-yellow);
        border-radius: 5px;
        background-color: var(--bg-input-grey);
        z-index: 2000;
    }

    form input {
        margin-top: calc(var(--padding-small)/3);
        margin-bottom: calc(var(--padding-small)/2);
        width: 95%;
        min-width: 95px;
    }

    #submit-wrapper {
        margin-top: var(--padding-small);
        text-align: center;
    }

    #submit-wrapper input {
        cursor: pointer;
        margin-top: 0;
        width: 90px;
        border: none;
    }

    #submit-wrapper input:hover {
        background-color: var(--bg-grey-focus);
    }

    #submit-wrapper input:active {
        background-color: var(--bg-grey-pressed);
    }

    input::placeholder {
        color: var(--ll-yellow);
        opacity: 70%;
    }

    input.illegal {
        background-color: var(--bg-error-red);
    }

    /* ============= Center configuration ============== */

    #main-config {
        display: grid;
        grid-column: 2/3;
        grid-row: 2/3;
        grid-template-columns: calc(40px - var(--padding-medium)) clamp(60px, 10vw, 100px) calc(3*var(--padding-medium)) repeat(6,2fr); 
        grid-template-rows: subgrid;
        margin: var(--padding-large) var(--padding-small) 0;
        transition: opacity 500ms;
        font-family: var(--font-regular);
        min-height: 520px;
    }

    body.loading #main-config {
        opacity: 50%;
    }

    body.loading #main-config * {
        cursor: progress !important;
    }

    .range {
        background-color: var(--bg-input-grey);
    }

    .card {
        background-color: var(--bg-card-grey);
        border-radius: 25px;
        box-shadow: 0px 10px 15px 2px rgba(0,0,0,0.5);
    }

    #universe-container {
        position: relative;
        display: grid;
        grid-column: 2/3;
        grid-row: 1/7;
        grid-template-rows: subgrid;
        grid-template-columns: subgrid;
        border-radius: 0px 12px 12px 12px;
        color: var(--ll-yellow);
        box-shadow: 0px 10px 15px 2px rgba(0,0,0,0.5);
    }


    .light #universe-container {
        box-shadow: 5px 10px 15px rgba(179, 179, 179, 0.5);
    }
    
    #universe-container:before {
        top: -15px;
        position: absolute;
        justify-self: center;
        content: "";
        display: inline-block;
        width: 70%;
        height: 20px;
        background-color: var(--bg-dmx-box);
        border-radius: 5px;
        z-index: -1;
    }

    #universe-container:after {
        top: -50px;
        position: absolute;
        justify-self: center;
        content: "";
        display: inline-block;
        width: 40%;
        height: 50px;
        background-color: var(--ll-yellow);
        border-radius: 5px;
        z-index: -4;
        box-shadow: 5px 0px 15px 2px rgba(0,0,0,0.5) inset;
    }

    .light #universe-container:after {
        background-color: var(--ll-mustard);
    }

    #universes {
        display: grid;
        grid-column: 2/3;
        grid-row: 1/7;
        grid-template-rows: subgrid;
        grid-template-columns: subgrid;
        position: relative;
    }

    #universe-container #tab {
        display: inline-block;
        position: absolute;
        width: 51px;
        margin-left: -46px;
        top: 17.7px;
        content: "Universes";
        transform: rotate(-90deg);
        font-size: var(--font-size-small);
        padding: 7px;
        border-radius: 12px 12px 0px 0px;
        box-shadow: none;
    }

    #universes li {
        align-self: center;
        position: relative;
        text-align: center;
        margin: 5px;
        padding: 8px 0;
        font-size: clamp(var(--font-size-small), 2vw, var(--font-size-medium)); 
        border-radius: 10px;
        /* z-index: 2; */
        box-shadow: 0px 5px 15px 2px rgba(0,0,0,0.5);
    }

    .light #universes li {
        box-shadow: 0px 5px 15px 2px rgba(171, 171, 171, 0.5);
    }

    #universes li span {
        font-size: var(--font-size-small);
        position: absolute;
        padding: 5px;
        top: 60%;
        left: 75%;
        border-radius: 10px;
        z-index: 1;
    }

    #universes li.illegal, #universes li.illegal span, #universes li.illegal input:nth-of-type(1) {
        background-color: var(--bg-error-red);
    }

    #universes li input {
        width: clamp(70px, 9vw, 90px);
        position: relative;
        font-size: clamp(var(--font-size-small), 2vw, var(--font-size-medium)); 
        text-align: center;
    }

    #universes li input:first-child {
        position: relative;
        z-index: 999 !important;
    }

    #universes li input:last-child {
        position: absolute;
        width: 55px;
        /* height: 70%; */
        top: 95%;
        left: 60%;
        font-size: var(--font-size-small);
        /* z-index: -1000 !important; */
    }

    #universe-filter-container {
        padding-top: 10px;
        grid-row: 8;
        z-index: 10;
        width: 90%;
        margin: 0px auto 0px auto;
    }

    #universe-filter {
        display: flex;
        flex-direction: row;
        justify-content: space-around;
    }

    #universe-filter h3 {
        display: flex;
        padding-top: 3px;
        justify-content: center;
    }

    #accolades {
        /* position: relative; */
        display: grid;
        grid-column: 3/10;
        grid-row: 1/11;
        grid-template-columns: subgrid;
        grid-template-rows: subgrid;
    }

    #accolades div {
        /* position: relative; */
        /* left: -40px; */
        height: 104%;
        display: grid;
        grid-template-columns: subgrid;
        margin-bottom: -2.65px;
        overflow: hidden;
    }

    #accolades svg {
        height: 100%;
    }

    .accolade {
        position: relative; 
        grid-column: 1/8; 
        overflow: hidden; 
        z-index: -10;
    }

    .accolade .info {
        display: block;
        fill: var(--ll-yellow);
        /* font-size: var(--font-size-xs); */
    }


    #fieldbusses{
        position: relative;
        display: grid;
        grid-template-rows: subgrid;
        grid-template-columns: subgrid;
        grid-row: 1/8;
        grid-column: 4/10;
    }
    
    .fieldbus.card {
        display: grid;
        grid-row: 1/8;
        grid-template-rows: subgrid;
        justify-self: end;
        width: 70%;
        max-width: 125px;
        min-width: 50px;
        color: var(--ll-yellow);
    }

    
    .address.range{
        position: relative;
        justify-self: center;
        grid-row: 1/7;
        width: 92%;
        border-radius: 25px;
        box-shadow: 0px -10px 35px 3px var(--bg-coal) inset;
        outline: 3px solid var(--bg-coal);
        outline-offset: -2px;
    }

    .light .address.range {
        box-shadow: 0px -10px 35px 3px rgb(237, 230, 219) inset;
    }

    .address.range h1 {
        position: absolute;
        left: 50%;
        width: 0;
        transform: rotate(-90deg);
        color: var(--bg-card-grey);
        font-family: var(--font-nav-title);
        font-size: 3rem;
        white-space: nowrap;
        opacity: 50%;
    }

    .light .address.range h1 {
        color: rgb(177, 177, 177);
    }

    .address.range div.patch {
        position: relative;
        background: var(--bg-coal);
        border-radius: 15px;
        outline: 3px solid var(--ll-yellow);
        outline-offset: -2px;
    }

    .light .address.range div.patch {
        background: rgb(255, 255, 255);
    }

    .draggable {
        cursor: move;
    }

    .address.range div.patch.top {
        background: linear-gradient(0deg, var(--bg-coal) 70%, var(--ll-mustard) 100%);
        transition: color 2s;
    }

    .address.range div.patch.mid {
        background: linear-gradient(0deg, var(--bg-coal) 0%, var(--ll-mustard) 50%, var(--bg-coal) 100%);
    }

    .address.range div.patch.bottom {
        background: linear-gradient(0deg, var(--ll-mustard) 0%, var(--bg-coal) 30%);
    }

    .address.range div.top-handle {
        cursor: n-resize;
        position: absolute;
        top: -16px;
        display: flex;
        justify-content: center;
        height: 20px;
        width: 100%; 
    }

    .address.range div.top-handle.light, .address.range div.bottom-handle.light {
        background-color: transparent;
        outline: transparent;
    }

    .address.range div.top-handle:after {
        content: "";
        width: 17%;
        height: 7px;
        position: relative;
        bottom: -9px;
        background-color: var(--ll-yellow);
        border-radius: 5px 5px 0px 0px;
    }

    .address.range div.bottom-handle {
        cursor: n-resize;
        position: absolute;
        bottom: -19.5px;
        display: flex;
        justify-content: center;
        height: 20px;
        width: 100%; 
    }

    .address.range div.bottom-handle:after {
        content: "";
        width: 17%;
        height: 7px;
        background-color: var(--ll-yellow);
        border-radius: 0px 0px 5px 5px;
    }

    .address-container {
        height: 100%;
        display: grid;
        grid-template-rows: repeat(3, 1fr);
    }

    .config .address-container {
        grid-template-rows: repeat(2, 1fr);
    }

    .config .address-container.overflow {
        grid-template-rows: 1fr;
    }

    #fieldbusses .patch.config {
        position: relative;
    }

    #fieldbusses h2 {
        height: fit-content;
        padding: 5px 5px 0px 5px;
        font-size: clamp(var(--font-size-xs), 1vw, var(--font-size-small)); 
        text-align: center;
        font-weight: 400;
    }

    #fieldbusses h2.stream {
        align-self: center;
    }

    #fieldbusses h2 input {
        position: absolute;
        left: 20%;
        width: clamp(55px, 4.5vw, 90px);
    }

    #fieldbusses .overflow h2 {
        position: absolute;
        width: 90%;
    }

    #fieldbusses .overflow h2.start{
        cursor: default;
        z-index: 101;
    }

    #fieldbusses .overflow h2.start {
        top: -35px;
    }

    #fieldbusses .overflow h2.configurable.start {
        top: -50px;
    }

    #fieldbusses h2.configurable.start {
        grid-row: 1;
        width: fit-content;
        justify-self: center;
    }

    #fieldbusses h2.configurable.stream {
        align-self: start;
        width: fit-content;
        justify-self: center;
        grid-row: 2;
        padding-top: 0px;
    }

    #fieldbusses .overflow h2.stream {
        grid-row: 1;
        margin-top: -5px;
        align-self: center;
    }

    #fieldbusses .overflow h2.configurable.stream {
        margin-top: -25px;
    }

    #fieldbusses .overflow.extreme h2.stream {
        bottom: -2.75em;
    }

    #fieldbusses .overflow.extreme h2.configurable.stream {
        bottom: -30px;
    }

    .address.range div.light{
        background-color: var(--bg-light-grey);
        outline: 3px solid var(--bg-card-grey);
    }
    
    .address.range div.light div:after{
        background-color: var(--bg-card-grey);
    }

    .fb-protocol.info {
        /* grid-row: 8; */
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        align-items: center;
        font-size: clamp(var(--font-size-xs), 1vw, var(--font-size-small));
    }

    .fb-protocol.info label {
        margin-top: 15px;
    }

    .fb-protocol.info select {
        margin-top: 5px;
        text-align: center;
        width: 90%;
    }

    .fb-protocol #ethernet {
        display: flex;
        justify-content: center;
        width: 70%;
        max-width: 3.5rem;
    }

    .rdm-button {
        position: relative;
        justify-self: end;
        font-family: 'Courier New', Courier, monospace;
        font-weight: 600;
        line-height: 25px;
        text-align: center;
    }

    .fieldbus .rdm-button {
        bottom: -55px;
        right: -10px;
    }

    #rdm-config {
        padding: var(--padding-large) var(--padding-small) 0 var(--padding-small);
        display: grid;
        grid-column: 2/3;
        grid-row: 2/3;
    }

    #rdm-config .card {
        position: relative;
    }

    #rdm-config .rdm-button {
        position: absolute;
        bottom: -5px;
        right: -5px;
    }

    #text-config-container {
        z-index: 2000;
        margin-right: var(--padding-large);
        grid-column: 2;
        align-self: end;
    }

    #text-config-container.card {
        min-width: 530px;
        position: relative;
        display: grid;
        grid-template-columns: 2fr 1fr;
        grid-template-rows: 6fr 1fr;
        grid-column: 2/8;
        align-self: inherit;
        color: var(--ll-yellow-font);
        min-width: 620px;
    }

    #text-config, .xml-text-button {
        cursor: pointer;
        font-size: var(--font-size-small);
        height: 50px;
        width: 90px;
        border: 2px solid var(--ll-yellow-font);
        border-radius: 10px;
        border-color: var(--ll-yellow-font);
        color: var(--ll-yellow-font);
    }

    .card #text-config {
        grid-row: 2;
        margin-bottom: var(--padding-medium);
        margin-left: var(--padding-medium);
        align-self: end;
    }

    #xml-text-area {
        display: none;
        resize: none;
        margin: var(--padding-medium) 0 0 var(--padding-medium);
        background-color: var(--bg-coal);
        color: var(--ll-yellow-font);
    }

    p#help-text {
        grid-column: 2;
        grid-row: 1;
        padding: var(--padding-medium);
        display: none;
        
    }

    #push{
        margin: 0 var(--padding-medium) var(--padding-medium) 0;
        align-self: end;
        justify-self: end;
    }

    #upload-container, #download-container {
        position: relative;
        text-decoration: none;
        grid-column: 2;
        grid-row: 1;
        align-self: end;
        left: var(--padding-medium)
    }

    #upload-container {
        padding: 2px;
        height: auto;
        width: 82px;
        height: 42px;
        line-height: 43px;
        text-align: center;
        margin-bottom: 60px;
    }

    #upload {
        display: none;
    }

    .xml-text-button {
        display: none;
    }

    .card #xml-text-area, .card p#help-text, .card .xml-text-button {
        display: inline-block;
    }

    /* ============= RDM-Table ============== */

    #rdm-table {
        font-family: var(--font-regular);
        margin: var(--padding-large);
    }

    #rdm-table tr:nth-child(odd) {
        background-color: #575757;
    }

    #rdm-table #headerRow {
        font-size: 1.5rem;
        color: var(--ll-yellow-font);
    }

    #rdm-table td {
        padding:  0.5rem 1rem;
    }


    /* ============= Dynamic resizing ============== */
    
    @media screen and (max-width: 950px) {
        :root {
            --grid-nav-width: 21vw;
        }

        .address-container h3 {
            white-space: inherit;
        }

    }

    @media screen and (max-width: 780px) {
        #title {
            margin-top: 20px;
        } 

        #sidebar h2{
            font-size: 1.5rem;
        }

        nav h2:nth-child(1) {
            margin-top: 15px;
        }
        
        .node {
            font-size: var(--font-size-small);
            padding: calc(var(--padding-small) / 2) 0 calc(var(--padding-small) / 2) calc(var(--padding-small) / 2);
        } 

        .node.selected .info {
            display: none;
        } 

        .node.selected #status {
            margin-top: 6px;
            margin-right: 3px;
            width: 5px;
            height: 5px;
        }

        .node.selected #status.config {
            top: 7px
        }

        .node.selected #top-curve:before{
            left: calc(var(--grid-nav-width) - 67px);
            bottom: 7.5px;
        }

        .node.selected #top-curve:after {
            left: calc(var(--grid-nav-width) - 97.5px);
            bottom: 7.5px;
        }

        .node.selected #bottom-curve:before {
            left: calc(var(--grid-nav-width) - 67px);
            top: 7px;
        }

        .node.selected #bottom-curve:after {
            left: calc(var(--grid-nav-width) - 97.5px);
            top: 7.5px;
        }

        .node input {
            width: calc(var(--grid-nav-width) - 3*var(--padding-small) + 5px) ;
        }
    }

    @media screen and (max-width: 641px) {
        body {
            grid-template-columns: 135px 1fr;
        }
        
        .node.selected #top-curve:before, .node.selected #bottom-curve:before {
            left: 68px;
        }

        .node.selected #top-curve:after, .node.selected #bottom-curve:after {
            left: 37.5px;
        }
    }

    /* @media screen and (min-height: 1000px) {
        #accolades h3 {
            left: 20px;
            bottom: -4vh
        }
    } */

    /* @media screen and (max-height: 668px) {
        body {
            grid-template-rows: var(--banner-height) calc(768px - var(--banner-height) - var(--padding-small));
        }
    } */


</style>
<script>
    let nodeIp = "http://2.121.17.247"

    const SWITCHPARAMS = ["status", "rxByteCount", "txByteCount", "rxBroadcast", "txBroadcast", "rxUnicast", "txUnicast", "rxMulticast", "txMulticast", "rxPause", "txPause"]
    const ARTNETPARAMS = ["universe", "keep", "framecounter"];
    const FIELDBUSPARAMS = ["codec", "startAddress", "streamLength", "finetuningParams"];

    const REFRESHINTERVAL = 20000000;  

    class Installation {
        #customer;
        #nodes = [];
        #prevNodes = [];
        #lightMode = false;
        // activeNode and activeNodeElement public property is available

        #maxShownUniverses = 10;
        #minShownUniverses = 4;
        #shownUniverses = 6;

        #rdmCounter = 0;

        // Immediately Invoked Async Function Expression zorgt ervoor dat we de nodes kunnen ophalen en nieuwe
        // object instanties kunnen aanmaken zonder then-chaining of extra async functies te gebruiken 
        // https://itnext.io/1-minute-to-become-a-better-developer-4-aeabd6586396
        constructor(customer){
            return (async () => {
                this.#customer = customer;
                await this.fetchNodes(true);
                for (let i = 0; i < 1; i++) {
                    let hexValue = i.toString(16);
                    if (hexValue.length < 2) {
                        hexValue = hexValue.padStart(2, '0');
                    }
                    this.addDemo(hexValue);
                }
                // this.#prevNodes.push(this.#nodes);
                if (localStorage.getItem("configuration") === "enabled") {
                    this.config = true;
                } else this.config = false;
                this.configElement = document.querySelector("body");
                this.universesContainer = document.querySelector("#universe-container");
                this.textConfigElement = document.querySelector("#text-config-container");
                this.textConfig = false;
                this.rdmConfig = false;
                return this;
            })();
        }

        get nodes(){
            return this.#nodes;
        }

        get prevNodes() {
            return this.#prevNodes;
        }

        get shownUniverses() {
            return this.#shownUniverses;
        }

        get maxShownUniverses() {
            return this.#maxShownUniverses;
        }

        get minShownUniverses() {
            return this.#minShownUniverses;
        }

        get rdmCounter() {
            let prevCount = this.#rdmCounter;
            this.#rdmCounter++;
            if (this.#rdmCounter = 256) this.#rdmCounter = 0;
            return prevCount.toString(16).toUpperCase();
        }

        set rdmCounter(rdc) {
            this.#rdmCounter = rdc;
        }

        set shownUniverses(su) {
            this.#shownUniverses = su;
        }

        changeShownUni(up){
            up? this.#shownUniverses++ : this.#shownUniverses--;
        }

        pushPrevNodes(pn) {
            this.#prevNodes.unshift(pn);
            if (this.#prevNodes.length > 2) this.#prevNodes.pop();
        }

        async fetchNodes(init) {
            try {
                //      `${init? "" : "http://" + this.activeNode.ip}/xdev`
                const response = await fetch(`${nodeIp}/xdev`, {signal: AbortSignal.timeout(2000)});
                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                let foundNodes = [];
                let devices = xmlDoc.getElementsByTagName("dev")[0].innerHTML.split(" ");
                for (let device of devices) {
                    let ip = hexToIP(device);
                    let oldNodes = [];
                    let node;
                    try {
                        node = await new Node(ip, false, [...this.#prevNodes] );    
                    } catch(error) {
                        console.error(`there was an error fetching node with ip ${ip}\n ${error}`)
                        continue;
                    };
                    if (node !== undefined) foundNodes.push(node);
                }
                
                if (init && !localStorage.getItem("activeNode")) {
                    foundNodes[0].active = true;
                    this.activeNode = foundNodes[0];
                    localStorage.setItem("activeNode", this.activeNode.mac);
                }

                this.pushPrevNodes(foundNodes);

                if (init) {
                    this.nodeOrder = foundNodes;
                    this.#nodes = foundNodes;
                } else {
                    this.#nodes = [];
                    this.nodeOrder.forEach((n) => {
                        let newNode = foundNodes.find((fn) => fn.ip === n.ip)
                        if (newNode) this.#nodes.push(newNode);
                    })
                }

            } catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");
                    return [];
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.error("AbortSignal.timeout() method is not supported");
                } else {
                    console.error("Failed to fetch Nodes:", error.message);
                }
            }
        }

        addDemo(mac){
            let universes = [];
            let fieldbusses = [];
            for (let i=0; i<10; i++){
                universes.push(new Universe(`inp${i+1}`, i, 512, 0));
            }
            for (let i=0; i<6; i++){
                fieldbusses.push(new Fieldbus(`out${i}`, 2, i == 0? 1 : (i*512)+1, 512, 0));
            }
            let demoNode = new NodeTemplate("127.0.0.1", null, "Demo", `7b:a6:80:7f:ec:${mac}`, {}, "255.255.255.0", universes, fieldbusses, ["Disabled", "Used-by-previous-channel", "DMX-512", "DMX-RDM"], "v3.1", new Configuration(null, true));
            demoNode.configuration.setXmlConfig(demoNode);
            if (demoNode.mac === localStorage.getItem("activeNode")) {
                this.nodes.map((node) => node.active = false);
                demoNode.active = true;
            }
            // demoNode.active = true; // Uncomment this line if there are no fysical nodes connected
            this.#nodes.push(demoNode);           
        }

        updateNav(init){
            let generateNode = (node, lm) => {
                let nodeElement = document.createElement("li");
                nodeElement.classList.add("node");
                nodeElement.id = node.UID;
                if (!this.config | node.active === false) {
                    nodeElement.innerHTML = `
                    <div id="top-curve"></div>
                        <div id="status"></div>
                        <h3 id="name">${node.name}</h3>
                        <ul class="info ${lm} configurable">
                            <li class="IP">IP: <p>${node.ip}</p></li>
                            <li class="netMask">Netmask: <p>${node.netmask}</p></li>
                            <li class="mac">MAC: <p>${node.mac}</p></li>
                        </ul>
                    <div id="bottom-curve"></div>
                    `
                    
                } else {
                    nodeElement.innerHTML = `
                    <div id="top-curve"></div>
                    <div class="config" id="status"></div>
                    <h3 id="name">${node.name}</h3>
                    <form class="node-form">
                        <label for="new-name"> Name:</label><br>
                        <input type="text" id="new-name" value="${node.name}"><br>
                        <label class="form-label" for="new-ip"> IP:</label><br>
                        <input type="text" id="new-ip" value=${node.ip}><br>
                        <label class="form-label" for="new-mask"> Netmask:</label><br>
                        <input type="text" id="new-mask" value=${node.netmask}><br>
                        <div id="submit-wrapper">
                            <input type="submit" value="Push to node">
                        </div>
                    </form>
                    <div id="bottom-curve"></div>`
                    }
                return nodeElement;
            }

            let navBar = document.getElementById("node-list");
            navBar.innerHTML="";
            this.#nodes.forEach(node => {
                let activeNode;
                if (node.mac === localStorage.getItem("activeNode")) activeNode = true;
                let nodeElement = generateNode(node, this.lm);
                if (!node.online) nodeElement.classList.add("disconnected");
                if (this.lm) nodeElement.classList.add("light");
                if (init) {
                    if (node.active || activeNode) {
                        nodeElement.classList.add("selected");
                        node.active = true;
                        this.activeNode = node;
                        if (this.config) nodeElement.children[2].hidden = true;
                    }
                } else {
                    if (node.active) {
                        nodeElement.classList.add("selected");
                        this.activeNode = node;
                        if (this.config) nodeElement.children[2].hidden = true;
                    }
                    else {
                        nodeElement.children[3].hidden = true;
                    }
                }
                navBar.appendChild(nodeElement);
            });

            if (init) {
                const fpsInterval = setInterval(() => this.activeNode.updateFps(), 1000);
                const statusInterval = setInterval(async () => {
                    for (const node of this.nodes) {
                        if (!isDemo(node.mac) && node.active === false) {
                            try {
                                const response = await fetch(`http://${node.ip}/xart`, {signal: AbortSignal.timeout(2000)});
                                if (!response.ok) {
                                    throw new Error(`Response status: ${response.status}`);
                                }
                                node.setStatus(true);               
                            } 
                            catch (error) {
                                if (error.name === "TimeoutError") {
                                    console.error("Request timed out");
                                    node.setStatus(false);     
                                } else if (error.name === "AbortError") {
                                    console.error("Fetch aborted by user");
                                } else if (error.name === "TypeError") {
                                    console.error("AbortSignal.timeout() method is not supported");
                                } else {
                                    console.error("Failed to update fps:", error.message);
                                }
                            }
                        }
                    }      
                }, 5000);
                
                // this.initaliseConfig();
            } // else this.showActiveNode();
            this.initialiseConfig();
        }

        initialiseConfig() {
            this.fieldbussesElement = document.getElementById("fieldbusses");
            this.fieldbussesElement.setAttribute('style', `grid-template-columns: repeat(${this.activeNode.fieldbusses.length}, 2fr)` )
            this.fieldbussesElement.innerHTML = '';
            
            let counter = 1;
            this.activeNode.fieldbusses.forEach(fb => {
                fb.fbElement =  generateDomTree("div", null, { id: `fb-${counter}`, class: "fieldbus card" }, [
                                    generateDomTree("div", null, { class: "address range" }, [
                                        generateDomTree("h1", `FIELDBUS ${counter}`),
                                        generateDomTree("div", null, { id: `address-block-${counter}`, class: "patch" }, [
                                            generateDomTree("div", null, { class: "top-handle draggable" }),
                                            generateDomTree("div", null, { class: "address-container draggable" }, [
                                                generateDomTree("h2", "start: ", { class: "draggable start" }, [
                                                    generateDomTree("span")
                                                ]),
                                                generateDomTree("h2", null, { class: "draggable stream" })]),
                                            generateDomTree("div",null, { class: "bottom-handle draggable" })
                                        ])
                                ]), 
                                generateDomTree("div", null, { class: "fb-protocol info" }),
                                generateDomTree("div", "i", {class: "rdm-button e-button", style: "visibility: hidden"}, null, {"click": installation.toggleRdmConfig})])
                this.fieldbussesElement.appendChild(fb.fbElement);
                counter++;    
            })

            this.showActiveNode();
            
            this.fetchConfigInterval ??= setInterval(async () => {
                await this.refreshPage();
            }, REFRESHINTERVAL);
        }

        showActiveNode() {
            let main                = document.getElementById("main-config");
            let uniC                = document.querySelector("#universe-container");
            let uni                 = document.getElementById("universes");
            let uniFilter           = document.querySelector("#universe-filter-container");
            let textC               = document.querySelector("#text-config-container");
            let firmwareVersion     = document.querySelector("#firmware span");
            let configVersion       = document.querySelector("#config span");
            
            this.activeNodeElement  = document.getElementById(`${this.activeNode.UID}`);  
            this.universesElement   = document.getElementById("universes");

            let ePort2 = document.querySelector("#eth2");
            if (Object.keys(this.activeNode.switch).length === 0) {
                ePort2.hidden = true;
            } else {
                ePort2.hidden = false;
            }

            const requiredUniverses = this.activeNode.fieldbusses.reduce((maxUniverses, fieldbus) => {
                const endAddress = (fieldbus.startAddress + fieldbus.streamLength) -1;
                const universesForFieldbus = Math.ceil(endAddress / 512);
                return Math.max(maxUniverses, universesForFieldbus);
            }, 0);

            if (installation.shownUniverses < requiredUniverses) {
                installation.shownUniverses = requiredUniverses;
            }

            this.universesElement.innerHTML = '';
            main.style.gridTemplateRows     = `repeat(${installation.shownUniverses}, 1fr) 25px 75px`; 
            firmwareVersion.innerHTML       = this.activeNode.firmware;

            let counter = 1;
            this.activeNode.universes.forEach((uni) => {
                if (counter <= installation.shownUniverses) {
                    let u = document.createElement("li");
                    u.style.padding = "0px"
                    u.classList.add("range");
                    if (this.lm) u.classList.add("light");
                    if (this.config) {
                        // let inputU = document.createElement("input");
                        let inputU = generateDomTree("input", null, {id: `universe-${counter}`, universe: uni.id, type: "number", value: uni.universe, min: 1, max: 32468 });
                        let inputK = generateDomTree("input", null, {id: `keep-${counter}`, universe: uni.id, type: "number", value: uni.keep, min: 1, max: 512});
                        u.appendChild(inputU);
                        u.appendChild(inputK);
                    } else {
                        u.innerHTML = `${uni.universe}<span class="range ${this.lm}">${uni.keep}</span>`
                        u.style.padding = "0.5rem"
                    }
                    this.universesElement.appendChild(u);
                }        
                counter++;
            })

            uniC.style.gridRow          = `1/${installation.shownUniverses+2}`;
            uni.style.gridRow           = fieldbusses.style.gridRow = `1/${installation.shownUniverses+3}`;
            uniFilter.style.gridRow     = textC.style.gridRow = `${installation.shownUniverses+2}`;
            
            if (!this.textConfig) {
                textC.style.gridRow = `${installation.shownUniverses+2}`;
            } else {
                this.fieldbussesElement.style.gridTemplateColumns = "subgrid";
                this.fieldbussesElement.style.gridColumn = "8/10"
            }

            counter = 1;
            this.activeNode.fieldbusses.forEach((fb) => {
                fb.fieldbusElement  = document.querySelector(`#fb-${counter}`);
                fb.addressRange     = document.querySelector(`#fb-${counter} .address.range`);
                fb.addressBlock     = document.querySelector(`#address-block-${counter}`);
                fb.startElement     = document.querySelector(`#fb-${counter} .address-container h2.start`);
                fb.streamElement    = document.querySelector(`#fb-${counter} .address-container h2.stream`);
                fb.codecElement     = document.querySelector(`#fb-${counter} .fb-protocol`);
                // fb.patch = document.querySelector(".patch");

                if (fb.codec === 0) {
                    fb.addressBlock.hidden = true;
                } else fb.addressBlock.hidden = false;

                if (this.activeNode.codecs[fb.codec].toLowerCase().includes("rdm")) {
                    fb.fieldbusElement.querySelector(".rdm-button").style.visibility = "visible";
                }

                if (this.textConfig) {
                    fb.fieldbusElement.style.position = "relative";
                    fb.fieldbusElement.style.zIndex = `${1000 + this.activeNode.fieldbusses.length-(counter-1)}`;
                    fb.fieldbusElement.style.gridColumn = "1";
                    fb.fieldbusElement.style.justifySelf = "center";
                    fb.fieldbusElement.style.left = `${(counter-2)*(this.fieldbussesElement.clientWidth/7.5)}px`;
                    fb.fieldbusElement.style.marginRight = `${10/this.activeNode.fieldbusses.length}px`;
                }

                // setting all the gridRows
                fb.fieldbusElement.style.gridRow = `1/${installation.shownUniverses+3}`
                if (fb.codec === 1) {
                    fb.fieldbusElement.style.gridRow = `${installation.shownUniverses+1}/${installation.shownUniverses+3}`
                    fb.addressRange.hidden = true;
                    // adding arrow pointing to the previous channel
                    // check if the arrow hasn't been added before
                    if (!document.querySelector(`#fb-${counter} #arrowSvg`)) {
                        const arrowTemplate = document.querySelector("#arrow-template");

                        const clone = arrowTemplate.content.cloneNode(true);
                        const svg = clone.querySelector("svg");
                        
                        let arrow = document.createElement("div");
                        arrow.id = "arrowSvg"
                        arrow.appendChild(svg);
                        fb.fieldbusElement.appendChild(arrow);
                        arrow.style.width = "55%"
                        arrow.style.alignSelf = "end";
                        arrow.style.justifySelf = "center"
                        arrow.style.gridColumn = "1";
                        arrow.style.gridRow = "1";

                    }
                } else {
                    let arrow = document.querySelector(`#fb-${counter} #arrowSvg`);
                    if (arrow) {
                        arrow.parentNode.removeChild(arrow);
                    }
                    fb.fieldbusElement.style.gridRow = `1/${installation.shownUniverses+3}`
                    fb.addressRange.hidden = false;
                }

                fb.addressRange.style.gridRow   = `1/${installation.shownUniverses+1}`;
                fb.codecElement.style.gridRow   = `${installation.shownUniverses+1}/${installation.shownUniverses +3}`;

                // Config elements for start and streamlength
                let startElement;
                let streamElement;

                if (this.config) {
                    fb.addressBlock.classList.add("config");
                    startElement    =   generateDomTree("h2", null, {class: "configurable start"}, [
                                            generateDomTree("label", "start: <br>", {for: `fb${counter}-startAddress`, class: "draggable"}, [
                                                generateDomTree("input", null, {id: `fb${counter}-startAddress`, fieldbus: fb.id, type: "number", min: "1", max: `${(this.shownUniverses*512)-1}`, value: `${fb.startAddress}`}, null)])]);
                    streamElement   =   generateDomTree("h2", null, {class: "configurable stream"}, [
                                            generateDomTree("label", "length: <br>", {for: `fb${counter}-streamLength`, class: "draggable"}, [
                                                generateDomTree("input", null, {id: `fb${counter}-streamLength`, fieldbus: fb.id, type: "number", min: "1", max: `${(this.shownUniverses*512)-1}`, value: `${fb.streamLength}`}, null)])]);
                } else {
                    fb.addressBlock.classList.remove("config");
                    startElement    =   generateDomTree("h2", "start: ", { class: "draggable non-configurable start" }, [
                                            generateDomTree("span", fb.startAddress)]);
                    streamElement   =   generateDomTree("h2", "length: <br>", { class: "draggable non-configurable stream" }, [
                                            generateDomTree("span", fb.streamLength, {class: "draggable"})]);
                }

                fb.addressHeight = fb.addressRange.getBoundingClientRect()["height"]*(fb.streamLength/(512*installation.shownUniverses));

                fb.startElement.replaceWith(startElement);
                fb.streamElement.replaceWith(streamElement);

                // Updating all the fb.addressblock heights and startpositions
                // Height = streamlength, top = startaddres
                let start   = String((fb.startAddress/(512*installation.shownUniverses))*100)+"%";
                let stream  = String((fb.streamLength/(512*installation.shownUniverses))*100)+"%";
                
                fb.addressBlock.style.height = stream;
                fb.addressBlock.style.top = start;
                
                fb.startElement = document.querySelector(`#fb-${counter} .address-container h2.start`);
                fb.streamElement = document.querySelector(`#fb-${counter} .address-container h2.stream`);
                
                if (fb.codec !== 0 && fb.codec !== 1) checkOverflow(fb.addressBlock, !this.config, fb.addressHeight);

                // if (counter > installation.shownUniverses) {
                //     fb.addressBlock.hidden = "true";
                // }

                const ACTIVECODEC = this.activeNode.codecs[fb.codec].split(" ")[0];

                const LABEL = generateDomTree("label", null,  {for: `fb-${counter}-codec`});
                    LABEL.innerHTML = "Codec: "
                    const SELECT = generateDomTree("select", null, {name: "codec", id: `fb-${counter}-codec`});
                    for (let i=0; i<this.activeNode.codecs.length; i++) {
                        const OPTION = document.createElement("option", {value: `${this.activeNode.codecs[i].split(" ")[0]}`});
                        const CONTENT = document.createTextNode(`${this.activeNode.codecs[i].split(" ")[0]}`);
                        if (this.activeNode.codecs[i].split(" ")[0] === ACTIVECODEC) {
                            OPTION.selected = true;
                        }
                        OPTION.appendChild(CONTENT);
                        SELECT.appendChild(OPTION);
                    }
                LABEL.appendChild(SELECT);
                
                let rj45 = generateDomTree("div", `<svg width="60%" viewBox="0 0 512 490.43">  
                                            <use href="#ethernet-port"/>
                                        </svg>`, { id: "ethernet" })
                
            
                fb.codecElement.innerHTML = '';
                if (this.config) {
                    fb.codecElement.appendChild(LABEL);
                } else {
                    let h2 = generateDomTree("h2", "Codec: ");
                    let h3 = generateDomTree("h3", ACTIVECODEC);
                    fb.codecElement.appendChild(h2);
                    fb.codecElement.appendChild(h3);
                }
                if (fb.codec !== 1) fb.codecElement.appendChild(rj45);
                
                counter++;
            });

            this.accoladesElement           = document.getElementById("accolades");   
            this.accoladesElement.innerHTML = '';   

            const template = document.getElementById("brace-template");

            counter = 1;
            this.activeNode.universes.forEach(un => {
                if (counter <= installation.shownUniverses) {
                    const braceColor = this.lm ? "rgb(77,77,77)" : "#FFF200";
                    const className = this.lm;
                
                    // Clone the template content
                    const clone = template.content.cloneNode(true);
                    const svg = clone.querySelector("svg");
                    let vb = 55 - this.shownUniverses * Math.pow(2, 0.8);
                    svg.setAttribute("viewBox", `${vb} 0 2000 72`);
                
                    // Replace color placeholders
                    svg.innerHTML = svg.innerHTML
                        .replaceAll("__COLOR__", braceColor)
                        .replace("__CLASS__", className)
                        .replace("__FS__", this.shownUniverses * Math.pow(2, 0.8)+"px");
  
                    const a = document.createElement("div");
                    // a.style.marginLeft = `${this.#accMargin}px`;
                    a.id = `accolade-${counter}`;
                    a.classList.add("accolade");
                    a.appendChild(svg);
                    
                    this.accoladesElement.appendChild(a);
                }
                counter++;
            });

            // this.setAccHeight()
            
            // mark double universes in red
            this.checkDoubleUnis();

            if (this.textConfig) {
                    this.textConfigElement.style.gridRow = `1/${this.shownUniverses+3}`
                }
        
            if (this.config) {
                // setting the event listener for the form
                let forms = document.getElementsByClassName("node-form");
                let form = this.activeNodeElement.children[3];
                Array.from(forms).forEach((form) => {
                    form.removeEventListener("submit", this.activeNode.processForm);
                })
                form.addEventListener("submit", this.activeNode.processForm);
            }
            
            if (this.configElement.classList.contains("loading")) {
                this.configElement.classList.remove("loading");
            }

            if (this.activeNode.online) {
                this.addEventHandlers();
                installation.configElement.classList.remove("loading");
                
            } else {
                this.removeEventHandlers();
                installation.configElement.classList.add("loading");
            }
        }

        setAccHeight() {
            let accDiv = document.querySelector(".accolade");
            let accHeight = accDiv.getBoundingClientRect()["height"];
            for(let i = 0; i < this.accoladesElement.children.length; i++) {
                // this.accoladesElement.children[i].children[0].style.height = accHeight+"px";
                this.accoladesElement.children[i].children[0].style.marginLeft = -130 + (this.shownUniverses * 10) + (accHeight/62 * 10)
            }
        }

        checkDoubleUnis() {
            let unis = document.querySelectorAll("#universes li");
            let uni;
            let keep;
            
            unis.forEach((uni) => uni.classList.remove("illegal"));
            
            let uniArr = [];
            for (const uni of unis) {
                this.config? uniArr.push(uni.children[0].value) : uniArr.push((uni.innerHTML).split("<")[0]);
            }
            let dupObj = {};
            uniArr.forEach((element, index, array) => {
                dupObj[element] = Array.from(array.entries()).reduce((indices, [i, e]) => {
                    if (element === e) {
                        indices.push(i);
                    }
                    return indices;
                }, []);
            });
            
            const setDuplicateError = (i) => {
                let uni = document.querySelector(`#universes li:nth-child(${i+1})`);
                uni.classList.add("illegal")
            }

            for (const duplicates of Object.values(dupObj)){
                if (duplicates.length === 2) {
                    setDuplicateError(duplicates[1])
                }
                else if (duplicates.length > 2) {
                    duplicates.shift();
                    for (const i in duplicates) {
                        setDuplicateError(duplicates[i])
                    }
                }           
            }
        }

        eventInit() {
            window.onresize = (e) => {
                // calculating the height of the accolades
                // this.setAccHeight();

                if (this.textConfig) {
                    let fieldbusContainers = document.querySelectorAll(".fieldbus");
                    for (let i=0; i<fieldbusContainers.length; i++) {
                        fieldbusContainers[i].style.left = `${(i-1)*(this.fieldbussesElement.clientWidth/7.5)}px`;
                        // fieldbusContainers[i].style.marginRight = `${10/6}px`;      
                    }
                }

                this.activeNode.fieldbusses.forEach((fb) => {
                    fb.addressHeight = fb.addressRange.getBoundingClientRect()["height"]*(fb.streamLength/(512*installation.shownUniverses));
                    if (fb.codec !== 0 && fb.codec !== 1) checkOverflow(fb.addressBlock, !this.config, fb.addressHeight);
                })
            }
            
            const dmSwitch          = document.querySelector("#dark-mode-switch input");
            const configSwitch      = document.querySelector("#edit-switch");
            const savedDarkMode     = localStorage.getItem("darkMode");

            if (this.config) {
                configSwitch.checked    = true;
            } else configSwitch.checked = false;

            if (savedDarkMode === "enabled") {
                dmSwitch.checked    = true;
            } else dmSwitch.checked = false;

            this.switchDarkMode(dmSwitch);
            dmSwitch.addEventListener("change", (e) => {
                this.switchDarkMode(dmSwitch)
            });

            const uniButtons = document.querySelectorAll("#universe-filter .e-button");
            for (const button of uniButtons) {
                button.addEventListener("click", () => {
                    const accolades = document.querySelectorAll("#accolades div");
                    if (button.id === "increment") {
                        if (this.shownUniverses < this.activeNode.universes.length) {
                            this.changeShownUni(true);
                        }
                    } else if (button.id === "decrement") {
                        if (this.shownUniverses > this.minShownUniverses) {
                            let overLap = false;
                            for (const fb of this.activeNode.fieldbusses) {
                                if ((fb.startAddress + fb.streamLength)-1 > (this.shownUniverses-1) * 512) {
                                    overLap = true;
                                }
                            }
                            if (!overLap) {
                                this.changeShownUni(false);
                            }        
                        }
                    }
                    this.initialiseConfig();
                })
            }

            let editButton = document.querySelector("#edit-switch");
            editButton.addEventListener("change", (e) => {
                const checkBox = document.querySelector("#edit-switch");
                if (checkBox.checked) {
                    this.config = true;
                    localStorage.setItem("configuration", "enabled");
                    this.updateNav(false)
                } else {
                    this.config = false;
                    localStorage.setItem("configuration", "disabled");
                    this.updateNav(false);
                }
                
                if (this.textConfig) {
                    this.textConfigElement.style.gridRow = `1/${this.shownUniverses+3}`
                }  
                this.navSwitcher();    
            })

            this.textConfigButton = document.querySelector("#text-config");
            this.textConfigButton.addEventListener("click", this.switchTextConfig);

            this.addEventHandlers();

            console.log(this.configElement.querySelector("#rdm-config .rdm-button"));
            this.configElement.querySelector("#rdm-config .rdm-button").addEventListener(("click"), this.toggleRdmConfig);
        }
        
        addEventHandlers() {
            this.configElement.addEventListener("click", this.handleFbEvent);
            this.configElement.addEventListener("mousedown", this.handleFbEvent);
            this.configElement.addEventListener("change", this.handleFbEvent);
            this.configElement.addEventListener("input", this.handleFbEvent);
            this.configElement.addEventListener("focusin", this.handleFbEvent);
            this.configElement.addEventListener("focusout", this.handleFbEvent);
            this.configElement.addEventListener("keydown", this.handleFbEvent);
            this.configElement.addEventListener("mousemove", this.handleFbEvent);
            this.configElement.addEventListener("mouseup", this.handleFbEvent);
        }

        removeEventHandlers() {
            this.configElement.removeEventListener("click", this.handleFbEvent);
            this.configElement.removeEventListener("mousedown", this.handleFbEvent);
            this.configElement.removeEventListener("change", this.handleFbEvent);
            this.configElement.removeEventListener("input", this.handleFbEvent);
            this.configElement.removeEventListener("focusin", this.handleFbEvent);
            this.configElement.removeEventListener("focusout", this.handleFbEvent);
            this.configElement.removeEventListener("keydown", this.handleFbEvent);
            this.configElement.removeEventListener("mousemove", this.handleFbEvent);
            this.configElement.removeEventListener("mouseup", this.handleFbEvent);
        }

        switchTextConfig = (e) => {
            this.textConfig = !this.textConfig;
            let fieldbusContainers = document.querySelectorAll(".fieldbus");
            if (this.textConfig) {
                clearInterval(installation.fetchConfigInterval);
                this.universesContainer.style.display = "none";
                this.accoladesElement.style.display = "none";
                this.fieldbussesElement.style.gridTemplateColumns = "subgrid";
                this.fieldbussesElement.style.gridColumn = "8/10";
                for (let i=0; i < this.activeNode.fieldbusses.length; i++) {
                    fieldbusContainers[i].style.position = "relative";
                    fieldbusContainers[i].style.zIndex = `${1000 + this.activeNode.fieldbusses.length-i}`;
                    fieldbusContainers[i].style.gridColumn = "1";
                    fieldbusContainers[i].style.justifySelf = "center";
                    fieldbusContainers[i].style.left = `${(i-1)*(this.fieldbussesElement.clientWidth/7.5)}px`;
                    fieldbusContainers[i].style.marginRight = `${10/this.activeNode.fieldbusses.length}px`;
                }
                this.textConfigElement.classList.add("card");
                this.textConfigElement.style.gridRow = `1/${installation.shownUniverses+3}`
                this.textArea = document.querySelector("#xml-text-area");
                if (isDemo(this.activeNode.mac)) {
                    this.activeNode.configuration.setXmlConfig(this.activeNode);
                    this.textArea.value = this.activeNode.configuration.textConfig;
                } 
                else {
                    this.textArea.value = this.activeNode.configuration.textConfig;
                }          
                this.textArea.hidden = false;

            } else {
                this.universesContainer.style.display = "grid";
                this.accoladesElement.style.display = "grid";
                this.textConfigElement.classList.remove("card");
                this.fieldbussesElement.setAttribute('style', `grid-template-columns: repeat(${this.activeNode.fieldbusses.length}, 2fr)` )
                this.fieldbussesElement.style.gridRow = `1/${this.shownUniverses+3}`
                for (let i=0; i < this.activeNode.fieldbusses.length; i++) {
                    fieldbusContainers[i].style.position = "relative";
                    fieldbusContainers[i].style.zIndex = `${this.activeNode.fieldbusses.length-i}`;
                    fieldbusContainers[i].style.gridColumn = `${i + 1}`;
                    fieldbusContainers[i].style.left = "0px";
                    fieldbusContainers[i].style.justifySelf = "end";
                    fieldbusContainers[i].style.marginRight = "0px";
                }
                let accDiv = document.querySelector(".accolade");
                let accHeight = accDiv.getBoundingClientRect()["height"];
                for(let i = 0; i < this.accoladesElement.children.length; i++) {
                    this.accoladesElement.children[i].children[0].style.height = accHeight;
                }
                installation.fetchConfigInterval ??= setInterval(async () => {
                    await this.refreshPage();
                }, REFRESHINTERVAL);
            }

            // adding event listeners for the buttons
            this.textConfigElement.addEventListener("click", this.handleTextConfig);
            this.fileInput = document.querySelector("#upload");
            this.fileInput.addEventListener("change", this.handleUpload);
            this.textArea.addEventListener("input", this.handleTextInput);
        }

        handleUpload = (e) => {
            const conf = this.fileInput.files[0];
            const reader = new FileReader();

            reader.onload = () => {
                const result = reader.result;
                this.textArea.value = result;
            }

            reader.onerror = function () {
                console.error('error reading the file');
            }

            reader.readAsText(conf, 'utf-8');
        }

        handleTextConfig = (e) => {
            switch(e.target.id) {
                case "download":
                    console.log("downloading");
                    console.log(e.target.parentElement);
                    const fileURL = URL.createObjectURL(this.activeNode.configuration.textConfigBlob);
                    e.target.parentElement.href = fileURL;
                    break;
                case "push":
                    if (!isDemo(this.activeNode.mac)) {
                        this.activeNode.configuration.postXmlConfig(this.textArea.value, true);
                    } else {
                        console.log("generating config object");
                        this.activeNode.configuration.generateConfigObject(this.textArea.value);
                        this.activeNode.initialiseNode(true);
                        this.updateNav(false);
                        this.navSwitcher();
                    }
                    break;
                default:
                    break;
            }
        }

        handleTextInput = (e) => {
            this.activeNode.configuration.generateTextBlob(e.target.value);
        }

        handleFbEvent = (e) => {
            e.stopPropagation();
            if (e.target.classList.contains("e-button") || e.target.tagName === "OPTION") {
                return;
            }

            if (e.key === "Enter") {
                e.preventDefault();
                let elements = document.querySelectorAll("input");
                console.log(elements);
                let illegalChecker = () => {
                    for (const element of elements) {
                        if (document.activeElement === element) {
                            return element.classList.contains("illegal") ? true : false;
                        }
                    }
                }

                if (!illegalChecker()) {
                    let param = e.target.id.split("-")[1];
                    this.target[param] = parseInt(e.target.value);
                    if (this.target) {
                        this.activeNode.configuration.handleInputChange(this.target);
                    }
                    this.inputSelection = false;
                }
            }

            if (e.type === "focusin" && (e.target.id !== "text-config" 
                                            && e.target.closest("div").id !== "text-config-container"
                                            && e.target !== undefined)
                                            && e.target.name !== "codec") {
                clearInterval(installation.fetchConfigInterval);;
                let focusedElement = e.target.id.split('-')[0][0] === "f" ? "fieldbus" : "universe";
                if (focusedElement === "fieldbus") {
                    this.target = this.activeNode.fieldbusses.find((fb) => fb.id === e.target.getAttribute("fieldbus"));
                }
                else {
                    this.target = this.activeNode.universes.find((uni) => uni.id === e.target.getAttribute("universe"));
                }
                this.inputSelection = true;
                e.target.select();
            }
            // ======================== UNIVERSES =======================

            if (e.type !== "mousemove" && e.type !== "mouseup" && e.type !== "click") {
                if ((e.target.id.split("-")[0] === "universe" || e.target.id.split("-")[0] === "keep")) {
                    if (e.type === "input") {
                        if (!this.target) this.target = this.activeNode.universes.find((uni) => uni.id === e.target.getAttribute("universe"));
                        let min, max;
                        if (e.target.id.split("-")[0] === "universe") {
                            min = 1, max = 32767;
                        } else min = 500, max = 512;
                        let inputValue = e.target.value;
                        if (inputValue < min || inputValue > max) {
                            e.target.classList.add("illegal");
                        }
                        else {
                            e.target.classList.remove("illegal");
                        }
                        installation.checkDoubleUnis();
                        if (!e.target.classList.contains("illegal")) {
                            let param = e.target.id.split("-")[0];
                            this.target[param] = parseInt(e.target.value);
                        }
                    }

                    if (e.type === "focusout") {
                        if (e.target.classList.contains("illegal")) {
                            e.target.value = this.activeNode.universes.find((uni) => uni.id === e.target.getAttribute("universe"))[e.target.id];
                            e.target.classList.remove("illegal");
                        }
                    }
                    
                    if (e.type === "change") {
                        e.target.select();
                        if (e.target.classList.contains("illegal")) {
                            return;
                        }
                        let param = e.target.id.split("-")[0];
                        this.target[param] = parseInt(e.target.value);
                        return;
                    }
                    
            // ======================== FIELDBUSSES =======================
               
                } else if (e.target.classList.contains("draggable") || e.target.tagName === "SELECT" && e.type === "change" || e.target.tagName === "INPUT" && e.target.hasAttribute("fieldbus")) {
                    this.targetFb = e.target.closest(".fieldbus").id.slice(-1)-1;
                    this.targetFb = this.activeNode.fieldbusses.find((fb) => fb.id === `out${this.targetFb}`);
                    if (e.target.tagName === "INPUT") {
                        if (e.type === "input") {
                            console.log(e.target)
                            if (!this.target) this.target = this.activeNode.fieldbusses.find((fb) => fb.id === e.target.getAttribute("fieldbus"));
                            let inputStream = e.target.closest(".address-container").querySelector(".stream input").value;
                            let inputStart  = e.target.closest(".address-container").querySelector(".start input").value;
                            let min = 1, max = e.target.id.split("-")[1] === "startAddress" ? installation.shownUniverses*512 - inputStream : installation.shownUniverses*512 - inputStart +1;
                            let inputValue = e.target.value;
                            if (inputValue < min || inputValue > max) {
                                e.target.classList.add("illegal");
                            }
                            else {
                                e.target.classList.remove("illegal");
                            }

                            // if (!e.target.classList.contains("illegal")) {
                            //     let param = e.target.id.split("-")[1];
                            //     this.target[param] = parseInt(e.target.value);
                            // }
                        }

                        if (e.type === "focusout") {
                            if (e.target.classList.contains("illegal")) {
                                e.target.value = this.activeNode.fieldbusses.find((fb) => fb.id === e.target.getAttribute("fieldbus"))[e.target.id];
                                e.target.classList.remove("illegal");
                            } else {
                                this.activeNode.configuration.handleInputChange(this.target);
                            }
                            this.inputSelection = false;
                            return
                        }

                        if (e.type === "change") {
                            e.target.select();

                            if (e.target.classList.contains("illegal")) {
                                return;
                            }
                            let param = e.target.id.split("-")[1];
                            this.target[param] = parseInt(e.target.value);
                            return;
                        }
                    }
                }            
            }

            if (this.targetFb !== undefined && !this.inputSelection) {
                switch(e.type) {
                    case "mousedown":
                        this.targetFb.setStart(e);
                        break;
                    case "change":
                        this.targetFb.handleCodecChange(e);
                        this.targetFb = undefined;
                        break;
                    case "mousemove":
                        this.targetFb.setMove(e);
                        break;
                    case "mouseup":
                        this.targetFb.updateValues(e);
                        this.targetFb = undefined;
                        break;
                    default:
                        break;
                }
            } 
        }

        handleNavClick = (e) => {
            let nodeElement = e.currentTarget;
            // resetting the nodes to their inactive state
            this.#nodes.map((node) => {node.active = false});

            let nodes = document.getElementsByClassName("node");
            for (let n of nodes) {
                n.classList.remove("selected");
            }

            if (!nodeElement.classList.contains("selected")) {
                nodeElement.classList.add("selected");
                let node = this.#nodes.find((n) => n.UID === nodeElement.id);
                if (this.lm) nodeElement.classList.add("light");
                node.active = true;
                this.activeNode = node;
                localStorage.setItem("activeNode", node.mac);
                this.shownUniverses = this.activeNode.universes.length < this.shownUniverses ? this.activeNode.universes.length : this.shownUniverses; 
                // setting the xml config value and event listeners              
            }
            this.updateNav(false);
            if (this.textConfig) {
                this.textArea.value = this.activeNode.configuration.textConfig;
                this.textConfigElement.style.gridRow = `1/${this.shownUniverses+3}`
                let fieldbusContainers = document.querySelectorAll(".fieldbus");
                this.universesContainer.style.display = "none";
                this.accoladesElement.style.display = "none";
                this.fieldbussesElement.style.gridTemplateColumns = "subgrid";
                this.fieldbussesElement.style.gridColumn = "8/10";
                for (let i=0; i < fieldbusContainers.length; i++) {
                    fieldbusContainers[i].style.position = "relative";
                    fieldbusContainers[i].style.zIndex = `${1000 + fieldbusContainers.length-i}`;
                    fieldbusContainers[i].style.gridColumn = "1";
                    fieldbusContainers[i].style.justifySelf = "center";
                    fieldbusContainers[i].style.left = `${(i-1)*(this.fieldbussesElement.clientWidth/7.5)}px`;
                    fieldbusContainers[i].style.marginRight = `${10/fieldbusContainers.length}px`;
                }
            }
            this.navSwitcher();

        }

        navSwitcher() {
            let nodes = document.querySelectorAll(".node");
            // removing all the previously attached event Listeners
            nodes.forEach((node) => node.removeEventListener("click", this.handleNavClick));
            let inactiveNodes = Array.from(nodes).filter((node) => !node.classList.contains("selected"));
            
            inactiveNodes.forEach((nodeElement) => {
                // Event listener to switch the active node
                nodeElement.addEventListener("click", this.handleNavClick);
            })       
        }

        toggleRdmConfig = async (e) => {
            let targetFb = e.target.closest(".fieldbus.card");
            console.log(targetFb);
            // Todo get the id of the fieldbus were trying to get information frome
            this.rdmConfig = !this.rdmConfig;
            if (this.rdmConfig) {
                this.configElement.querySelector("#main-config").innerHTML = "";
                this.configElement.querySelector("#rdm-config").style.visibility = "visible";

                // fetching all the devices
                await this.showRdmConfig(0)

            } else {
                this.configElement.querySelector("#rdm-config").style.visibility = "hidden";
                this.showActiveNode();
            }      
        }

        async showRdmConfig(fieldbus) {
            try {
                const response = await fetch(`${nodeIp}/xtod`, {signal: AbortSignal.timeout(2000)});
                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                let rdmConfig = Configuration.parseConfig(xmlDoc);
                let rdmDevices = rdmConfig[`out${fieldbus}`].split(" ");
                console.log(rdmDevices);
                sendRdmPacket(nodeIp, 0, rdmDevices[0], "GET", "DEVICE_INFO");
                // let devices = xmlDoc.getElementsByTagName("dev")[0].innerHTML.split(" ");               
            } 
            catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");    
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.error("AbortSignal.timeout() method is not supported");
                } else {
                    console.error("Failed to update fps:", error.message);
                } 
            }
        }

        switchDarkMode(sw) {
            let accolades = document.querySelectorAll(".accolade path");
            let buttonSvgs = document.querySelector("#edit svg path");
            let body = document.querySelector("body");

            if (sw.checked === true) {
                this.lm = "light";
                localStorage.setItem("darkMode", "enabled");
                body.classList.add("light");
                for (const accolade of accolades) {
                    accolade.style.stroke = "#4d4d4d";
                }
                buttonSvgs.style.stroke = "#4d4d4d";
                buttonSvgs.style.fill = "#4d4d4d";
            } else {
                this.lm = "";
                localStorage.setItem("darkMode", "disabled");
                for (const accolade of accolades) {
                    accolade.style.stroke = "#FFF200"
                }
                buttonSvgs.style.stroke = "#FFF200";
                buttonSvgs.style.fill = "#FFF200";
                body.classList.remove("light");
            }
        }

        async refreshPage() {
            let demoNodes = [];
            for (const n of this.nodes) {
                if (isDemo(n.mac)) demoNodes.push(n) ;
            }
            await this.fetchNodes(false);
            demoNodes.forEach((node) => this.nodes.push(node))
            this.updateNav(false);
            this.navSwitcher();
        }
    }

    class Node {
        #oldNodes = [];
        #ip;
        #name;
        #mac;
        #switch = {};
        #netmask;
        #configuration;
        #universes = [];
        #fieldbusses = [];
        #codecs = [];
        #firmware;
        #lastUpdate;
        #online = true;
        #active = false;

        #timestamp;
        #prevTimestampOff = null;
        #prevTimestampOn = null;

        constructor(ip, skipConfig = false,  oldNodes = null) {
            this.#ip = ip;
            
            if (!skipConfig) {
                return (async () => {
                    try {
                        this.#configuration = await new Configuration(ip);
                        if (this.#configuration) {
                            if (oldNodes !== null) {
                                this.#oldNodes = [...oldNodes];
                            };       
                            this.initialiseNode();
                            console.log("initialisation complete")
                            return this;
                        }
                    } catch(error) {
                        console.error(error);
                    }
                    
                })();
            }
        }

        get ip() {
            return this.#ip;
        }

        get name() {
            return this.#name;
        }

        get mac() {
            return this.#mac;
        }

        get UID() {
            return this.#mac.replaceAll(":", "");
        }

        get netmask() {
            return this.#netmask;
        }

        get universes() {
            return this.#universes;
        }

        get fieldbusses() {
            return this.#fieldbusses;
        }

        get configuration(){
            return this.#configuration;
        }

        get codecs() {
            return this.#codecs;
        }

        get firmware() {
            return this.#firmware;
        }
        
        get active() {
            return this.#active;
        }

        get online() {
            return this.#online;
        }

        get switch() {
            return this.#switch;
        }

        
        set ip(ip) {
            let reIP = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

            if (!reIP.test(ip)) {
                console.log("Invalid IP format");
                return;
            }

            let ipParts = ip.split('.').map(Number);
            let maskParts = this.#netmask.split('.').map(Number);

            let broadcastParts = ipParts.map((octet, index) => octet | (255 - maskParts[index]));

            if (ipParts.every((octet, index) => octet === broadcastParts[index])) {
                console.log("This is a broadcast address and is not allowed.");
                return;
            }

            console.log("This is a valid IP address.");
            this.#ip = ip;
        }

        set name(name){
            if (typeof name !== "string" || name.trim().length === 0) {
                console.log("Invalid name: must be a non-empty string.");
                return;
            }
            this.#name = name.trim();
        }

        set mac(mac){
            let reMAC = /^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$/;
            if (!reMAC.test(mac)) {
                console.log("Invalid MAC address: must be in the format XX:XX:XX:XX:XX:XX.");
                return;
            }
            this.#mac = mac.toUpperCase();
        }

        set switch(sw){
            this.#switch = sw;
        }

        set firmware(fw) {
            this.#firmware = fw;
        }

        set netmask(nm){
            let reNetmask = /^(255|254|252|248|240|224|192|128|0)\.((255|254|252|248|240|224|192|128|0)\.){2}(255|254|252|248|240|224|192|128|0)$/;
            if (!reNetmask.test(nm)) {
                console.log("Invalid netmask: must be a valid subnet mask.");
                return;
            }
            this.#netmask = nm;
        }

        set universes(un){
            if (!Array.isArray(un) || un.length !== 10 || !un.every(u => u instanceof Universe)) {
                console.log("Invalid universes: must be an array of 10 Universe objects.");
                return;
            }
            this.#universes = un;
        }

        set fieldbusses(fb){
            if (!Array.isArray(fb) || fb.length !== 6 || !fb.every(f => f instanceof Fieldbus)) {
                console.log("Invalid fieldbusses: must be an array of 6 Fieldbus objects.");
                return;
            }
            this.#fieldbusses = fb;
        }

        set codecs(c){
            this.#codecs = c;
        }

        set active(a) {
            this.#active = a;
        }

        set configuration(c) {
            this.#configuration = c;
        }

        // setting the status indicator of the disconnected nodes, debounce to make sure there is no
        // flickering
        setStatus(o) {
            let node = document.getElementById(this.UID);
            this.#timestamp = new Date().getTime();
            if (o) {
                if (this.#prevTimestampOn === null) {
                    this.#prevTimestampOn = this.#timestamp;
                }
                if ((this.#timestamp-this.#prevTimestampOn) > 1) {
                    this.#online = o;
                    node.classList.remove("disconnected");
                    installation.configElement.classList.remove("loading");
                    this.#prevTimestampOn = new Date().getTime;
                    this.#prevTimestampOff = null;
                    installation.addEventHandlers();
                }         
            } else {
                if (this.#prevTimestampOff === null) {
                    this.#prevTimestampOff = this.#timestamp;
                }
                if ((this.#timestamp-this.#prevTimestampOff) > 1) {
                    this.#online = o;
                    node.classList.add("disconnected");
                    if (this.ip === installation.activeNode.ip) {
                        installation.configElement.classList.add("loading");
                    }
                    this.#prevTimestampOff = new Date().getTime;
                    this.#prevTimestampOn = null;
                    installation.removeEventHandlers();
                }         
            }    
        }

        initialiseNode(demo = false) {
            if (this.#configuration !== null) {
                this.#name = this.#configuration.name;
                if (!demo) {
                    this.#mac = this.#configuration.mac;
                    if (localStorage.getItem("activeNode") === this.#mac) {
                        this.#active = true;
                    }
                }

                try {
                    this.#switch = this.#configuration.switch;
                } catch(error) {
                    console.log("Node found without switch")
                }
                
                
                this.#netmask = this.#configuration.mask;
                this.#firmware = this.#configuration.firmware;

                let prevNode;
                if (this.#oldNodes[0] !== undefined) {
                    prevNode = this.#oldNodes[0].find((node) => node.mac === this.#mac)
                }
                let counter = 0;
                let fbIndex = 0;
                let resetFb = false;
                let fieldbusses = [];
                let artnet = [];
                let codecs = [];
                for (const [key, value] of Object.entries(this.#configuration.fieldbus)) {
                    let params = [];
                    for (let v of Object.values(value)) {
                        params.push(v);
                    }
                    let fieldbus = new Fieldbus(key, ...params);

                    fieldbusses.push(fieldbus);
                    counter++;
                }
                this.#fieldbusses = fieldbusses; 

                for (const [key, value] of Object.entries(this.#configuration.artnet)) {
                    let params = [];
                    for (let v of Object.values(value)){
                        params.push(v);
                    }
                    artnet.push(new Universe(key, ...params));
                }
                this.#universes = artnet;
                
                for (const value of Object.values(this.#configuration.codec)) {
                    codecs.push(value);
                }
                this.#codecs = codecs;                          
            }
        }

        async updateFps() {
            // if not demo
            if (!isDemo(this.mac)) {
                try {
                    const response = await fetch(`http://${this.ip}/xart`, {signal: AbortSignal.timeout(2000)});
                    if (!response.ok) {
                        throw new Error(`Response status: ${response.status}`);
                    }
                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                    let parsedXart = Configuration.parseConfig(xmlDoc);
                    let newTime = new Date().getTime();
                    if (this.#lastUpdate > 0) {
                        let delta = newTime - this.#lastUpdate;
                        for (let uni = 0; uni < this.universes.length; uni++) {
                            let fps = 0;
                            let AnIn = parseInt(((parsedXart[`in${uni}`]).split(" "))[0])
                            let AnOut = (parseInt(this.universes[uni]["framecounter"]))
                            fps = (AnIn + 8192 - AnOut)%8192;
                            fps = Math.trunc(Math.round(fps/(delta/10000))/10);
                            let fpsElement = document.querySelector(`#accolade-${uni+1} text`);
                            if (fpsElement != null) {
                                fpsElement.innerHTML = `${fps}fps`;
                            }                        
                            // Updating the universes with the latest received framecounter
                            this.universes[uni]["framecounter"] = ((parsedXart[`in${uni}`]).split(" "))[0]
                        }
                    }
                
                if (!this.#online) this.setStatus(true);
                this.#lastUpdate = newTime;
                
            } 
                catch (error) {
                    if (error.name === "TimeoutError") {
                        console.error("Request timed out");
                        if (this.#online) this.setStatus(false);
                    } else if (error.name === "AbortError") {
                        console.error("Fetch aborted by user");
                    } else if (error.name === "TypeError") {
                        console.error("AbortSignal.timeout() method is not supported");
                    } else {
                        console.error("Failed to update fps:", error.message);
                    }
                }
            }        
        }

        processForm = (e) => {
            e.preventDefault();
            e.stopPropagation();
            let name = document.getElementById("new-name");
            let mask = document.getElementById("new-mask");
            let ip = document.getElementById("new-ip");
            this.name = name.value;
            this.netmask = mask.value;
            this.ip = ip.value;
            console.log(this.name);
            if (!isDemo(this.mac)) this.configuration.handleFormChange(this);
        }
    }

    class NodeTemplate extends Node {
        constructor(ip, oldNode, name, mac, sw, nm, un, fb, c, fw, config){
            super(ip, true, oldNode);
            this.name = name;
            this.mac = mac;
            this.switch = sw;
            this.netmask = nm;
            this.universes = un;
            this.fieldbusses = fb;
            this.codecs = c;
            this.firmware = fw;
            this.configuration = config;
        }
    }

    class Universe {
        #id;
        #universe;
        #keep;
        #framecounter;

        #paramBytes = 4;

        constructor(id, universe, keep, framecounter) {
            this.#id = id;
            this.#universe = universe;
            this.#keep = keep;
            this.#framecounter = framecounter;
        }

        get id() {
            return this.#id;
        }

        get universe() {
            return this.#universe;
        }

        get keep() {
            return this.#keep;
        }

        get framecounter() {
            return this.#framecounter
        }

        set framecounter(f) {
            this.#framecounter = f;
        }

        set universe(u) {
            this.#universe = u;
        }

        set keep(k) {
            this.#keep = k;
        }
    }

    class Fieldbus {
        #id;
        #codec;
        #startAddress;
        #streamLength;
        #finetuningParams

        constructor(id, codec, startAddress, streamLength, finetuningParams) {
            this.#id = id;
            this.#codec = codec;
            this.#startAddress = startAddress;
            this.#streamLength = streamLength;
            this.#finetuningParams = finetuningParams;
        }

        get id () {
            return this.#id;
        }

        get codec() {
            return this.#codec;
        }

        get startAddress() {
            return this.#startAddress;
        }

        get streamLength() {
            return this.#streamLength;
        }

        get finetuningParams() {
            return this.#finetuningParams;
        }

        set streamLength(s) {
            this.#streamLength = s;
        }

        set startAddress(s) {
            this.#startAddress = s;
        }

        set codec(c) {
            this.#codec = c;
        }

        setStart = (e) => {
            clearInterval(installation.fetchConfigInterval);
            switch (e.target.classList[0]) {
                case "top-handle": 
                    this.start = "top"
                    e.target.closest(".patch").classList.add("top");
                    break;
                case "address-container":
                case "draggable":
                    if (e.target.offsetParent.classList.contains("overflow") && e.target.tagName === "H3") break;
                    this.start = "patch";
                    e.target.closest(".patch").classList.add("mid");
                    break;
                case "bottom-handle":
                    this.start = "bottom"
                    e.target.closest(".patch").classList.add("bottom");
                    break;
                default:
                    return;
            }
            this.startedDrag = true;
            this.startCoord = e.clientY;
            this.targetFb = e.target.closest(".fieldbus").id;
        }

        setMove = (e) => {
            if (this.startedDrag) {
                this.startedMove = true;
                let changePatch = (newRange = undefined, newStart = undefined) => {
                    let patch = document.querySelector(`#${this.targetFb} .address.range .patch`);
                    let start = document.querySelector(`#${this.targetFb} .address.range h2.start`);
                    let stream = document.querySelector(`#${this.targetFb} .address.range h2.stream`);
                    if (newRange !== undefined) {
                        this.newRange = Math.floor(newRange);
                        let rangeElement;
                        let status = !document.querySelector(".patch").classList.contains("config");
                        if (status) {
                            rangeElement = document.querySelector(`#${this.targetFb} .address-container h2.stream span`);
                            rangeElement.innerHTML = this.newRange;
                        } else {
                            rangeElement = document.querySelector(`#${this.targetFb} .address-container h2.stream input`);
                            rangeElement.value = this.newRange;
                        }
                        patch.style.height = String((this.newRange/(512*installation.shownUniverses))*100)+"%";

                        checkOverflow(patch, status);
                    }
                    if (newStart !== undefined) {
                        this.newStart = Math.floor(newStart);
                        patch.style.top = String((newStart/(512*installation.shownUniverses))*100)+"%";
                        let startElement;
                        if (!document.querySelector(".patch").classList.contains("config")) {
                            startElement = document.querySelector(`#${this.targetFb} .address-container h2.start span`);
                            startElement.innerHTML = this.newStart;
                        } else {
                            startElement = document.querySelector(`#${this.targetFb} .address-container h2.start input`);
                            startElement.value = this.newStart;
                        }    
                    }
                }

                const threshold = 50;
                let newRange = 0;
                let newStart = 0;
                let dif = 0;
                const addressRange = document.querySelector(`#fb-${parseInt(this.#id.split("out")[1])+1} .address.range`);
                const addressesPerPixel = (512*installation.shownUniverses)/addressRange.getBoundingClientRect()["height"];

                switch (this.start) {
                    case "top":
                        const offsetTop = this.startCoord-e.clientY;
                        newStart = this.#startAddress - (offsetTop*addressesPerPixel);
                        newRange = this.#streamLength + (offsetTop*addressesPerPixel);
                        for (let i=0; i<= installation.shownUniverses; i++) {
                            dif = newStart - (512*i);
                            if (dif > -threshold && dif < threshold) {
                                let hop = (512*i) - newStart;
                                newStart = 512*i+1;
                                newRange = newRange - hop -1 ;
                                break;
                            }
                        }

                        if (newRange < 1) {
                            newRange = 1;
                            newStart = this.#startAddress + this.#streamLength - 2;
                        }

                        if (newStart < 1) {
                            newStart = 1;
                            newRange = this.#startAddress + this.#streamLength -1 ;
                        }
                        changePatch(newRange, newStart);
                        break;
                    case "bottom":
                        const offsetBottom = this.startCoord-e.clientY;
                        newRange = this.#streamLength - (offsetBottom*addressesPerPixel);
                        // snapping to full universes
                        for (let i=0; i<= installation.shownUniverses; i++) {
                            dif = (512*i-(this.#startAddress+newRange));
                            if (dif < threshold && dif > -threshold){
                                newRange = (512*i)-(this.#startAddress-1)
                                break;
                            }
                        }
                        // bottom and top limits
                        if (this.startAddress + newRange > 512*installation.shownUniverses) newRange = (512*installation.shownUniverses)-(this.#startAddress-1);
                        if (newRange < 1) newRange = 1;
                        changePatch(newRange);
                        break;  
                    case "patch":
                        const offset = this.startCoord-e.clientY;
                        newStart = this.#startAddress - (offset*addressesPerPixel);
                        for (let i=0; i<= installation.shownUniverses; i++) {
                            dif = newStart - (512*i);
                            if (dif > -threshold && dif < threshold) {
                                newStart = (512*i) + 1;
                                break;
                            }          
                        }
                        if (newStart < 1) newStart = 1;
                        else if (newStart + this.#streamLength > 512*installation.shownUniverses) newStart = (512*installation.shownUniverses) - this.#streamLength;
                        changePatch(undefined, newStart);
                        break
                    default:
                        break;           
                }
            }
        }

        updateValues = (e) => {
            if (e.target.tagName === "INPUT" && !this.startedMove) {
                return;
            }
            let fbs = document.querySelectorAll(".patch");
            fbs.forEach((fb) => fb.classList.remove("top", "mid", "bottom"));

            this.start = '';
            this.startedDrag = this.startedMove = false;   
            if (this.newRange !== undefined) this.#streamLength = this.newRange;
            if (this.newStart !== undefined) this.#startAddress = this.newStart;
            
            if (!isDemo(installation.activeNode.mac)) {
                installation.activeNode.configuration.handleInputChange(this);
            }
        }

        handleCodecChange = (e) => {
                let target = e.target;
                let value = target.value;

                this.codec = target.selectedIndex;

                if (!isDemo(installation.activeNode.mac)) {
                    installation.activeNode.configuration.handleInputChange(this, true);
                } else installation.showActiveNode();
            }
    }

    class Configuration {
        #xmlConfig;
        #configObject;
        #textConfig;
        #textConfigBlob;

        // look up table for the amount of hex characters per parameter
        #ioHexCount = {
            "artnet": {
                "universe": 4,
                "keep": 4,
            },
            "fieldbus": {
                "codec": 2,
                "startAddress": 4,
                "streamLength": 4,
            }
            
        }

        constructor(ip, skipConfig = false){
            if (!skipConfig) {
                return( async () => {
                    try {
                        this.#xmlConfig = await this.fetchXmlConfig(ip);
                    }
                    catch (error) {
                        console.error(error)
                    }
                    if (this.#xmlConfig) {
                        this.#configObject = Configuration.parseConfig(this.#xmlConfig);
                        console.log(this.#configObject);
                        // filling a text config blob for download with XML button
                        this.#textConfigBlob = new Blob([this.generateTextConfig()], {type: 'text/plain'});    
                        return this;
                    }
                })();
            }           
        }

        get xmlConfig(){
            return this.#xmlConfig;
        }

        get textConfig() {
            return this.#textConfig;
        }

        get configObject(){
            return this.#configObject;
        }

        get name() {
            return dig(this.#configObject, "name");
        }

        get mac() {
            return hexToMac(dig(this.#configObject, "mac"));
        }

        get mask() {
            return hexToIP(dig(this.#configObject, "mask"));
        }

        get switch() {
            return this.convertObjectAndMap(SWITCHPARAMS, "switch")
        }

        get fieldbus() {
            return this.convertObjectAndMap(FIELDBUSPARAMS, "fieldbus");
        }

        get artnet() {
            return this.convertObjectAndMap(ARTNETPARAMS, "artnet");
        }

        get codec() {
            return this.#configObject["codec"];
        }

        get firmware() {
            return this.#configObject["sys"]["fw"];
        }

        get textConfigBlob() {
            return this.#textConfigBlob;
        }

        async fetchXmlConfig(ip) {
            try {
                const response = await fetch(`http://${ip}/xml`, {signal: AbortSignal.timeout(2000)});
                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                return xmlDoc;
            } 
            catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.log("One or more nodes were found where CORS is not enabled, please contact system administrator Jeff Van Themsche")
                } else {
                    console.error("Failed to fetch XML configuration:", error.message);
                }
            }
        }

        async postXmlConfig(xml, xmlConfig = false) {
            installation.removeEventHandlers();
            installation.configElement.classList.add("loading");

            let trimmedXml = "";
            if (xmlConfig) {
                 // Deleting the codec from the xml
                let startIndex = xml.indexOf("<codec>");
                let stopIndex = xml.indexOf("</codec>");
                let newXml = xml.substring(0, startIndex)+xml.substring(stopIndex+8);

                let xmlArr = newXml.split("\n");
                let tagFound = false;
                for (const line of xmlArr) {
                    let trimmedLine = line.trim();
                    trimmedXml+=trimmedLine;
                }
                console.log(trimmedXml);
            } else console.log(xml);    
               
            try {
                const response = await fetch(`http://${installation.activeNode.ip}/xml`, {
                    signal: AbortSignal.timeout(2000),
                    method: "POST",
                    body: xmlConfig? trimmedXml: xml
                })

                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                let responseObj = Configuration.parseConfig(xmlDoc);
                console.log("Changed parameters: " + hexToDec(responseObj["changed"]));
                let errPos = hexToDec(responseObj["fault"])
                console.log("Fault detected at: " + errPos);
                if (errPos !== 0) {
                    let errString = "";
                    for (let i = errPos - 10; i < errPos + 10; i++) {
                        if (i !== errPos) {
                            errString += trimmedXml[i];
                        } else {
                            errString += " >>> ";
                            errString += trimmedXml[i];
                            errString += " <<< "
                        }            
                    }
                    console.log(errString);
                }

                await installation.refreshPage();

                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }

            }
            
            catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.error("AbortSignal.timeout() method is not supported");
                } else {
                    console.error("Failed to post XML configuration:", error.message);
                }
            }
        }

        handleFormChange(n) {
            let xmlText = '<node>\n';
            xmlText += `\t<sys>\n`;
            xmlText += `\t\t<ip>${ipToHex(n.ip)}</ip>\n`;
            xmlText += `\t\t<mask>${ipToHex(n.netmask)}</mask>\n`;
            xmlText += `\t\t<name>${n.name}</name>\n`;
            xmlText += `\t</sys>\n`;
            xmlText += '</node>';
            this.postXmlConfig(xmlText);
        }

        handleInputChange(io, codec = false) {   
            let xmlText = '<node>'
            io.id[0] === "i"? xmlText += '<artnet>' : xmlText += '<fieldbus>';
            xmlText += `<${io.id}>`
            io.id[0] === "i"? xmlText += hexConverter(this.#ioHexCount["artnet"], io.universe, io.keep) : xmlText += 
                !codec? hexConverter(this.#ioHexCount["fieldbus"], io.codec, io.startAddress, io.streamLength) : hexConverter(this.#ioHexCount["fieldbus"], io.codec);
            xmlText += `</${io.id}>`
            io.id[0] === "i"? xmlText += '</artnet>' : xmlText += '</fieldbus>';
            xmlText += '</node>';
            this.postXmlConfig(xmlText);
        }

        convertObjectAndMap(mapParams, tag) {
            let convertedObject = {};
            for (const [key,value] of Object.entries(dig(this.#configObject, tag))){
                convertedObject[key] = {}
                let params = value.split(" ");
                for (let i = 0; i < params.length; i++) {
                    convertedObject[key][mapParams[i]] = parseInt(params[i], 16);
                }
            }
            return convertedObject;
        }

        static parseConfig(xmlObj) {
            let config = {};
            
            // Recursive function that traverses over each node and fills a config object
            function traverseConfig(xmlNode, config) {
                if (xmlNode !== null && typeof xmlNode === 'object') {
                    for (let i = 0; i < xmlNode.childNodes.length; i++) {
                        const childNode = xmlNode.childNodes.item(i);
                        if (childNode.nodeType === 1) {
                            if (childNode.childElementCount > 0) {
                                config[childNode.nodeName] = {};
                                traverseConfig(childNode, config[childNode.nodeName]);
                            } else {
                                config[childNode.nodeName] = childNode.textContent.trim();
                            }
                        }
                    }
                }
            }

            traverseConfig(xmlObj.documentElement, config);
            return config;
        }

        generateConfigObject(xmlText) {
            console.log(xmlText);
            let parser = new DOMParser();
            let xmlObj = parser.parseFromString(xmlText, "text/xml");
            this.#configObject = Configuration.parseConfig(xmlObj);
            this.generateTextConfig();
        }

        generateTextConfig() {
            let xmlText = "<node>\n";
            // Filling the textConfig with information from the fetched object
            function traverseObject(configObject, lvl = 1) {
                if (configObject !== null && typeof configObject === 'object') {
                    for (const [key, value] of Object.entries(configObject)) {
                        if (typeof value === 'object') {
                            xmlText += `${'  '.repeat(lvl)}<${key}>\n`;
                            traverseObject(value, lvl + 1);
                            xmlText += `${'  '.repeat(lvl)}</${key}>\n`;
                        } else {
                            xmlText += `${'  '.repeat(lvl)}<${key}>${value}</${key}>\n`;
                        }
                    }
                }
            }
        
            traverseObject(this.#configObject);
            xmlText += "</node>";
            this.#textConfig = xmlText;
            this.#textConfigBlob = new Blob([xmlText], {type: 'text/plain'});
            return xmlText;
        }

        setXmlConfig(node) {
            let xmlText  = '<node>\n'
            xmlText     += `  <sys>\n`
            xmlText     += `    <ip>${ipToHex(node.ip)}</ip>\n`
            xmlText     += `    <mask>${ipToHex(node.netmask)}</mask>\n`
            // xmlText     += `    <mac>${macToHex(node.mac)}</mac>\n`
            xmlText     += `    <name>${node.name}</name>\n`
            xmlText     += `  </sys>\n`
            xmlText     += '  <artnet>\n'
            node.universes.forEach((uni) => {
                xmlText += `    <${uni.id}>${hexConverter(this.#ioHexCount["artnet"],uni.universe, uni.keep)}</${uni.id}>\n`
            })
            xmlText += '  </artnet>\n'
            xmlText += '  <fieldbus>\n'
            node.fieldbusses.forEach((fieldbus) => {
                xmlText += `    <${fieldbus.id}>${hexConverter(this.#ioHexCount["fieldbus"],fieldbus.codec, fieldbus.startAddress, fieldbus.streamLength)}</${fieldbus.id}>\n`
            })
            xmlText += '  </fieldbus>\n'
            xmlText += '</node>'
            this.#textConfig = xmlText;
            this.#textConfigBlob = new Blob([xmlText], {type: 'text/plain'});
            return xmlText;
        }

        generateTextBlob(xmlText) {
            this.#textConfigBlob = new Blob([xmlText], {type: 'text/plain'});
        }
    }

    let mockRdmData = {
        UUID1: {
                parameter1: "value1",
                parameter2: "value2",
                parameter3: "value3"
        },
        UUID2: {
                parameter1: "2value1",
                parameter2: "2value2",
                parameter3: "2value3"
        },
        UUID3: {
                parameter1: "3value1",
                parameter2: "3value2",
                parameter3: "3value3"
        }
    }

    class Table {
        constructor(parentNode, rdmInfo) {
            this.rdmHeader = ["Device", "Parameters", "Values"]
            this.rdmInfo = rdmInfo;
            this.parentNode = parentNode;
            this.addFilters();
            this.generateBaseTable();
            this.addRowEvents();
        }

        addFilters() {
            this.filters = [];
            for (const KEY of Object.keys(this.rdmInfo)){
                console.log(KEY)
                console.log(Object.keys(KEY))
                for(const KEY2 of Object.keys(this.rdmInfo[KEY])){
                    console.log(KEY2)
                    if(!this.filters.includes(KEY2)){
                        this.filters.push(KEY2)
                    }
                }
            }
            console.log(this.filters);
        }

        generateBaseTable() {
            console.log(this.rdmInfo);
            let table = document.createElement("table");
            table.id = "rdm-table"
            let headerRow = document.createElement("tr");
            headerRow.id = "headerRow";
            let counter = 0;
            for (const HEADER of this.rdmHeader) {
                let hTd = document.createElement("td");     
                hTd.innerHTML = HEADER;
                // param filter
                if (counter == 1) {
                    hTd.innerHTML += "<br>"
                    let paramDD = document.createElement("select");
                    paramDD.addEventListener("change", this.applyFilter)
                    paramDD.id = "param-dropdown";
                    let filterItem = document.createElement("option");
                    filterItem.innerHTML = "--Filter--"
                    paramDD.appendChild(filterItem);
                    for (const FILTER of this.filters) {
                        filterItem = document.createElement("option");
                        filterItem.value = FILTER;
                        filterItem.innerHTML = FILTER;
                        paramDD.appendChild(filterItem);
                    }
                    hTd.appendChild(paramDD);
                }
                headerRow.appendChild(hTd)
                counter++;
            }
            table.appendChild(headerRow);

            for (const DEVID of Object.keys(this.rdmInfo)) {
                let dataRow = document.createElement("tr");
                dataRow.id = DEVID;
                for (let i = 0; i < this.rdmHeader.length; i++) {
                    let dTd = document.createElement("td");
                    if (i == 0) {
                        dTd.innerHTML = DEVID;
                        dTd.openedRow = false;
                    } else dTd.innerHTML = null;
                    dataRow.appendChild(dTd);
                }
                table.appendChild(dataRow);
                
            }
            this.parentNode.appendChild(table);
            this.table = document.querySelector("#rdm-table");
            console.log(this.table);
        }

        addRowEvents() {
            let devices = document.querySelectorAll("tr:not(#headerRow) > td:first-child");
            console.log(devices);
            for (const DEVICE of devices) {
                DEVICE.addEventListener("click", this.toggleParameters)
            }
        }

        toggleParameters = (e) => {
            console.log("clicked on " + e.target.innerHTML);
            let targetRow = e.target.closest("tr");
            let parentNode = targetRow.parentNode;
            if (e.target.openedRow === false) {
                console.log(targetRow);
                // let rowsExceptHeader = document.querySelectorAll("#rdm-table tr:not(:first-child)");
                // for (const ROW of rowsExceptHeader) {
                //     this.table.removeChild(ROW);
                // }

                let counter = 0;
                for (const [KEY, VAL] of Object.entries(mockRdmData[e.target.innerHTML])) {
                    console.log(KEY + " " + VAL)
                    let dataRow = document.createElement("tr");
                    dataRow.id = e.target.innerHTML;
                    let data = document.createElement("td");
                    if (counter == 0) {
                            data.innerHTML = e.target.innerHTML
                            data.addEventListener("click", this.toggleParameters)
                            data.openedRow = true;
                        } else {
                            data.innerHTML = ""
                    };
                    dataRow.appendChild(data);
                    data = document.createElement("td");
                    data.innerHTML = KEY;
                    dataRow.appendChild(data);
                    data = document.createElement("td");
                    data.innerHTML = VAL;
                    dataRow.appendChild(data);
                    console.log(targetRow);
                    this.table.insertBefore(dataRow, targetRow);
                    counter++;
                }
                console.log(this.table);
                console.log(targetRow);
                this.table.removeChild(targetRow);
            } else {
                for (let i = 0; i < Object.keys(mockRdmData[e.target.innerHTML]).length-1; i++) {
                    let nr = targetRow.nextSibling;
                    this.table.removeChild(nr)
                }
                let dataWithoutUID = targetRow.querySelectorAll("td:not(:first-child)");
                for (const DATA of dataWithoutUID) {
                    DATA.innerHTML = "";
                }
                targetRow.querySelector("td:first-child").openedRow = false;
            }
        }

        applyFilter = (e) => {
            console.log("changed filter to " + e.target.value)
        }
    }

    // Helper functie om de gewenste value te verkrijgen vanuit een object
    // https://www.30secondsofcode.org/js/s/get-nested-object-value/#search-for-a-deeply-nested-property-in-an-object
    const dig = (obj, target) => 
                target in obj ? obj[target] : Object.values(obj).reduce((acc, val) => {
                    if (acc !== undefined) return acc;
                    if (typeof val === 'object') return dig(val, target);
                }, undefined);

    function hexToDec(hex) {
        let dec = 0;
        for (let i = 0; i < hex.length; i+=2) {
            dec += parseInt(hex.substring(i, i+2), 16);
        }
        return dec;
    }

    function hexToIP(hex){
        let ip = "";
        for(let i = 0; i < hex.length; i+=2){
            ip += parseInt(hex.substring(i, i+2), 16);
            if(i < hex.length - 2){
                ip += ".";
            }
        }
        return ip;
    }

    function ipToHex(ip) {
        let hex = "";
        const octets = ip.split('.');
        for (let i = 0; i < octets.length; i++) {
            let hexValue = parseInt(octets[i]).toString(16).toUpperCase();
            if (hexValue.length < 2) {
                // hexValue = '0' + hexValue; // Ensure two-character hexadecimal
                hexValue = hexValue.padStart(2, '0');
            }
            hex += hexValue;
        }
        return hex;
    }

    function hexToMac(mac){
        let macAddress = "";
        for(let i = 0; i < mac.length; i+=2){
            macAddress += mac.substring(i, i+2);
            if(i < mac.length - 2){
                macAddress += ":";
            }
        }
        return macAddress;
    }

    function macToHex(mac) {
        let hex = "";
        const parts = mac.split(':');
        for (let i = 0; i < parts.length; i++) {
            hex += parts[i].toUpperCase();
        }
        return hex;
    }

    // function demoHexConverter(...params) {
    //     return params.map(param => param.toString(16).toUpperCase()).join(' ');
    // }

    function hexConverter(io, ...params) {
        let paddedHex = '';
        let counter = 0;
        for (const bytecount of Object.values(io)) {
            try {
                paddedHex += params[counter].toString(16).toUpperCase().padStart(bytecount, '0');
                paddedHex += " ";
            } catch (error) {
                // console.log("skipping one parameter while converting to HEX, consider passing a zero if it's in the beginning of the data")
            }
            counter++;
            
        }
        return paddedHex.trim();
    }

    function generateDomTree(tag, value=null, attributes=null, children=null, listeners=null) {
        let root = document.createElement(tag);
        value? root.innerHTML = value : root.textContent = "";
        if (attributes) {
            for (const [key, value] of Object.entries(attributes)) {
                root.setAttribute(key, value);
            }
        }
        if (children) {
            Array.from(children).forEach((childNode) => root.appendChild(childNode));
        }
        if (listeners) {
            for (const [e, f] of Object.entries(listeners)) {
            root.addEventListener((e), f);
            }
        }
        return root;
    }
  
    function checkOverflow(patchContainer, status, ah = null) {
        let patch = patchContainer.children[1];
        let start = patch.children[0];
        let stream = patch.children[1];
        let input;
        let inputHeight = 0;
        let offset = 5;
        if (!status) {
            input = start.children[0].children[1];
            inputHeight = input.clientHeight;
        }

        if (start.clientHeight + stream.clientHeight + 2 * inputHeight >= (ah? ah : patch.clientHeight) - offset) {
            patch.classList.add("overflow");
        } else if (!patch.classList.contains("extreme")) {
            patch.classList.remove("overflow");
        }

        if (patch.classList.contains("overflow")) {
            if (stream.clientHeight + inputHeight >= (ah? ah : patch.clientHeight) - offset) {
                patch.classList.add("extreme");
            } else patch.classList.remove("extreme");
        }
    }

    function isDemo(demoMac) {
        if (demoMac.substring(0, 15) === "7B:A6:80:7F:EC:") {
            return true;
        } return false;
    }

    async function sendRdmPacket(nodeIp, fbId, destinationUID, getSet, param) {
        const PIDMAP = {
            "DEVICE_INFO": {
                "PID": "0060",
                "PDL": "00",
                "PD" : "00"
            },
            "IDENTIFY_DEVICE": {
                "PID": "1000",
                "PDL": "00",
                "PD" : "00"
            }
        }
        let payload = 
`CC0125${destinationUID}123456789ABC${installation.rdmCounter.padStart(2, "0")}00000000${getSet = "GET"? 20 : 30}${PIDMAP[param]["PID"]}${PIDMAP[param]["PDL"]}${PIDMAP[param]["PD"]}`
        
        let CS = (function () {
            let byteArr = []
            for (let i=0; i < payload.length; i+=2) {
                byteArr.push(payload.substring(i,i+2))
            }
            const intArr = byteArr.map((h) => parseInt(h,16));
            let intCS = intArr.reduce((acc, cv) => {return acc + cv}, 0);
            let finalCS = intCS.toString(16).padStart(4, '0');
            console.log(finalCS);
            payload = "<rdm>" + payload + finalCS.toUpperCase() + "</rdm>";
        })();

        try {
            const response = await fetch(`${nodeIp}/xrdm`, {
                method:'POST',
                mode: 'cors', 
                headers: {
                    'Content-Type': 'text/xml',
                    'bindindex': '1'
                },         
                body: `${payload}`
            })
        } catch (error) {
            console.error(error);
        }
    }
    
    // =========================== Program entry point =========================
                                                                               
    let installation;                                                          
                                                                               
    async function intitialise(init) {
        installation = await new Installation("Lux-Lumen");
        installation.updateNav(init);
        installation.navSwitcher();
        if (init) installation.eventInit();  
    }
        
    document.addEventListener("DOMContentLoaded", async () => {
        await intitialise(true);
        let rdmTable = new Table(document.querySelector("#rdm-config .card"), mockRdmData);
    })
    
</script>
<body>
    <header>
        <div id="banner">
            <!-- svg definition of the ethernet ports -->
            <svg xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 490.43">
                <defs>
                    <symbol id="ethernet-port">
                        <path fill-rule="nonzero" d="M29.08 0h453.85c8.04 0 15.28 3.33 20.5 8.55 5.26 5.27 8.57 12.64 8.57 20.53v432.27c0 7.94-3.33 15.23-8.59 20.49-5.25 5.25-12.54 8.59-20.48 8.59H29.08c-7.89 0-15.26-3.31-20.53-8.58C3.33 476.63 0 469.4 0 461.35V29.08c0-8.05 3.3-15.3 8.54-20.54l2.18-1.91A28.741 28.741 0 0 1 29.08 0z"/>
                        <path fill="#CCC" d="M29.08 21.98h453.85c3.9 0 7.09 3.35 7.09 7.1v432.27c0 3.75-3.34 7.1-7.09 7.1H29.08c-3.75 0-7.1-3.19-7.1-7.1V29.08c0-3.91 3.19-7.1 7.1-7.1z"/>
                        <path fill-rule="nonzero" d="M82.08 65.09h348.08c6.53 0 12.4 2.71 16.62 6.93 4.27 4.27 6.95 10.25 6.95 16.65v239.14h-70.87v48.58h-40.95v46.95H171.27v-46.95h-40.94v-48.58H58.5V88.67c0-6.54 2.67-12.42 6.92-16.66 4.3-4.28 10.23-6.92 16.66-6.92z"/>
                        <path fill="#fff" d="M82.08 81.57h348.08c3.9 0 7.1 3.35 7.1 7.1v222.66h-70.88v48.59h-40.95v46.94H187.75v-46.94H146.8v-48.59H74.98V88.67c0-3.91 3.19-7.1 7.1-7.1z"/>
                        <path fill-rule="nonzero" d="M365.43 297.06h71.83c9.09 0 16.47 7.38 16.47 16.48v46.38c0 9.09-7.38 16.47-16.47 16.47h-71.83c-9.09 0-16.48-7.38-16.48-16.47v-46.38c0-9.1 7.39-16.48 16.48-16.48z"/>
                        <path fill="#fff" d="M437.26 313.54h-71.83v46.38h71.83z"/>
                        <path fill-rule="nonzero" d="M74.98 297.06h71.82c9.1 0 16.48 7.38 16.48 16.48v46.38c0 9.09-7.38 16.47-16.48 16.47H74.98c-9.1 0-16.48-7.38-16.48-16.47v-46.38c0-9.1 7.38-16.48 16.48-16.48z"/>
                        <path fill="#fff" d="M74.98 313.54h71.82v46.38H74.98z"/>
                        <rect x="109.2" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="153.91" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="198.62" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="243.33" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="288.03" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="332.74" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="377.45" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                    </symbol>
                </defs>
            </svg>
            <!-- end of ehternet port definition -->
            <div id="eth1">
                <span>ETH1</span>
                <svg viewBox="0 0 512 490.43">  
                    <use href="#ethernet-port"/>
                </svg>
            </div>
            <div id="eth2">
                <span>ETH2</span>
                <svg viewBox="0 0 512 490.43">  
                    <use href="#ethernet-port"/>
                </svg>
            </div>
            <h1>Configurator</h1>
            <div id="edit">
                <input type="checkbox" id="edit-switch" autocomplete="off">
                <label for="edit-switch">
                    <?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
                    <svg height="100%" class="e-button" id="pen" viewBox="0 0 24 24" id="_24x24_On_Light_Edit" data-name="24x24/On Light/Edit" xmlns="http://www.w3.org/2000/svg">
                        <rect id="view-box" width="24" height="24" fill="none"/>
                        <path id="Shape" d="M.75,17.5A.751.751,0,0,1,0,16.75V12.569a.755.755,0,0,1,.22-.53L11.461.8a2.72,2.72,0,0,1,3.848,0L16.7,2.191a2.72,2.72,0,0,1,0,3.848L5.462,17.28a.747.747,0,0,1-.531.22ZM1.5,12.879V16h3.12l7.91-7.91L9.41,4.97ZM13.591,7.03l2.051-2.051a1.223,1.223,0,0,0,0-1.727L14.249,1.858a1.222,1.222,0,0,0-1.727,0L10.47,3.91Z" stroke="#FFF200" transform="translate(3.25 3.25)" fill="#FFF200"/>
                    </svg>
                </label>
            </div>
            <div id="dark-mode-switch">
                <input type="checkbox" id="switch">
                <label for="switch">
                    <?xml version="1.0" encoding="utf-8"?>
                    <svg class="sun" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 50 50">
                        <path d="M 24.90625 3.96875 C 24.863281 3.976563 24.820313 3.988281 24.78125 4 C 24.316406 4.105469 23.988281 4.523438 24 5 L 24 11 C 23.996094 11.359375 24.183594 11.695313 24.496094 11.878906 C 24.808594 12.058594 25.191406 12.058594 25.503906 11.878906 C 25.816406 11.695313 26.003906 11.359375 26 11 L 26 5 C 26.011719 4.710938 25.894531 4.433594 25.6875 4.238281 C 25.476563 4.039063 25.191406 3.941406 24.90625 3.96875 Z M 10.65625 9.84375 C 10.28125 9.910156 9.980469 10.183594 9.875 10.546875 C 9.769531 10.914063 9.878906 11.304688 10.15625 11.5625 L 14.40625 15.8125 C 14.648438 16.109375 15.035156 16.246094 15.410156 16.160156 C 15.78125 16.074219 16.074219 15.78125 16.160156 15.410156 C 16.246094 15.035156 16.109375 14.648438 15.8125 14.40625 L 11.5625 10.15625 C 11.355469 9.933594 11.054688 9.820313 10.75 9.84375 C 10.71875 9.84375 10.6875 9.84375 10.65625 9.84375 Z M 39.03125 9.84375 C 38.804688 9.875 38.59375 9.988281 38.4375 10.15625 L 34.1875 14.40625 C 33.890625 14.648438 33.753906 15.035156 33.839844 15.410156 C 33.925781 15.78125 34.21875 16.074219 34.589844 16.160156 C 34.964844 16.246094 35.351563 16.109375 35.59375 15.8125 L 39.84375 11.5625 C 40.15625 11.265625 40.246094 10.800781 40.0625 10.410156 C 39.875 10.015625 39.460938 9.789063 39.03125 9.84375 Z M 25 15 C 19.484375 15 15 19.484375 15 25 C 15 30.515625 19.484375 35 25 35 C 30.515625 35 35 30.515625 35 25 C 35 19.484375 30.515625 15 25 15 Z M 4.71875 24 C 4.167969 24.078125 3.78125 24.589844 3.859375 25.140625 C 3.9375 25.691406 4.449219 26.078125 5 26 L 11 26 C 11.359375 26.003906 11.695313 25.816406 11.878906 25.503906 C 12.058594 25.191406 12.058594 24.808594 11.878906 24.496094 C 11.695313 24.183594 11.359375 23.996094 11 24 L 5 24 C 4.96875 24 4.9375 24 4.90625 24 C 4.875 24 4.84375 24 4.8125 24 C 4.78125 24 4.75 24 4.71875 24 Z M 38.71875 24 C 38.167969 24.078125 37.78125 24.589844 37.859375 25.140625 C 37.9375 25.691406 38.449219 26.078125 39 26 L 45 26 C 45.359375 26.003906 45.695313 25.816406 45.878906 25.503906 C 46.058594 25.191406 46.058594 24.808594 45.878906 24.496094 C 45.695313 24.183594 45.359375 23.996094 45 24 L 39 24 C 38.96875 24 38.9375 24 38.90625 24 C 38.875 24 38.84375 24 38.8125 24 C 38.78125 24 38.75 24 38.71875 24 Z M 15 33.875 C 14.773438 33.90625 14.5625 34.019531 14.40625 34.1875 L 10.15625 38.4375 C 9.859375 38.679688 9.722656 39.066406 9.808594 39.441406 C 9.894531 39.8125 10.1875 40.105469 10.558594 40.191406 C 10.933594 40.277344 11.320313 40.140625 11.5625 39.84375 L 15.8125 35.59375 C 16.109375 35.308594 16.199219 34.867188 16.039063 34.488281 C 15.882813 34.109375 15.503906 33.867188 15.09375 33.875 C 15.0625 33.875 15.03125 33.875 15 33.875 Z M 34.6875 33.875 C 34.3125 33.941406 34.011719 34.214844 33.90625 34.578125 C 33.800781 34.945313 33.910156 35.335938 34.1875 35.59375 L 38.4375 39.84375 C 38.679688 40.140625 39.066406 40.277344 39.441406 40.191406 C 39.8125 40.105469 40.105469 39.8125 40.191406 39.441406 C 40.277344 39.066406 40.140625 38.679688 39.84375 38.4375 L 35.59375 34.1875 C 35.40625 33.988281 35.148438 33.878906 34.875 33.875 C 34.84375 33.875 34.8125 33.875 34.78125 33.875 C 34.75 33.875 34.71875 33.875 34.6875 33.875 Z M 24.90625 37.96875 C 24.863281 37.976563 24.820313 37.988281 24.78125 38 C 24.316406 38.105469 23.988281 38.523438 24 39 L 24 45 C 23.996094 45.359375 24.183594 45.695313 24.496094 45.878906 C 24.808594 46.058594 25.191406 46.058594 25.503906 45.878906 C 25.816406 45.695313 26.003906 45.359375 26 45 L 26 39 C 26.011719 38.710938 25.894531 38.433594 25.6875 38.238281 C 25.476563 38.039063 25.191406 37.941406 24.90625 37.96875 Z"></path>
                    </svg>
                    <svg class="moon" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 122.88 122.89" style="enable-background:new 0 0 122.88 122.89" xml:space="preserve"><g><path d="M49.06,1.27c2.17-0.45,4.34-0.77,6.48-0.98c2.2-0.21,4.38-0.31,6.53-0.29c1.21,0.01,2.18,1,2.17,2.21 c-0.01,0.93-0.6,1.72-1.42,2.03c-9.15,3.6-16.47,10.31-20.96,18.62c-4.42,8.17-6.1,17.88-4.09,27.68l0.01,0.07 c2.29,11.06,8.83,20.15,17.58,25.91c8.74,5.76,19.67,8.18,30.73,5.92l0.07-0.01c7.96-1.65,14.89-5.49,20.3-10.78 c5.6-5.47,9.56-12.48,11.33-20.16c0.27-1.18,1.45-1.91,2.62-1.64c0.89,0.21,1.53,0.93,1.67,1.78c2.64,16.2-1.35,32.07-10.06,44.71 c-8.67,12.58-22.03,21.97-38.18,25.29c-16.62,3.42-33.05-0.22-46.18-8.86C14.52,104.1,4.69,90.45,1.27,73.83 C-2.07,57.6,1.32,41.55,9.53,28.58C17.78,15.57,30.88,5.64,46.91,1.75c0.31-0.08,0.67-0.16,1.06-0.25l0.01,0l0,0L49.06,1.27 L49.06,1.27z"/></g></svg>
                </label>
            </div>
        </div>
    </header>
    <div id="sidebar">
        <div id="title">
            <h2>Lux<br>Lumen</h2>
            <h2>Art-Net<br>node</h2>
        </div>
        <nav>
            <ul id="node-list">
            </ul>
        </nav>
        <div class="info config">
            <h3 id="firmware">firmware: <span></span></h3>
            <h3 id="config">config: <span>V0.01</span></h3>
        </div>
    </div>
    <div id="main-config">
        <div id="universe-container" class="card">
            <div class="card" id="tab">Art-Net</div>
            <ol id="universes">
            </ol>
            <div id="universe-filter-container">
                <div id="universe-filter">
                    <button class="e-button" id="decrement">-</button>
                    <button class="e-button" id="increment">+</button>
                </div>
            </div>
        </div>
        <!-- svg definition of the accolades -->
        <template id="brace-template">
        <?xml version="1.0" encoding="UTF-8"?>
        <svg viewBox="0 0 2000 72" xmlns="http://www.w3.org/2000/svg">
            <path d="M61.4 1.7H2637.1" stroke="__COLOR__" stroke-width="2"/>
            <path d="M61.4 70.7H2637.1" stroke="__COLOR__" stroke-width="2"/>
            <path d="M5 36.2H46.5M61.4 70.7C54.3 70.7 50 67.3 50 59.9c0-8.3 5-11.1 6.7-15.6 2.7-7.1-5-8.2-10.2-8.1M61.4 1.7C54.3 1.7 50 5.2 50 12.6c0 8.3 5 11 6.7 15.6 2.7 7-5 8.1-10.2 8" fill="none" stroke="__COLOR__" stroke-width="2"/>
            <text class="info __CLASS__" x="60px" y="40px" style="font-size: __FS__">0fps</text>
        </svg>
        </template>
        <!-- end of accolade definition -->
        <div id="accolades"></div>
        <!-- svg definition of the used-by-prev channel arrow-->
        <template id="arrow-template">
            <?xml version="1.0" encoding="UTF-8" standalone="no"?>
                <!-- Created with Inkscape (http://www.inkscape.org/) -->             
                <svg
                   viewBox="0 0 419.52734 525.35492"
                   version="1.1"
                   xmlns="http://www.w3.org/2000/svg"
                   xmlns:svg="http://www.w3.org/2000/svg">
                  <defs
                     id="defs1" />
                  <g
                     inkscape:label="Laag 1"
                     inkscape:groupmode="layer"
                     id="layer1">
                    <path
                       style="fill:#000000"
                       d="m 241.03184,826.39488 h 172.1656"
                       id="path1" />
                    <path
                       style="fill:#000000;stroke-width:198.293;stroke-dasharray:none"
                       d="M 247.37459,821.98486 H 494.74918"
                       id="path2" />
                    <path
                       style="fill:var(--bg-coal);fill-opacity:1;stroke:var(--ll-yellow);stroke-width:19.5213;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1;paint-order:normal"
                       d="m 379.82697,504.48806 -248.04154,-0.87159 c 0,0 155.51854,-110.38667 40.55595,-240.79349 L 98.672304,357.52911 58.587054,192.32546 15.580464,15.082048 370.58215,141.67429 258.19279,193.07579 c 0,0 210.30919,158.00931 121.77737,311.35093"
                       id="path3"
                       />
                  </g>
                </svg>
        </template>
        <div id="fieldbusses"></div>
        <div id="text-config-container">
            <textarea id="xml-text-area" spellcheck="false"></textarea>
            <p id="help-text">
                Editing the node parameters is possible by directly editing the fields within the tags. The values are in hex format where 2 characters represent a byte. 2 bytes after each other are MSB. different parameters are separated by a space.
                <br><br>
                Its possible to change only 1 parameter by giving the tag and its value eg. &ltout3> 02 &lt/out3> wil set the third output to the second protocol.
            </p>
            <button class="card xml-text-button" id="push">push to node</button>
            <label id="upload-container" for="upload" class="card xml-text-button">
                Open file
            </label>
            <input id="upload" type="file">
            <a id="download-container" download="XML.conf" href="">
                <button class="card xml-text-button" id="download">download config file</button>
            </a>
            <button class="card" id="text-config">text config</button>
        </div>
    </div>
    <div id="rdm-config" style="visibility: hidden">
        <div class="card">
            <div class="rdm-button e-button">i</div>
        </div>
    </div>
</body>
</html>
