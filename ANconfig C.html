HTTP/1.1 200 OK
Connection: close
Content-Type: text/html
Acces-Control-Allow-Origin: *

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Art-Net configurator</title>
</head>
<style>
    /* Resets all the style rules applied by browser 

   http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
    */

    html, body, div, span, applet, object, iframe,
    h1, h2, h3, h4, h5, h6, p, blockquote, pre,
    a, abbr, acronym, address, big, cite, code,
    del, dfn, em, img, ins, kbd, q, s, samp,
    small, strike, strong, sub, sup, tt, var,
    b, u, i, center,
    dl, dt, dd, ol, ul, li,
    fieldset, form, label, legend,
    table, caption, tbody, tfoot, thead, tr, th, td,
    article, aside, canvas, details, embed, 
    figure, figcaption, footer, header, hgroup, 
    menu, nav, output, ruby, section, summary,
    time, mark, audio, video {
    	margin: 0;
    	padding: 0;
    	border: 0;
    	font-size: 100%;
    	/* font: inherit; */
    	vertical-align: baseline;
    }
    /* HTML5 display-role reset for older browsers */
    article, aside, details, figcaption, figure, 
    footer, header, hgroup, menu, nav, section {
    	display: block;
    }
    body {
    	line-height: 1;
    }
    ol, ul {
    	list-style: none;
    }
    blockquote, q {
    	quotes: none;
    }
    blockquote:before, blockquote:after,
    q:before, q:after {
    	content: '';
    	content: none;
    }
    table {
    	border-collapse: collapse;
    	border-spacing: 0;
    }
    
    /* ============= Style rules defined by us ============== */
    /* ======= starting with some custom properties ========= */

    :root {
        /* colors */
        --ll-yellow: #FFF200;
        --ll-light-yellow: #F8EB00;
        --ll-mustard: #B9AF00;
        --bg-coal: #363633;
        --bg-light: #F5F5F5;
        --bg-dmx-box: #2F2F2F;
        --bg-grey: #82827B;
        --bg-grey-focus: #9e9e97;
        --bg-grey-pressed: #63635e;
        --bg-light-grey: #c9c9c9;
        --bg-light-address: #FDFFF9;
        --bg-card-grey: #4d4d4d;
        --bg-light-card-grey: #DDDDDD;
        --bg-error-red: #8a3838;
        --bg-status-green: #2Aff00;

        /* font */
        --font-nav-title: 'Reddit', sans-serif;
        --font-regular: 'Roboto', sans-serif;

        /* font sizes */
        --font-size-xxl: 4rem;
        --font-size-xl: 2.5rem;
        --font-size-large: 2rem;
        --font-size-medium: 1.4rem;
        --font-size-small: 0.9rem;
        --font-size-xs: 0.7rem;

        /* spacing */
        --grid-nav-width: 200px;
        --banner-height: 85px;
        --padding-small: 15px;
        --padding-medium: 20px;
        --padding-large: 40px;
    }   

    body {
        background-color: var(--bg-coal);
        display: grid;
        grid-template-columns: var(--grid-nav-width) 1fr;
        grid-template-rows: var(--banner-height) calc(100vh - var(--banner-height) - var(--padding-small));
    }

    body.light {
        background-color: var(--bg-light);
    }

    nav, .info, #banner span, #title {
        font-family: var(--font-regular);
    }

    #title h2:nth-child(2), h1 {
        color: var(--bg-coal);
    }

    .info {
        color: var(--ll-light-yellow)
    }

    .info.light {
        color: black;
    }

    /*==================================== Banner ==================================== */
    
    header {
        display: grid;
        grid-row: 1/2;
        grid-column: 1/3;
        grid-template-columns: subgrid;
        margin: var(--padding-small) var(--padding-small) 0 var(--padding-small);
        min-width: 620px;
        background-color: var(--ll-mustard); 
        border-radius: 20px;
        box-shadow: 5px 10px 15px rgba(0,0,0,0.5);
        z-index: 100;
    }
    header.light{
        background-color: var(--ll-light-yellow);
    }

    #banner {
        display: grid;
        column-gap: var(--padding-small);
        grid-column: 2/3;
        grid-template-columns: 45px repeat(2, 40px) auto 50px var(--padding-small);
        align-items: center;
    }

    #eth1 {
        position: relative;
        grid-column: 2/3;
    }

    #eth2 {
        position: relative;
        grid-column: 3/4;
    }

    h1 {
        grid-column: 4/5;
        justify-self: center;
        position: relative;
        bottom: 2px;
        font-size: var(--font-size-xxl);
        font-family: Brush Script MT;
        font-weight: lighter;
    }

    h3 {
        font-weight: 100;
    }

    /* ============= Dark mode switch ============== */

    #dark-mode-switch {
        grid-column: 5/6;
    }

    #dark-mode-switch label {
        width: 70px;
        height: 30px;
        position: relative;
        bottom: 6px;
        display: block;
        background-color: var(--bg-coal);
        border-radius: 200px;
        box-shadow: inset 0px 5px 15px rgba(0,0,0,0.4), inset 0px -5px 15px rgba(255,255,255,0.4);
        cursor: pointer;
        transition: 0.3s;

    }

    #dark-mode-switch label:after{
        content: "";
        width: 25px;
        height: 25px;
        position: absolute;
        top: 2.5px;
        left :2.5px;
        background: linear-gradient(180deg, #777, #3a3a3a);
        border-radius: 40px;
        box-shadow: 0px 5px 10px rgba(0,0,0,0.2);
        transition: 0.3s;
    }

    #dark-mode-switch input, #edit input {
        width: 0;
        height: 0;
        visibility: hidden;
    }

    #dark-mode-switch input:checked + label {
        background-color: #ebebeb;
    }

    #dark-mode-switch input:checked + label:after {
        left: calc(100% - 2.5px);
        transform: translateX(-100%);
        background: linear-gradient(270deg, var(--bg-light-card-grey), var(--bg-card-grey));
    }

    #dark-mode-switch label:active:after {
        width: 35px;
    }

    #dark-mode-switch label svg {
        position: absolute;
        width: 20px;
        top: 5px;
        z-index: 100;
    }

    #dark-mode-switch label svg.sun {
        width: 25px;
        left: 43px;
        top: 3px;
        fill: #7e7e7e;
        transition: 0.3s;
    }

    #dark-mode-switch label svg.moon {
        left: 5px;
        fill: #dbdbdb;
        transition: 0.3s;
    }

    #dark-mode-switch input:checked + label svg.sun {
        fill: #fff;
        transition: 0.3s;

    }

    #dark-mode-switch input:checked + label svg.moon {
        fill: #7e7e7e;
        transition: 0.3s;
    }

    /* ============= Edit mode switch ============== */

    .e-button {
        height: 25px;
        width: 25px;
        background-color: var(--bg-coal);
        border: 2px solid var(--ll-yellow);
        color: var(--ll-yellow);
        border-radius: 100%;
    }

    #pen {
        height: 18px;
        width: 18px;
        padding: 3px;
    }

    .e-button.light {
        background-color: var(--bg-light-grey);
        border: 2px solid var(--bg-dmx-box);
        color: var(--bg-dmx-box);
    }

    .e-button:hover{
        cursor: pointer;
    }

    /*==================================== Navbar ==================================== */

    #sidebar {
        display: grid;
        grid-template-rows: 150px 10fr 1fr;
        grid-row: 1/2;
        grid-column: 1/2;
        margin: var(--padding-small) 0 var(--padding-small) var(--padding-small);
        height: calc(100vh - 2*var(--padding-small));
        min-height: calc(768px - 2*var(--padding-small));
        min-width: 120px;
        background-color: var(--bg-grey);
        border-radius: 20px;
        z-index: 101;
    }

    #sidebar.light {
        background-color: var(--bg-light-grey);
    }

    nav {
        margin-top: var(--padding-small);
        grid-column: 1;
        grid-row: 2;      
        font-size: 2rem;
    }

    #title {
        grid-column:1;
        grid-row: 1;
    }

    #title h2 {
        grid-row:1/2;
        font-size: var(--font-size-large);
        text-align: right;
        margin-right: 10px;
    }

    /* Lux-Lumen */
    #title h2:nth-child(1), #info {
        color: var(--ll-yellow);
    }

    /* Art-Net node */
    #title h2:nth-child(2) {
        position: relative;
        z-index: 101;
    }

    #edit {
        z-index: 1000;
        grid-column: 1;
        grid-row: 1;
        position: relative;
        top: -5px;
        right: 20px;
    }

    #edit label {
        position: relative;
        bottom: 4px;
        left: 2px;
    }

    #node-list {
        display: flex;
        flex-direction: column;
    }

    .node {
        /* position: relative; */
        z-index: 101;
        font-size: var(--font-size-medium);
        padding: var(--padding-small) 0 var(--padding-small) var(--padding-small);
        color: var(--bg-coal);
    }

    .node.disconnected h3 {
        opacity: 25%;
    }

    .node:hover {
        cursor: pointer;
    }

    .info {
        display: none;
        font-size: var(--font-size-small);
    }

    .node-list #status {
        display: none;
    }

    .info li {
        margin-top: 0.5rem;
    }

    .info p {
        display: inline;
    }

    .info.config {
        font-size: var(--font-size-xs);
        flex-direction: column;
        display: flex;
        justify-content: center;
        align-items: center;
        grid-row: 3/4;
    }

    /* ============= Selected node ============== */

    .node.selected {
        position: relative;
        margin-left: var(--padding-small);
        margin-right: -1px;
        border-radius: 10px 0px 0px 10px;
        background-color: #363633;
        color: var(--ll-yellow);
        z-index: 5;
    }

    .node h2 {
        font-weight: 200;
    }

    .node.selected.disconnected h2 {
        opacity: 100%;
    }

    .node.selected.light {
        background-color: var(--bg-light);
        color: black;
    }

    .node.selected .info {
        margin-top: var(--padding-small);
        display: block;
    }

    .node.selected #top-curve {
        position: relative;
    }

    .node.selected #top-curve:before{
        position: absolute;
        content: "";
        left: calc(var(--grid-nav-width) - 75px);
        bottom: 15px;
        width: 30px;
        height: 30px;
        background-color: var(--bg-coal);
    }

    .node.selected.light #top-curve:before,
    .node.selected.light #bottom-curve:before {
        background-color: var(--bg-light);
    }

    .node.selected.light #top-curve:after,
    .node.selected.light #bottom-curve:after {
        background-color: var(--bg-light-grey);
    }

    .node.selected #top-curve:after {
        content: "";
        float: right;
        position: absolute;
        left: calc(var(--grid-nav-width) - 105px);
        bottom: 15px;
        width: 60px;
        height: 60px;
        background-color: var(--bg-grey);
        border-radius: 100%;
        /* border-color: var(--bg-grey); */
    }

    .node.selected #bottom-curve {
        position: relative;
    }

    .node.selected #bottom-curve:before {
        content:"";
        position: absolute;
        left: calc(var(--grid-nav-width) - 75px);
        top: 15px;
        width: 30px;
        height: 30px;
        background-color: var(--bg-coal);
    }

    .node.selected #bottom-curve:after {
        content:"";
        position: absolute;
        left: calc(var(--grid-nav-width) - 105px);
        top: 15px;
        width: 60px;
        height: 60px;
        border-radius: 100%;
        background-color: var(--bg-grey);
    }

    .node.selected #status{
        float: left;
        margin-top: 9px;
        margin-right: 5px;
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background-color: var(--bg-status-green);
    }
    
    .node.disconnected #status{
        background-color: red;
    }

    .node form {
        cursor: default;
        /* margin-top: -20px; */
        min-width: 90px;
        height: 100%;
    }

    .node .form-label {
        font-size: var(--font-size-small);
    }

    input, select {
        color: (var(--ll-yellow));
        border: 2px solid var(--ll-yellow);
        border-radius: 5px;
        background-color: var(--bg-grey);
    }

    form input {
        margin-top: calc(var(--padding-small)/3);
        margin-bottom: calc(var(--padding-small)/2);
        width: calc(var(--grid-nav-width) - 3*var(--padding-small)) ;
        min-width: 95px;
    }

    .light input, .light select {
        border-color: black;
        background-color: var(--bg-light-grey);
    }

    .light input::placeholder {
        color: black;
    }

    #submit-wrapper {
        margin-top: var(--padding-small);
        text-align: center;
    }

    #submit-wrapper input {
        cursor: pointer;
        margin-top: 0;
        width: 90px;
        border: none;
    }

    #submit-wrapper input:hover {
        background-color: var(--bg-grey-focus);
    }

    #submit-wrapper input:active {
        background-color: var(--bg-grey-pressed);
    }

    input::placeholder {
        color: var(--ll-yellow);
        opacity: 70%;
    }

    /* ============= Center configuration ============== */

    #main-config {
        isolation: isolate;
        display: grid;
        grid-column: 2/3;
        grid-row: 2/3;
        grid-template-columns: calc(40px - var(--padding-medium)) calc(2*var(--padding-medium) + 50px) calc(3*var(--padding-medium)) repeat(6,2fr); 
        margin: var(--padding-large) var(--padding-small) 0;
        min-width: 570px;
    }

    .range {
        background-color: var(--bg-grey);
    }

    .range.light {
        background-color: var(--bg-light-address);
        color: black;
    }

    .card {
        background-color: var(--bg-card-grey);
    }

    .card.light {
        background-color: var(--bg-light-card-grey);
        color: black;
    }

    .universe.card {
        position: relative;
        display: grid;
        grid-column: 2/3;
        grid-row: 1/7;
        grid-template-rows: subgrid;
        grid-template-columns: subgrid;
        border-radius: 0px 12px 12px 12px;
        color: var(--ll-yellow);
        box-shadow: 0px 10px 15px 2px rgba(0,0,0,0.5);
    }
    
    .universe.card:before {
        top: -15px;
        left: 10px;
        position: absolute;
        content: "";
        display: inline-block;
        width: 70px;
        height: 20px;
        background-color: var(--bg-dmx-box);
        border-radius: 5px;
        z-index: -1;
    }

    .universe.card.light:before {
        background-color: var(--bg-grey);
    }

    .universe:after {
        top: -50px;
        left: 25px;
        position: absolute;
        content: "";
        display: inline-block;
        width: 40px;
        height: 50px;
        background-color: var(--ll-yellow);
        border-radius: 5px;
        z-index: -4;
        box-shadow: 5px 0px 15px 2px rgba(0,0,0,0.5) inset;
    }

    #universes {
        display: grid;
        grid-column: 2/3;
        grid-row: 1/7;
        grid-template-rows: subgrid;
        grid-template-columns: subgrid;
        position: relative;
        font-family: var(--font-regular);
    }

    .universe #tab {
        display: inline-block;
        position: absolute;
        right: 60px;
        top: 24.7px;
        font-family: var(--font-regular);
        content: "Universes";
        transform: rotate(-90deg);
        font-size: var(--font-size-small);
        padding: 7px;
        border-radius: 12px 12px 0px 0px;
    }

    #universes li {
        align-self: center;
        position: relative;
        margin: 5px;
        display: flex;
        justify-content: center;
        justify-self: center;
        align-items: center;
        height: 40px;
        width: 80px;
        font-size: var(--font-size-medium);
        border-radius: 10px;
        z-index: 2;
        box-shadow: 0px 5px 15px 2px rgba(0,0,0,0.5);
        transition: transform 0.2s;
    }

    #universes li input {
        position: relative;
        min-width: 90%;
        height: 110%;
        font-size: var(--font-size-medium);
        text-align: center;
    }

    #universes li input:last-child {
        position: absolute;
        min-width: 60%;
        height: 60%;
        width: 70%;
        top: 40px;
        left: 40px;
        font-size: var(--font-size-small);
        z-index: 1000;
    }

    #universes li span {
        font-size: var(--font-size-small);
        position: absolute;
        padding: 5px;
        top: 25px;
        left: 50px;
        border-radius: 10px;
        z-index: -1;
    }

    #universe-filter-container {
        padding-top: 10px;
        grid-row: 8;
        z-index: 10;
        width: 70%;
        margin: 0px auto 0px auto;
    }

    #universe-filter {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
    }

    #universe-filter h3 {
        display: flex;
        padding-top: 3px;
        justify-content: center;
    }

    #accolades {
        /* position: relative; */
        display: grid;
        grid-column: 3/10;
        grid-row: 1/11;
        grid-template-columns: subgrid;
        grid-template-rows: subgrid;
    }

    #accolades div {
        /* position: relative; */
        /* left: -40px; */
        height: 104%;
        display: grid;
        grid-template-columns: subgrid;
        margin-bottom: -2.65px;
        overflow: hidden;
    }

    .accolade {position: relative; grid-column: 1/8; overflow: hidden; z-index: -10;}

    .accolade .info {
        display: block;
        fill: var(--ll-yellow);
        font-family: var(--font-regular);
        font-size: var(--font-size-xs);
    }

    .accolade .info.light {
        fill: black;
    }

    #fieldbusses{
        position: relative;
        display: grid;
        grid-template-rows: subgrid;
        grid-template-columns: subgrid;
        grid-row: 1/8;
        grid-column: 1/10;
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10 and IE 11 */
        user-select: none; /* Standard syntax */
    }
    
    .fieldbus.card {
        display: grid;
        grid-row: 1/8;
        grid-template-rows: subgrid;
        justify-self: end;
        width: 70%;
        max-width: 125px;
        min-width: 50px;
        border-radius: 25px;
        box-shadow: 0px 10px 15px 2px rgba(0,0,0,0.5);
        color: var(--ll-yellow);
        font-family: var(--font-regular);
    }

    
    .address.range{
        position: relative;
        justify-self: center;
        grid-row: 1/7;
        width:90%;
        border-radius: 25px;
    }

    .address.range h1 {
        position: absolute;
        left: 50%;
        width: 0;
        transform: rotate(-90deg);
        color: var(--bg-card-grey);
        font-family: var(--font-nav-title);
        font-size: 3rem;
        white-space: nowrap;
        opacity: 50%;
    }

    #fb-1 {grid-column: 4/5}
    #fb-2 {grid-column: 5/6}
    #fb-3 {grid-column: 6/7}
    #fb-4 {grid-column: 7/8}
    #fb-5 {grid-column: 8/9}
    #fb-6 {grid-column: 9/10}

    .address.range div.patch {
        cursor: move;
        position: relative;
        background-color: var(--bg-coal);
        border-radius: 15px;
        outline: 3px solid var(--ll-yellow);
        outline-offset: -2px;
    }

    .address.range div.top-handle {
        cursor: n-resize;
        position: absolute;
        top: -6px;
        display: flex;
        justify-content: center;
        height: 10px;
        width: 100%; 
    }

    .address.range div.top-handle.light, .address.range div.bottom-handle.light {
        background-color: transparent;
        outline: transparent;
    }

    .address.range div.top-handle:after {
        content: "";
        width: 17%;
        height: 7px;
        background-color: var(--ll-yellow);
        border-radius: 5px 5px 0px 0px;
    }

    .address.range div.bottom-handle {
        cursor: n-resize;
        position: absolute;
        bottom: -9.5px;
        display: flex;
        justify-content: center;
        height: 10px;
        width: 100%; 
    }

    .address.range div.bottom-handle:after {
        content: "";
        width: 17%;
        height: 7px;
        background-color: var(--ll-yellow);
        border-radius: 0px 0px 5px 5px;
    }

    #fieldbusses h3, #fieldbusses h2 {
        max-width: 50px;
    }

    #fieldbusses input {
        position: relative;
        font-size: clamp(var(--font-size-xs), 1vw, var(--font-size-small));
        width: 140%;
    }

    #fieldbusses h2 input {
        margin-top: 3px;
        font-size: clamp(var(--font-size-s), 1vw, var(--font-size-medium));
    }

    .address-container {
        height: 100%;
        display: grid;
        grid-template-rows: repeat(3, 1fr);
    }

    .address.range .patch.extreme.overflow .address-container {
        display: block;
    }

    .config.overflow .address-container h3 {
        width: 110%;
    }

    .address.range .patch.extreme.overflow h3 {
        position: absolute;
    }

    .address.range .patch.overflow h3 {
        margin-top: -40px;
        cursor: default;
        width: 90%;
    }

    .address.range .patch.overflow.config h3 {
        margin-top: -37px;
        white-space: nowrap;
    }

    .address.range .patch.overflow.extreme h2 {
        position: absolute;
        bottom: -40px;
        width: 100%;
        text-align: center;
    }
    
    .address.range .config.patch.overflow.extreme h2  {
        bottom: -2.2em;
    }

    .address.range div.light{
        background-color: var(--bg-light-grey);
        outline: 3px solid var(--bg-card-grey);
    }
    
    .address.range div.light div:after{
        background-color: var(--bg-card-grey);
    }

    .address.range h2 {
        font-size: clamp(var(--font-size-small), 2vw, var(--font-size-medium));
        font-weight: lighter;
        align-self: center;
        margin-left: auto;
        margin-right: auto;
    }

    .address.range h3 {
        width: 80%;
        margin-top: 5px;
        margin-left:5px;
        font-size: clamp(var(--font-size-xs), 1vw, var(--font-size-small));
        font-weight: lighter;
    }

    .fb-protocol.info {
        grid-row: 8;
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: space-evenly;
        align-items: center;
        font-size: clamp(var(--font-size-xs), 1vw, var(--font-size-small));
    }

    .fb-protocol.info select {
        margin-top: 5px;
        text-align: center;
        width: 90%;
    }

    .fb-protocol #ethernet {
        display: flex;
        justify-content: center;
        max-width: 60%;
    }

    /* ============= Dynamic resizing ============== */
    
    @media screen and (max-width: 950px) {
        :root {
            --grid-nav-width: 21vw;
        }

        .address-container h3 {
            white-space: inherit;
        }

        #fieldbusses .overflow h3 input {
            width: 105%;
        }
    }

    @media screen and (max-width: 780px) {
        #title {
            margin-top: 20px;
        } 

        #sidebar h2{
            font-size: 1.5rem;
        }

        nav h2:nth-child(1) {
            margin-top: 15px;
        }
        
        .node {
            font-size: var(--font-size-small);
            padding: calc(var(--padding-small) / 2) 0 calc(var(--padding-small) / 2) calc(var(--padding-small) / 2);
        } 

        .node.selected .info {
            display: none;
        } 

        .node.selected #status {
            margin-top: 6px;
            margin-right: 3px;
            width: 5px;
            height: 5px;
        }

        .node.selected #status.config {
            top: 7px
        }

        .node.selected #top-curve:before{
            left: calc(var(--grid-nav-width) - 67px);
            bottom: 7.5px;
        }

        .node.selected #top-curve:after {
            left: calc(var(--grid-nav-width) - 97.5px);
            bottom: 7.5px;
        }

        .node.selected #bottom-curve:before {
            left: calc(var(--grid-nav-width) - 67px);
            top: 7px;
        }

        .node.selected #bottom-curve:after {
            left: calc(var(--grid-nav-width) - 97.5px);
            top: 7.5px;
        }

        .node input {
            width: calc(var(--grid-nav-width) - 3*var(--padding-small) + 5px) ;
        }
    }

    @media screen and (max-width: 641px) {
        body {
            grid-template-columns: 135px 1fr;
        }
        
        .node.selected #top-curve:before, .node.selected #bottom-curve:before {
            left: 68px;
        }

        .node.selected #top-curve:after, .node.selected #bottom-curve:after {
            left: 37.5px;
        }
    }

    @media screen and (min-height: 1000px) {
        #accolades h3 {
            left: 20px;
            bottom: -4vh
        }
    }

    @media screen and (max-height: 768px) {
        body {
            grid-template-rows: var(--banner-height) calc(768px - var(--banner-height) - var(--padding-small));
        }
    }


</style>
<script>
    let nodeIp = "http://10.20.24.124"

    const SWITCHPARAMS = ["status", "rxByteCount", "txByteCount", "rxBroadcast", "txBroadcast", "rxUnicast", "txUnicast", "rxMulticast", "txMulticast", "rxPause", "txPause"]
    const ARTNETPARAMS = ["universe", "keep", "framecounter"];
    const FIELDBUSPARAMS = ["codec", "startAddress", "streamLength", "finetuningParams"];

    class Installation {
        #prevInstallation
        #customer;
        #nodes = [];
        #lightMode = false;
        // activeNode and activeNodeElement public property is available

        #accMargin = -55;

        // Immediately Invoked Async Function Expression zorgt ervoor dat we de nodes kunnen ophalen en nieuwe
        // object instanties kunnen aanmaken zonder then-chaining of extra async functies te gebruiken 
        // https://itnext.io/1-minute-to-become-a-better-developer-4-aeabd6586396
        constructor(customer, prevInstallation = null){
            return (async () => {
                this.#customer = customer;
                this.#prevInstallation = prevInstallation;
                await this.fetchNodes();
                // if (!prevInstallation) {
                this.addDemo();
                // } else {
                //     this.#nodes.push(this.#prevInstallation.nodes.find((n) => n.mac === "7B:A6:80:7F:EC:7D"));                          
                // }   
                if (localStorage.getItem("configuration") === "enabled") {
                    this.config = true;
                } else this.config = false;
                this.configElement = document.querySelector("#main-config");
                return this;
            })();
        }

        get nodes(){
            return this.#nodes;
        }

        get prevInstallation() {
            return this.#prevInstallation;
        }

        async fetchNodes(init) {
            try {
                const response = await fetch(`${nodeIp}/xdev`, {signal: AbortSignal.timeout(2000)});
                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                let foundNodes = [];
                let devices = xmlDoc.getElementsByTagName("dev")[0].innerHTML.split(" ");
                for (let device of devices) {
                    let ip = hexToIP(device);
                    let oldNode;
                    // if (this.#prevInstallation !== null) {
                    //     oldNode = this.#prevInstallation.nodes.find((node) => node.ip === ip);
                    // }
                    let node = await new Node(ip, oldNode);
                    foundNodes.push(node);
                }
                if (init) foundNodes[0].active = true;
                this.#nodes = foundNodes;
            } catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");
                    return [];
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.error("AbortSignal.timeout() method is not supported");
                } else {
                    console.error("Failed to fetch Nodes:", error.message);
                }
            }
        }

        addDemo(){
            let universes = [];
            let fieldbusses = [];
            for (let i=0; i<10; i++){
                universes.push(new Universe(`inp${i+1}`, i, 512, 0));
            }
            for (let i=0; i<6; i++){
                fieldbusses.push(new Fieldbus(`out${i}`, 2, i == 0? 1 : (i*512)+1, 512, 0));
            }
            let demoNode = new NodeTemplate("127.0.0.1", null, "Demo", "7b:a6:80:7f:ec:7d", {}, "255.255.255.0", universes, fieldbusses, ["Disabled", "Used-by-previous-channel", "DMX-512", "DMX-RDM"], "v3.1")
            if (demoNode.mac === localStorage.getItem("activeNode")) {
                this.nodes.map((node) => node.active = false);
                demoNode.active = true;
            }
            // demoNode.active = true; // Uncomment this line if there are no fysical nodes connected
            this.#nodes.push(demoNode);           
        }

        updateNav(init){
            let generateNode = (node, lm) => {
                let nodeElement = document.createElement("li");
                nodeElement.classList.add("node");
                nodeElement.id = node.UID;
                if (!this.config | node.active === false) {
                    nodeElement.innerHTML = `
                    <div id="top-curve"></div>
                    <div id="status"></div>
                    <h3 id="name">${node.name}</h3>
                        <ul class="info ${lm} configurable">
                            <li class="IP">IP: <p>${node.ip}</p></li>
                            <li class="netMask">Netmask: <p>${node.netmask}</p></li>
                            <li class="mac">MAC: <p>${node.mac}</p></li>
                        </ul>
                    <div id="bottom-curve"></div>
                    `
                    
                } else {
                    nodeElement.innerHTML = `
                    <div id="top-curve"></div>
                    <div class="config" id="status"></div>
                    <h3 id="name">${node.name}</h3>
                    <form class="node-form">
                        <label for="new-name"> Name:</label><br>
                        <input type="text" id="new-name" placeholder=${node.name}><br>
                        <label class="form-label" for="new-ip"> IP:</label><br>
                        <input type="text" id="new-ip" placeholder=${node.ip}><br>
                        <label class="form-label" for="new-mask"> Netmask:</label><br>
                        <input type="text" id="new-mask" placeholder=${node.netmask}><br>
                        <div id="submit-wrapper">
                            <input type="submit" value="Push to node">
                        </div>
                    </form>
                    <div id="bottom-curve"></div>`
                    }
                return nodeElement;
            }

            let navBar = document.getElementById("node-list");
            navBar.innerHTML="";
            this.#nodes.forEach(node => {
                let nodeElement = generateNode(node, this.lm);
                if (this.lm) nodeElement.classList.add("light");
                // check if the webpage address corresponds to one of the nodes in the lists,
                // make this the selected node if match is found.
                if (init && localStorage.getItem("activeNode") === "") {
                    if (node.ip == (nodeIp.split("http://"))[1]) {
                        nodeElement.classList.add("selected");
                        node.active = true;
                        this.activeNode = node;
                        if (this.config) nodeElement.children[2].hidden = true;
                    }
                } else {
                    if (node.active) {
                        nodeElement.classList.add("selected");
                        this.activeNode = node;
                        if (this.config) nodeElement.children[2].hidden = true;
                    }
                    else {
                        nodeElement.children[3].hidden = true;
                    }
                }
                navBar.appendChild(nodeElement);
            });

            if (init) {
                const fpsInterval = setInterval(() => this.activeNode.updateFps(), 1000);
                const statusInterval = setInterval(async () => {
                    for (const node of this.nodes) {
                        if (node.mac !== "7B:A6:80:7F:EC:7D" && node.active === false) {
                            try {
                                const response = await fetch(`http://${node.ip}/xart`, {signal: AbortSignal.timeout(2000)});
                                if (!response.ok) {
                                    throw new Error(`Response status: ${response.status}`);
                                }
                                node.setStatus(true);               
                            } 
                            catch (error) {
                                if (error.name === "TimeoutError") {
                                    console.error("Request timed out");
                                    node.setStatus(false);     
                                } else if (error.name === "AbortError") {
                                    console.error("Fetch aborted by user");
                                } else if (error.name === "TypeError") {
                                    console.error("AbortSignal.timeout() method is not supported");
                                } else {
                                    console.error("Failed to update fps:", error.message);
                                }
                            }
                        }
                    }      
                }, 5000);
                
                this.initaliseConfig();
            } else this.showActiveNode();
            
        }

        initaliseConfig() {
            this.activeNodeElement = document.getElementById(`${this.activeNode.UID}`);

            // Universes and their braces
            this.accoladesElement = document.getElementById("accolades");   
            this.accoladesElement.innerHTML = '';   

            let counter = 1;
            this.activeNode.universes.forEach(un => {
                if (counter <= this.activeNode.shownUniverses) {              
                    let a = document.createElement("div");
                    a.style.marginLeft = `${this.#accMargin}px`
                    a.id = `accolade-${counter}`;
                    a.classList.add("accolade");
                    // svg definition of the braces
                    let braceColor = this.lm? "rgb(77,77,77)" : "#FFF200";
                    a.innerHTML = `
                    <svg height="100%" viewBox="0 0 2000 72" xmlns="http://www.w3.org/2000/svg">
                        <path d="M61.4318 1.72424H2637.06" stroke=${braceColor} stroke-width="2"/>
                        <path d="M61.4318 70.7244H2637.06" stroke=${braceColor} stroke-width="2"/>
                        <path d="M46.4779 36.2288C51.7241 36.3106 59.3583 35.2166 56.7341 28.1965C55.0324 23.6442 50.049 20.9121 50.049 12.6052C50.049 5.20797 54.2605 1.72424 61.4318 1.72424M46.4779 36.2288C51.7241 36.1469 59.3583 37.2492 56.7341 44.2693C55.0324 48.8216 50.049 51.5537 50.049 59.8606C50.049 67.2579 54.2605 70.7416 61.4318 70.7416M46.4779 36.2288H5" fill="none" stroke=${braceColor} stroke-width="2"/>
                        <text class="info ${this.lm}" x="60" y="40">0fps</text>
                    </svg>`
                    this.accoladesElement.appendChild(a);
                }
                counter++;
            })

            this.fieldbussesElement = document.getElementById("fieldbusses");
            this.fieldbussesElement.innerHTML = '';
            counter = 1;
            this.activeNode.fieldbusses.forEach(fb => {
                fb.fbElement =  generateDomTree("div", null, { id: `fb-${counter}`, class: "fieldbus card" }, [
                                    generateDomTree("div", null, { class: "address range" }, [
                                        generateDomTree("h1", `FIELDBUS ${counter}`),
                                        generateDomTree("div", null, { id: `address-block-${counter}`, class: "patch" }, [
                                            generateDomTree("div", null, { class: "top-handle" }),
                                            generateDomTree("div", null, { class: "move address-container" }, [
                                                generateDomTree("h3", "start: ", { class: "move" }, [
                                                    generateDomTree("span")
                                                ]),
                                                generateDomTree("h2", null, { class: "move" })]),
                                            generateDomTree("div", null, { class: "bottom-handle" })
                                        ])
                                ]), 
                                generateDomTree("div", null, { class: "fb-protocol info" })])
                this.fieldbussesElement.appendChild(fb.fbElement);
                counter++;    
            })
      
            this.showActiveNode();
        }

        // Event listeners for the universes
        // handleUniChange = (e) => {
        //         let param = e.target.id;
        //         let targetUniverse = this.activeNode.universes.find((uni) => uni.id === e.target.getAttribute("universe"));
        //         targetUniverse[param] = parseInt(e.target.value);
        //         this.activeNode.configuration.handleInputChange(targetUniverse);
        //     }

        showActiveNode() {
            this.activeNodeElement = document.getElementById(`${this.activeNode.UID}`);
                
            let firmwareVersion = document.querySelector("#firmware span");
            let configVersion = document.querySelector("#config span");

            this.universesElement = document.getElementById("universes");
            this.universesElement.innerHTML = ''; 

            firmwareVersion.innerHTML = this.activeNode.firmware;
            let counter = 1;
            this.activeNode.universes.forEach((uni) => {
                if (counter <= this.activeNode.shownUniverses) {
                    let u = document.createElement("li");
                    u.classList.add("range");
                    if (this.lm) u.classList.add("light");
                    if (this.config) {
                        // let inputU = document.createElement("input");
                        let inputU = generateDomTree("input", null, {id: "universe", universe: uni.id, type: "number", value: uni.universe, min: 1, max: 32468 });
                        let inputK = generateDomTree("input", null, {id: "keep", universe: uni.id, type: "number", value: uni.keep, min: 1, max: 512});
                        u.appendChild(inputU);
                        u.appendChild(inputK);
                    } else {
                        u.innerHTML = `${uni.universe}<span class="range ${this.lm}">${uni.keep}</span>`
                    }
                    this.universesElement.appendChild(u);
                }        
                counter++;
            })

            // this.unilist = document.querySelector("#universes");
            // this.unilist.removeEventListener("change", this.handleUniChange);
            // this.unilist.addEventListener("change", this.handleUniChange);

            counter = 1;
            this.activeNode.fieldbusses.forEach((fb) => {
                fb.addressBlock = document.getElementById(`address-block-${counter}`);
                fb.startElement = document.querySelector(`#fb-${counter} .address-container h3`);
                fb.streamElement = document.querySelector(`#fb-${counter} .address-container h2`);
                fb.codecElement = document.querySelector(`#fb-${counter} .fb-protocol`);
                fb.patch = document.querySelector(".patch");

                if (this.activeNode.codecs[fb.codec].split(" ")[0] === "disabled") {
                    fb.addressBlock.hidden = true;
                } else fb.addressBlock.hidden = false;

                // Config elements for start and streamlength
                let startElement;
                let streamElement;
                if (this.config) {
                    fb.patch.classList.add("config");
                    startElement    =   generateDomTree("h3", null, null, [
                                        generateDomTree("label", "start: ", {for: "start-address"}, [
                                            generateDomTree("input", null, {id: "start-address", fieldbus: fb.id, type: "number", min: "1", max: "5119", value: `${fb.startAddress}`}, null)])]);
                    streamElement   =   generateDomTree("h2", null, null, [
                                            generateDomTree("label", null, {for: "stream-address"}, [
                                                generateDomTree("input", null, {id: "stream-length", fieldbus: fb.id, type: "number", min: "1", max: "1024", value: `${fb.streamLength}`}, null)])]);
                } else {
                    fb.patch.classList.remove("config");
                    startElement    =   generateDomTree("h3", "start: ", { class: "move" }, [
                                            generateDomTree("span", fb.startAddress)]);
                    streamElement   =   generateDomTree("h2", fb.streamLength, { class: "move" });
                }

                fb.startElement.replaceWith(startElement);
                fb.streamElement.replaceWith(streamElement);

                // Updating all the fb.addressblock heights and startpositions
                // Height = streamlength, top = startaddres
                let start = String((fb.startAddress/(512*this.activeNode.shownUniverses))*100)+"%";
                let stream = String((fb.streamLength/(512*this.activeNode.shownUniverses))*100)+"%";

                // Updating the styles so that overflow is handled
                if (fb.streamLength <= 280 | this.config & fb.streamLength <= 400) {
                    fb.addressBlock.classList.add("overflow");
                } else fb.addressBlock.classList.remove("overflow");
                if (fb.streamLength <= 120 | this.config & fb.streamLength <= 250) {
                    fb.addressBlock.classList.add("extreme")
                } else fb.addressBlock.classList.remove("extreme");
                
                fb.addressBlock.style.height = stream;
                fb.addressBlock.style.top = start;

                if (counter > this.activeNode.shownUniverses) {
                    fb.addressBlock.hidden = "true";
                }

                const ACTIVECODEC = this.activeNode.codecs[fb.codec].split(" ")[0];

                const LABEL = generateDomTree("label", null,  {for: "codec"});
                    LABEL.innerHTML = "Codec: "
                    const SELECT = generateDomTree("select", null, {name: "codec", id: "codec"});
                    for (let i=0; i<this.activeNode.codecs.length; i++) {
                        const OPTION = document.createElement("option", {value: `${this.activeNode.codecs[i].split(" ")[0]}`});
                        const CONTENT = document.createTextNode(`${this.activeNode.codecs[i].split(" ")[0]}`);
                        if (this.activeNode.codecs[i].split(" ")[0] === ACTIVECODEC) {
                            OPTION.selected = true;
                        }
                        OPTION.appendChild(CONTENT);
                        SELECT.appendChild(OPTION);
                    }
                LABEL.appendChild(SELECT);
                
                let rj45 = generateDomTree("div", `<svg width="75%" viewBox="0 0 512 490.43">  
                                            <use href="#ethernet-port"/>
                                        </svg>`, { id: "ethernet" })
                
            
                fb.codecElement.innerHTML = '';
                if (this.config) {
                    fb.codecElement.appendChild(LABEL);
                } else {
                    let h2 = generateDomTree("h2", "Codec: ");
                    let h3 = generateDomTree("h3", ACTIVECODEC);
                    fb.codecElement.appendChild(h2);
                    fb.codecElement.appendChild(h3);
                }
                fb.codecElement.appendChild(rj45);

                // mark double universes in red
                let unis = document.querySelectorAll("#universes li");
                let uniArr = [];
                for (const uni of unis) {
                    uniArr.push((uni.innerHTML).split("<")[0]);
                }

                let dupObj = {};
                uniArr.forEach((element, index, array) => {
                    dupObj[element] = Array.from(array.entries()).reduce((indices, [i, e]) => {
                        if (element === e) {
                            indices.push(i);
                        }
                        return indices;
                    }, []);
                });

                const setDuplicateError = (i) => {
                    if (!this.config) {
                        let uni = document.querySelector(`#universes li:nth-child(${i+1})`);
                        let keep = document.querySelector(`#universes li:nth-child(${i+1}) span`)
                        uni.style.backgroundColor = keep.style.backgroundColor = "var(--bg-error-red)";
                    }
                }

                for (const duplicates of Object.values(dupObj)){
                    if (duplicates.length === 2) {
                        setDuplicateError(duplicates[1])
                    }
                    else if (duplicates.length > 2) {
                        duplicates.shift();
                        for (const i in duplicates) {
                            setDuplicateError(duplicates[i])
                        }
                    }           
                }
                
                this.changeGridStyling(); // must happen before setting the handlers otherwise the offset
                // is wrong
            
                if (this.config) {
                    // setting the event listener for the form
                    let forms = document.getElementsByClassName("node-form");
                    let form = this.activeNodeElement.children[3];
                    Array.from(forms).forEach((form) => {
                        form.removeEventListener("submit", this.activeNode.processForm);
                    })
                    form.addEventListener("submit", this.activeNode.processForm);
                }

                counter++;
            })
            
        }

        eventInit() {
            // window.onresize = (e) => {console.log(e)}
            const dmSwitch = document.querySelector("#dark-mode-switch input");
            const configSwitch = document.querySelector("#edit-switch");
            const savedDarkMode = localStorage.getItem("darkMode");

            if (this.config) {
                configSwitch.checked = true;
            } else configSwitch.checked = false;

            if (savedDarkMode === "enabled") {
                dmSwitch.checked = true;
            } else dmSwitch.checked = false;

            this.switchDarkMode(dmSwitch);
            dmSwitch.addEventListener("change", () => this.switchDarkMode(dmSwitch));

            const uniButtons = document.querySelectorAll("#universe-filter .e-button");
            for (const button of uniButtons) {
                button.addEventListener("click", () => {
                    const accolades = document.querySelectorAll("#accolades div");
                    if (button.id === "increment") {
                        if (this.activeNode.shownUniverses < this.activeNode.maxShownUniverses) {
                            this.activeNode.changeShownUni(true);
                            this.#accMargin += 5;
                        }
                    } else if (button.id === "decrement") {
                        if (this.activeNode.shownUniverses > this.activeNode.minShownUniverses) {
                            let overLap = false;
                            for (const fb of this.activeNode.fieldbusses) {
                                if ((fb.startAddress + fb.streamLength)-1 > (this.activeNode.shownUniverses-1) * 512) {
                                    overLap = true;
                                }
                            }
                            if (!overLap) {
                                this.activeNode.changeShownUni(false);
                                this.#accMargin -= 5;
                            }        
                        }
                    }
                    this.initaliseConfig();
                    this.changeGridStyling();
                })
            }

            let editButton = document.querySelector("#edit-switch");
            editButton.addEventListener("change", (e) => {
                const checkBox = document.querySelector("#edit-switch");
                if (checkBox.checked) {
                    this.config = true;
                    localStorage.setItem("configuration", "enabled");
                    this.updateNav(false)
                } else {
                    this.config = false;
                    localStorage.setItem("configuration", "disabled");
                    this.updateNav(false);
                }  
                this.navSwitcher();    
            })

            this.addHandleEvents();
        }

        addHandleEvents = () => {
            this.configElement.addEventListener("mousedown", this.handleFbEvent);
            this.configElement.addEventListener("change", this.handleFbEvent);
            this.configElement.addEventListener("mousemove", this.handleFbEvent);
            this.configElement.addEventListener("mouseup", this.handleFbEvent);     
        }

        handleFbEvent = (e) => {
            if (e.type !== "mousemove") {
                this.targetFb = e.target.closest(".fieldbus").id.slice(-1)-1;
                this.targetFb = this.activeNode.fieldbusses.find((fb) => fb.id === `out${this.targetFb}`)
                console.log(this.targetFb);
            }
            if (this.targetFb !== undefined) {
                switch(e.type) {
                    case "mousedown":
                        this.targetFb.setStart(e);
                        break;
                    case "change":
                        console.log("change");
                        break;
                    case "mousemove":
                        this.targetFb.setMove(e);
                        break;
                    case "mouseup":
                        this.targetFb.updateValues(e);
                        break;
                    default:
                        break;
                }
            } 
        }

        handleNavClick = (e) => {

            let nodeElement = e.currentTarget;
            // resetting the nodes to their inactive state
            this.#nodes.map((node) => {node.active = false});

            let nodes = document.getElementsByClassName("node");
            for (let n of nodes) {
                n.classList.remove("selected");
            }

            if (!nodeElement.classList.contains("selected")) {
                nodeElement.classList.add("selected");
                let node = this.#nodes.find((n) => n.UID === nodeElement.id);
                if (this.lm) nodeElement.classList.add("light");
                node.active = true;
                this.activeNode = node;
                localStorage.setItem("activeNode", node.mac)               
            }
            this.updateNav(false);
            this.navSwitcher();

        }

        navSwitcher() {
            let nodes = document.querySelectorAll(".node");
            // removing all the previously attached event Listeners
            nodes.forEach((node) => node.removeEventListener("click", this.handleNavClick));
            let inactiveNodes = Array.from(nodes).filter((node) => !node.classList.contains("selected"));
            
            inactiveNodes.forEach((nodeElement) => {
                // Event listener to switch the active node
                nodeElement.addEventListener("click", this.handleNavClick);
            })       
        }

        changeGridStyling(){
            let main            = document.getElementById("main-config");
            let uniC            = document.querySelector(".universe.card");
            let uni             = document.getElementById("universes");
            let uniFilter       = document.querySelector("#universe-filter-container");
            let fieldbusses     = document.getElementById("fieldbusses");
            let fbC             = document.querySelectorAll(".fieldbus.card");
            let fb              = document.querySelectorAll(".address.range");
            let protos          = document.querySelectorAll(".fb-protocol.info");

            main.style.gridTemplateRows = `repeat(${this.activeNode.shownUniverses}, 1fr) 25px 120px`
            uniC.style.gridRow          = `1/${this.activeNode.shownUniverses+2}`
            uni.style.gridRow = fieldbusses.style.gridRow = `1/${this.activeNode.shownUniverses+3}`
            uniFilter.style.gridRow = `${this.activeNode.shownUniverses+2}`
            for (const fb of fbC) {
                fb.style.gridRow = `1/${this.activeNode.shownUniverses+3}`
            }
            for (const f of fb) {
                f.style.gridRow = `1/${this.activeNode.shownUniverses+1}`
            }
            for (const p of protos) {
                p.style.gridRow = `${this.activeNode.shownUniverses +2}`
            }
        }

        switchDarkMode(sw) {
            let accolades = document.querySelectorAll(".accolade path");
            let buttonSvgs = document.querySelector("#edit svg path");
            let lightArr = [];
            lightArr.push(document.querySelector("body"));
            lightArr.push(document.querySelector("header"));
            lightArr.push(document.querySelector("#sidebar"));
            lightArr.push(...document.querySelectorAll(".node"));
            lightArr.push(...document.querySelectorAll(".info"));
            lightArr.push(...document.querySelectorAll(".card"));
            lightArr.push(...document.querySelectorAll(".range"));
            lightArr.push(...document.querySelectorAll(".address.range div.patch"));
            lightArr.push(...document.querySelectorAll(".e-button"));
            if (sw.checked === true) {
                this.lm = "light";
                localStorage.setItem("darkMode", "enabled");
                lightArr.forEach(e => e.classList.add("light"));
                for (const accolade of accolades) {
                    accolade.style.stroke = "#4d4d4d";
                }
                buttonSvgs.style.stroke = "#4d4d4d";
                buttonSvgs.style.fill = "#4d4d4d";
            } else {
                this.lm = "";
                localStorage.setItem("darkMode", "disabled");
                for (const accolade of accolades) {
                    accolade.style.stroke = "#FFF200"
                }
                buttonSvgs.style.stroke = "#FFF200";
                buttonSvgs.style.fill = "#FFF200";
                lightArr.forEach(e => e.classList.remove("light"));
            }
        }
    }

    class Node {
        #oldNode;
        #ip;
        #name;
        #mac;
        #switch = {};
        #netmask;
        #configuration;
        #universes = [];
        #fieldbusses = [];
        #codecs = [];
        #firmware;
        #maxShownUniverses = 10;
        #minShownUniverses = 6;
        #shownUniverses = 6;
        #lastUpdate;
        #online = true;
        #active = false;

        #timestamp;
        #prevTimestampOff = null;
        #prevTimestampOn = null;

        #enableDetector = [[0,1],[0,1],[0,1],[0,1],[0,1],[0,1]]

        constructor(ip, oldSelf = null, skipConfig = false) {
            this.#ip = ip;
            
            if (!skipConfig) {
                return (async () => {
                    this.#configuration = await new Configuration(ip);
                    if (oldSelf !== null) {
                        this.#oldNode = oldSelf;
                        this.#enableDetector = this.#oldNode.enableDetector;
                    }
                    this.initialiseNode();
                    return this;
                })();
            }
        }

        get ip() {
            return this.#ip;
        }

        get name() {
            return this.#name;
        }

        get mac() {
            return this.#mac;
        }

        get UID() {
            return this.#mac.replaceAll(":", "");
        }

        get netmask() {
            return this.#netmask;
        }

        get universes() {
            return this.#universes;
        }

        get fieldbusses() {
            return this.#fieldbusses;
        }

        get configuration(){
            return this.#configuration;
        }

        get codecs() {
            return this.#codecs;
        }

        get firmware() {
            return this.#firmware;
        }

        get shownUniverses() {
            return this.#shownUniverses;
        }

        get maxShownUniverses() {
            return this.#maxShownUniverses;
        }

        get minShownUniverses() {
            return this.#minShownUniverses;
        }
        
        get active() {
            return this.#active;
        }

        get enableDetector() {
            return this.#enableDetector;
        }
        
        set ip(ip) {
            let reIP = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

            if (!reIP.test(ip)) {
                console.log("Invalid IP format");
                return;
            }

            let ipParts = ip.split('.').map(Number);
            let maskParts = this.#netmask.split('.').map(Number);

            let broadcastParts = ipParts.map((octet, index) => octet | (255 - maskParts[index]));

            if (ipParts.every((octet, index) => octet === broadcastParts[index])) {
                console.log("This is a broadcast address and is not allowed.");
                return;
            }

            console.log("This is a valid IP address.");
            this.#ip = ip;
        }

        set name(name){
            if (typeof name !== "string" || name.trim().length === 0) {
                console.log("Invalid name: must be a non-empty string.");
                return;
            }
            this.#name = name.trim();
        }

        set mac(mac){
            let reMAC = /^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$/;
            if (!reMAC.test(mac)) {
                console.log("Invalid MAC address: must be in the format XX:XX:XX:XX:XX:XX.");
                return;
            }
            this.#mac = mac.toUpperCase();
        }

        set switch(sw){
            this.#switch = sw;
        }

        set firmware(fw) {
            this.#firmware = fw;
        }

        set netmask(nm){
            let reNetmask = /^(255|254|252|248|240|224|192|128|0)\.((255|254|252|248|240|224|192|128|0)\.){2}(255|254|252|248|240|224|192|128|0)$/;
            if (!reNetmask.test(nm)) {
                console.log("Invalid netmask: must be a valid subnet mask.");
                return;
            }
            this.#netmask = nm;
        }

        set universes(un){
            if (!Array.isArray(un) || un.length !== 10 || !un.every(u => u instanceof Universe)) {
                console.log("Invalid universes: must be an array of 10 Universe objects.");
                return;
            }
            this.#universes = un;
        }

        set fieldbusses(fb){
            if (!Array.isArray(fb) || fb.length !== 6 || !fb.every(f => f instanceof Fieldbus)) {
                console.log("Invalid fieldbusses: must be an array of 6 Fieldbus objects.");
                return;
            }
            this.#fieldbusses = fb;
        }

        set codecs(c){
            this.#codecs = c;
        }

        set active(a) {
            this.#active = a;
        }

        // setting the status indicator of the disconnected nodes, debounce to make sure there is no
        // flickering
        setStatus(o) {
            let node = document.getElementById(this.UID);
            this.#timestamp = new Date().getTime();
            if (o) {
                if (this.#prevTimestampOn === null) {
                    this.#prevTimestampOn = this.#timestamp;
                }
                if ((this.#timestamp-this.#prevTimestampOn) > 1) {
                    this.#online = o;
                    node.classList.remove("disconnected");
                    this.#prevTimestampOn = new Date().getTime;
                    this.#prevTimestampOff = null;
                }         
            } else {
                if (this.#prevTimestampOff === null) {
                    this.#prevTimestampOff = this.#timestamp;
                }
                if ((this.#timestamp-this.#prevTimestampOff) > 1) {
                    this.#online = o;
                    node.classList.add("disconnected");
                    this.#prevTimestampOff = new Date().getTime;
                    this.#prevTimestampOn = null;
                }         
            }    
        }

        changeShownUni(up){
            up? this.#shownUniverses++ : this.#shownUniverses--;
        }

        initialiseNode() {
            if (this.#configuration !== null) {
                this.#name = this.#configuration.name;
                this.#mac = this.#configuration.mac;
                if (localStorage.getItem("activeNode") === this.#mac) {
                    this.#active = true;
                }

                this.#switch = this.#configuration.switch;
                this.#netmask = this.#configuration.mask;
                this.#firmware = this.#configuration.firmware;
                let counter = 0;
                for (const [key, value] of Object.entries(this.#configuration.fieldbus)) {
                    let params = [];
                    for (let v of Object.values(value)) {
                        params.push(v);
                    }
                    this.#enableDetector[counter].push(params[0] > 0? 1 : 0);
                    this.#enableDetector[counter].shift();
                    this.#fieldbusses.push(new Fieldbus(key, ...params));
                    counter++;
                }

                // console.log(this.#enableDetector);

                for (let i = 0; i < this.#enableDetector.length; i++) {
                    if (this.#enableDetector[i][0] === 0 && this.#enableDetector[i][1] === 1) {
                        console.log(`rising edge detected at fb ${i}`);
                        if (installation.prevInstallation !== null) {
                            console.log("prevInstallation detected");
                            let prevFb = null;
                            installation.prevInstallation.nodes.forEach((node) => {
                                node.fieldbusses.forEach((fb) => {
                                    if (fb.parentNode === this.mac) {
                                        console.log(`previous config: ${fb.lastConfig.startAddress}, ${fb.lastConfig.streamLength}`)
                                        this.fieldbusses[i].startAddress    = fb.lastConfig.startAddress;
                                        this.fieldbusses[i].streamLength    = fb.lastConfig.streamLength;
                                        console.log("restored previous config");
                                        this.configuration.handleInputChange(this.fieldbusses[i]);
                                    }
                                })
                            });
                        }
                    }
                }

                for (const [key, value] of Object.entries(this.#configuration.artnet)) {
                    let params = [];
                    for (let v of Object.values(value)){
                        params.push(v);
                    }
                    this.#universes.push(new Universe(key, ...params));
                }
                for (const value of Object.values(this.#configuration.codec)) {
                    this.codecs.push(value);
                }                          
            }
        }

        async updateFps() {
            // if not demo
            if (this.mac !== "7B:A6:80:7F:EC:7D") {
                try {
                    const response = await fetch(`http://${this.ip}/xart`, {signal: AbortSignal.timeout(2000)});
                    if (!response.ok) {
                        throw new Error(`Response status: ${response.status}`);
                    }
                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                    let parsedXart = Configuration.parseConfig(xmlDoc);
                    let newTime = new Date().getTime();
                    if (this.#lastUpdate > 0) {
                        let delta = newTime - this.#lastUpdate;
                        for (let uni = 0; uni < this.universes.length; uni++) {
                            let fps = 0;
                            let AnIn = parseInt(((parsedXart[`in${uni}`]).split(" "))[0])
                            let AnOut = (parseInt(this.universes[uni]["framecounter"]))
                            fps = (AnIn + 8192 - AnOut)%8192;
                            fps = Math.trunc(Math.round(fps/(delta/10000))/10);
                            let fpsElement = document.querySelector(`#accolade-${uni+1} text`);
                            if (fpsElement != null) {
                                fpsElement.innerHTML = `${fps}fps`;
                            }                        
                            // Updating the universes with the latest received framecounter
                            this.universes[uni]["framecounter"] = ((parsedXart[`in${uni}`]).split(" "))[0]
                        }
                    }
                
                if (!this.#online) this.setStatus(true);
                this.#lastUpdate = newTime;
                
            } 
                catch (error) {
                    if (error.name === "TimeoutError") {
                        console.error("Request timed out");
                        if (this.#online) this.setStatus(false);
                    } else if (error.name === "AbortError") {
                        console.error("Fetch aborted by user");
                    } else if (error.name === "TypeError") {
                        console.error("AbortSignal.timeout() method is not supported");
                    } else {
                        console.error("Failed to update fps:", error.message);
                    }
                }
            }        
        }

        processForm = (e) => {
            e.preventDefault();
            e.stopPropagation();
            let name = document.getElementById("new-name");
            let mask = document.getElementById("new-mask");
            let ip = document.getElementById("new-ip");
            this.name = name.value;
            this.netmask = mask.value;
            this.ip = ip.value;
            console.log(this.name);
            if (this.mac !== "7B:A6:80:7F:EC:7D") this.configuration.handleFormChange(this);
        }
    }

    class NodeTemplate extends Node {
        constructor(ip, oldNode, name, mac, sw, nm, un, fb, c, fw){
            super(ip, oldNode, true);
            this.name = name;
            this.mac = mac;
            this.switch = sw;
            this.netmask = nm;
            this.universes = un;
            this.fieldbusses = fb;
            this.codecs = c;
            this.firmware = fw;
        }
    }

    class Universe {
        #id;
        #universe;
        #keep;
        #framecounter;

        #paramBytes = 4;

        constructor(id, universe, keep, framecounter) {
            this.#id = id;
            this.#universe = universe;
            this.#keep = keep;
            this.#framecounter = framecounter;
        }

        get id() {
            return this.#id;
        }

        get universe() {
            return this.#universe;
        }

        get keep() {
            return this.#keep;
        }

        get framecounter() {
            return this.#framecounter
        }

        set framecounter(f) {
            this.#framecounter = f;
        }

        set universe(u) {
            this.#universe = u;
        }

        set keep(k) {
            this.#keep = k;
        }
    }

    class Fieldbus {
        #id;
        #codec;
        #startAddress;
        #streamLength;
        #finetuningParams

        constructor(id, codec, startAddress, streamLength, finetuningParams) {
            this.#id = id;
            this.#codec = codec;
            this.#startAddress = startAddress;
            this.#streamLength = streamLength;
            this.#finetuningParams = finetuningParams;
        }

        get id () {
            return this.#id;
        }

        get codec() {
            return this.#codec;
        }

        get startAddress() {
            return this.#startAddress;
        }

        get streamLength() {
            return this.#streamLength;
        }

        get finetuningParams() {
            return this.#finetuningParams;
        }

        set streamLength(s) {
            this.#streamLength = s;
        }

        set startAddress(s) {
            this.#startAddress = s;
        }

        set codec(c) {
            this.#codec = c;
        }

        setStart = (e) => {
            switch (e.target.classList[0]) {
                case "top-handle": 
                    this.start = "top"
                    break;
                case "move":
                    if (e.target.offsetParent.classList.contains("overflow") & e.target.tagName === "H3") break;
                    this.start = "patch";
                    break;
                case "bottom-handle":
                    this.start = "bottom"
                    break;
            }
            this.startedDrag = true;
            this.startCoord = e.clientY;
            this.targetFb = e.target.closest(".fieldbus").id;
            console.log(this.streamLength);
        }

        setMove = (e) => {
            if (this.startedDrag) {
                let changePatch = (newRange = undefined, newStart = undefined) => {
                    let patch = document.querySelector(`#fb-${parseInt(this.#id.split("out")[1])+1} .address.range .patch`);
                    if (newRange !== undefined) {
                        this.newRange = Math.floor(newRange);
                        let rangeElement;
                        let status = !document.querySelector(".patch").classList.contains("config");
                        if (status) {
                            rangeElement = document.querySelector(`#${this.targetFb} .address-container h2`);
                            rangeElement.innerHTML = this.newRange;
                        } else {
                            rangeElement = document.querySelector(`#${this.targetFb} .address-container h2 input`);
                            rangeElement.value = this.newRange;
                        }
                        patch.style.height = String((this.newRange/(512*installation.activeNode.shownUniverses))*100)+"%";
                        if (this.newRange <= 280 | !status & this.newRange <= 400) {
                            patch.classList.add("overflow");
                        } else {
                            if (patch.classList.contains("overflow")) patch.classList.remove("overflow");
                        }
                        if (this.newRange <= 120 | !status & this.newRange <= 230) {
                            patch.classList.add("extreme");
                        } else {
                            if (patch.classList.contains("extreme")) patch.classList.remove("extreme");
                        }
                    }
                    if (newStart !== undefined) {
                        this.newStart = Math.floor(newStart);
                        patch.style.top = String((newStart/(512*installation.activeNode.shownUniverses))*100)+"%";
                        let startElement;
                        if (!document.querySelector(".patch").classList.contains("config")) {
                            startElement = document.querySelector(`#${this.targetFb} .address-container h3 span`);
                            startElement.innerHTML = this.newStart;
                        } else {
                            startElement = document.querySelector(`#${this.targetFb} .address-container h3 input`);
                            startElement.value = this.newStart;
                        }    
                    }
                }

                const threshold = 50;
                let newRange = 0;
                let newStart = 0;
                let dif = 0;
                const addressRange = document.querySelector(`#fb-${parseInt(this.#id.split("out")[1])+1} .address.range`);
                const addressesPerPixel = (512*installation.activeNode.shownUniverses)/addressRange.getBoundingClientRect()["height"];

                switch (this.start) {
                    case "top":
                        const offsetTop = this.startCoord-e.clientY;
                        newStart = this.#startAddress - (offsetTop*addressesPerPixel);
                        newRange = this.#streamLength + (offsetTop*addressesPerPixel);
                        for (let i=0; i<= installation.activeNode.shownUniverses; i++) {
                            dif = newStart - (512*i);
                            if (dif > -threshold && dif < threshold) {
                                let hop = (512*i) - newStart;
                                newStart = 512*i+1;
                                newRange = newRange - hop -1 ;
                                break;
                            }
                        }

                        if (newRange < 1) {
                            newRange = 1;
                            newStart = this.#startAddress + this.#streamLength - 2;
                        }

                        if (newStart < 1) {
                            newStart = 1;
                            newRange = this.#startAddress + this.#streamLength -1 ;
                        }
                        changePatch(newRange, newStart);
                        break;
                    case "bottom":
                        const offsetBottom = this.startCoord-e.clientY;
                        newRange = this.#streamLength - (offsetBottom*addressesPerPixel);
                        // snapping to full universes
                        for (let i=0; i<= installation.activeNode.shownUniverses; i++) {
                            dif = (512*i-(this.#startAddress+newRange));
                            if (dif < threshold && dif > -threshold){
                                newRange = (512*i)-(this.#startAddress-1)
                                break;
                            }
                        }
                        // bottom and top limits
                        if (this.startAddress + newRange > 512*installation.activeNode.shownUniverses) newRange = (512*installation.activeNode.shownUniverses)-(this.#startAddress-1);
                        if (newRange < 1) newRange = 1;
                        changePatch(newRange);
                        break;  
                    case "patch":
                        const offset = this.startCoord-e.clientY;
                        newStart = this.#startAddress - (offset*addressesPerPixel);
                        for (let i=0; i<= installation.activeNode.shownUniverses; i++) {
                            dif = newStart - (512*i);
                            if (dif > -threshold && dif < threshold) {
                                newStart = (512*i) + 1;
                                break;
                            }          
                        }
                        if (newStart < 1) newStart = 1;
                        else if (newStart + this.#streamLength > 512*installation.activeNode.shownUniverses) newStart = (512*installation.activeNode.shownUniverses) - this.#streamLength;
                        changePatch(undefined, newStart);
                        break
                    default:
                        break;           
                }
            }
        }

        updateValues = (e) => {
            if (e.target.tagName === "INPUT" | e.target.tagName === "SELECT" | e.target.tagName === "OPTION") {
                return;
            }
            this.start = '';
            this.startedDrag = false;   
            if (this.newRange !== undefined) this.#streamLength = this.newRange;
            if (this.newStart !== undefined) this.#startAddress = this.newStart;
            
            if (installation.activeNode.mac !== "7B:A6:80:7F:EC:7D") {
                installation.activeNode.configuration.handleInputChange(this);
            }
        }

        handleParamChange = (e) => {
                let target = e.target;
                let value = target.value;
                console.log(target);

                switch (target.id) {
                    case "stream-length":
                        this.streamLength = parseInt(value);
                        break;
                    case "start-address":
                        this.startAddress = parseInt(value);
                        break;
                    case "codec":
                        this.codec = target.selectedIndex;
                        if (this.codec === 0) {
                            this.lastConfig = this;
                            this.parentNode = installation.activeNode.mac;
                        }
                        break;
                    default:
                        console.log("can't detect the change");
                        break;
                }
                installation.activeNode.configuration.handleInputChange(this);
            }
    }

    class Configuration {
        #xmlConfig;
        #configObject;

        // look up table for the amount of hex characters per parameter
        #ioHexCount = {
            "artnet": {
                "universe": 4,
                "keep": 4,
                "framecounter": 4
            },
            "fieldbus": {
                "codec": 2,
                "startAddress": 4,
                "streamLength": 4,
                "fineTuningParams": 16
            }
            
        }

        constructor(ip){
            return( async () => {
                this.#xmlConfig = await this.fetchXmlConfig(ip);
                this.#configObject = Configuration.parseConfig(this.#xmlConfig);
                return this;
            })();
        }

        get xmlConfig(){
            return this.#xmlConfig;
        }

        get configObject(){
            return this.#configObject;
        }

        get name() {
            return dig(this.#configObject, "name");
        }

        get mac() {
            return hexToMac(dig(this.#configObject, "mac"));
        }

        get mask() {
            return hexToIP(dig(this.#configObject, "mask"));
        }

        get switch() {
            return this.convertObjectAndMap(SWITCHPARAMS, "switch")
        }

        get fieldbus() {
            return this.convertObjectAndMap(FIELDBUSPARAMS, "fieldbus");
        }

        get artnet() {
            return this.convertObjectAndMap(ARTNETPARAMS, "artnet");
        }

        get codec() {
            return this.#configObject["codec"];
        }

        get firmware() {
            return this.#configObject["sys"]["fw"];
        }

        async fetchXmlConfig(ip) {
            try {
                const response = await fetch(`http://${ip}/xml`, {signal: AbortSignal.timeout(3000)});
                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                return xmlDoc;
            } 
            catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.error("AbortSignal.timeout() method is not supported");
                } else {
                    console.error("Failed to fetch XML configuration:", error.message);
                }
            }
        }

        async postXmlConfig(xml) {
            try {
                const response = await fetch(`http://${installation.activeNode.ip}/xml`, {
                    signal: AbortSignal.timeout(5000),
                    method: "POST",
                    body: xml
                })

                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }
                // removing all the configuration event listeners
                // installation.unilist.removeEventListener("change", installation.handleUniChange);
                let demoNode = installation.nodes.find((node) => node.mac === "7B:A6:80:7F:EC:7D");
                await installation.fetchNodes(false);
                installation.nodes.push(demoNode);
                installation.updateNav(false);
                installation.navSwitcher();
            }
            
            catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.error("AbortSignal.timeout() method is not supported");
                } else {
                    console.error("Failed to post XML configuration:", error.message);
                }
            }
        }

        handleFormChange(n) {
            let xmlText = '<node>\n';
            xmlText += `\t<sys>\n`;
            xmlText += `\t\t<ip>${ipToHex(n.ip)}</ip>\n`;
            xmlText += `\t\t<mask>${ipToHex(n.netmask)}</mask>\n`;
            xmlText += `\t\t<name>${n.name}</name>\n`;
            xmlText += `\t</sys>\n`;
            xmlText += '</node>';
            // console.log(xmlText);
            this.postXmlConfig(xmlText);
        }

        handleInputChange(io) {   
            let xmlText = '<node>'
            io.id[0] === "i"? xmlText += '<artnet>' : xmlText += '<fieldbus>';
            xmlText += `<${io.id}>`
            io.id[0] === "i"? xmlText += hexConverter(this.#ioHexCount["artnet"], io.universe, io.keep) : xmlText += hexConverter(this.#ioHexCount["fieldbus"], io.codec, io.startAddress, io.streamLength);
            xmlText += `</${io.id}>`
            io.id[0] === "i"? xmlText += '</artnet>' : xmlText += '</fieldbus>';
            xmlText += '</node>';
            // console.log(xmlText);
            this.postXmlConfig(xmlText);
        }

        convertObjectAndMap(mapParams, tag) {
            let convertedObject = {};
            for (const [key,value] of Object.entries(dig(this.#configObject, tag))){
                convertedObject[key] = {}
                let params = value.split(" ");
                for (let i = 0; i < params.length; i++) {
                    convertedObject[key][mapParams[i]] = parseInt(params[i], 16);
                }
            }
            return convertedObject;
        }

        static parseConfig(xmlObj) {
        let config = {};
        
        // Recursieve functie die over all nodes gaat en het config object vult
        function traverseConfig(xmlNode, config) {
            if (xmlNode !== null && typeof xmlNode === 'object') {
                for (let i = 0; i < xmlNode.childNodes.length; i++) {
                    const childNode = xmlNode.childNodes.item(i);
                    if (childNode.nodeType === 1) {
                        if (childNode.childElementCount > 0) {
                            config[childNode.nodeName] = {};
                            traverseConfig(childNode, config[childNode.nodeName]);
                        } else {
                            config[childNode.nodeName] = childNode.textContent.trim();
                        }
                    }
                }
            }
        }

        traverseConfig(xmlObj.documentElement, config);
            return config;
        }
    }

    // Helper functie om de gewenste value te verkrijgen vanuit een object
    // https://www.30secondsofcode.org/js/s/get-nested-object-value/#search-for-a-deeply-nested-property-in-an-object
    const dig = (obj, target) => 
                target in obj ? obj[target] : Object.values(obj).reduce((acc, val) => {
                    if (acc !== undefined) return acc;
                    if (typeof val === 'object') return dig(val, target);
                }, undefined);

    function hexToIP(hex){
        let ip = "";
        for(let i = 0; i < hex.length; i+=2){
            ip += parseInt(hex.substring(i, i+2), 16);
            if(i < hex.length - 2){
                ip += ".";
            }
        }
        return ip;
    }

    function ipToHex(ip) {
        let hex = "";
        const octets = ip.split('.');
        for (let i = 0; i < octets.length; i++) {
            let hexValue = parseInt(octets[i]).toString(16).toUpperCase();
            if (hexValue.length < 2) {
                // hexValue = '0' + hexValue; // Ensure two-character hexadecimal
                hexValue = hexValue.padStart(2, '0');
            }
            hex += hexValue;
        }
        return hex;
    }

    function hexToMac(mac){
        let macAddress = "";
        for(let i = 0; i < mac.length; i+=2){
            macAddress += mac.substring(i, i+2);
            if(i < mac.length - 2){
                macAddress += ":";
            }
        }
        return macAddress;
    }

    function macToHex(mac) {
        let hex = "";
        const parts = mac.split(':');
        for (let i = 0; i < parts.length; i++) {
            hex += parts[i].toUpperCase();
        }
        return hex;
    }

    function hexConverter(io, ...params) {
        let paddedHex = '';
        let counter = 0;
        for (const bytecount of Object.values(io)) {
            try {
                paddedHex += params[counter].toString(16).toUpperCase().padStart(bytecount, '0');
                paddedHex += " ";
            } catch (error) {
                // console.log("skipping one parameter while converting to HEX, consider passing a zero if it's in the beginning of the data")
            }
            counter++;
            
        }
        return paddedHex.trim();
    }

    function generateDomTree(tag, value=null, attributes=null, children=null, listeners=null) {
        let root = document.createElement(tag);
        value? root.innerHTML = value : root.textContent = "";
        if (attributes) {
            for (const [key, value] of Object.entries(attributes)) {
                root.setAttribute(key, value);
            }
        }
        if (children) {
            Array.from(children).forEach((childNode) => root.appendChild(childNode));
        }
        if (listeners) {
            for (const [e, f] of Object.entries(listeners)) {
            root.addEventListener((e), f);
            }
        }
        return root;
    }
    
    let installation;

    async function intitialise(init) {
        installation = await new Installation("Lux-Lumen");
        installation.updateNav(init);
        installation.navSwitcher();
        if (init) installation.eventInit();  
    }
        
    document.addEventListener("DOMContentLoaded", async () => {
        await intitialise(true);
    })
    
    


</script>
<body>
    <header>
        <div id="banner">
            <!-- svg definition of the ethernet ports -->
            <svg xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 490.43">
                <defs>
                    <symbol id="ethernet-port">
                        <path fill-rule="nonzero" d="M29.08 0h453.85c8.04 0 15.28 3.33 20.5 8.55 5.26 5.27 8.57 12.64 8.57 20.53v432.27c0 7.94-3.33 15.23-8.59 20.49-5.25 5.25-12.54 8.59-20.48 8.59H29.08c-7.89 0-15.26-3.31-20.53-8.58C3.33 476.63 0 469.4 0 461.35V29.08c0-8.05 3.3-15.3 8.54-20.54l2.18-1.91A28.741 28.741 0 0 1 29.08 0z"/>
                        <path fill="#CCC" d="M29.08 21.98h453.85c3.9 0 7.09 3.35 7.09 7.1v432.27c0 3.75-3.34 7.1-7.09 7.1H29.08c-3.75 0-7.1-3.19-7.1-7.1V29.08c0-3.91 3.19-7.1 7.1-7.1z"/>
                        <path fill-rule="nonzero" d="M82.08 65.09h348.08c6.53 0 12.4 2.71 16.62 6.93 4.27 4.27 6.95 10.25 6.95 16.65v239.14h-70.87v48.58h-40.95v46.95H171.27v-46.95h-40.94v-48.58H58.5V88.67c0-6.54 2.67-12.42 6.92-16.66 4.3-4.28 10.23-6.92 16.66-6.92z"/>
                        <path fill="#fff" d="M82.08 81.57h348.08c3.9 0 7.1 3.35 7.1 7.1v222.66h-70.88v48.59h-40.95v46.94H187.75v-46.94H146.8v-48.59H74.98V88.67c0-3.91 3.19-7.1 7.1-7.1z"/>
                        <path fill-rule="nonzero" d="M365.43 297.06h71.83c9.09 0 16.47 7.38 16.47 16.48v46.38c0 9.09-7.38 16.47-16.47 16.47h-71.83c-9.09 0-16.48-7.38-16.48-16.47v-46.38c0-9.1 7.39-16.48 16.48-16.48z"/>
                        <path fill="#fff" d="M437.26 313.54h-71.83v46.38h71.83z"/>
                        <path fill-rule="nonzero" d="M74.98 297.06h71.82c9.1 0 16.48 7.38 16.48 16.48v46.38c0 9.09-7.38 16.47-16.48 16.47H74.98c-9.1 0-16.48-7.38-16.48-16.47v-46.38c0-9.1 7.38-16.48 16.48-16.48z"/>
                        <path fill="#fff" d="M74.98 313.54h71.82v46.38H74.98z"/>
                        <rect x="109.2" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="153.91" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="198.62" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="243.33" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="288.03" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="332.74" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                        <rect x="377.45" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"/>
                    </symbol>
                </defs>
            </svg>
            <!-- end of ehternet port definition -->
            <div id="eth1">
                <span>ETH1</span>
                <svg viewBox="0 0 512 490.43">  
                    <use href="#ethernet-port"/>
                </svg>
            </div>
            <div id="eth2">
                <span>ETH2</span>
                <svg viewBox="0 0 512 490.43">  
                    <use href="#ethernet-port"/>
                </svg>
            </div>
            <h1>Configurator</h1>
            <div id="dark-mode-switch">
                <input type="checkbox" id="switch">
                <label for="switch">
                    <?xml version="1.0" encoding="utf-8"?>
                    <svg class="sun" xmlns="http://www.w3.org/2000/svg" x="0px" y="px" viewBox="0 0 50 50">
                        <path d="M 24.90625 3.96875 C 24.863281 3.976563 24.820313 3.988281 24.78125 4 C 24.316406 4.105469 23.988281 4.523438 24 5 L 24 11 C 23.996094 11.359375 24.183594 11.695313 24.496094 11.878906 C 24.808594 12.058594 25.191406 12.058594 25.503906 11.878906 C 25.816406 11.695313 26.003906 11.359375 26 11 L 26 5 C 26.011719 4.710938 25.894531 4.433594 25.6875 4.238281 C 25.476563 4.039063 25.191406 3.941406 24.90625 3.96875 Z M 10.65625 9.84375 C 10.28125 9.910156 9.980469 10.183594 9.875 10.546875 C 9.769531 10.914063 9.878906 11.304688 10.15625 11.5625 L 14.40625 15.8125 C 14.648438 16.109375 15.035156 16.246094 15.410156 16.160156 C 15.78125 16.074219 16.074219 15.78125 16.160156 15.410156 C 16.246094 15.035156 16.109375 14.648438 15.8125 14.40625 L 11.5625 10.15625 C 11.355469 9.933594 11.054688 9.820313 10.75 9.84375 C 10.71875 9.84375 10.6875 9.84375 10.65625 9.84375 Z M 39.03125 9.84375 C 38.804688 9.875 38.59375 9.988281 38.4375 10.15625 L 34.1875 14.40625 C 33.890625 14.648438 33.753906 15.035156 33.839844 15.410156 C 33.925781 15.78125 34.21875 16.074219 34.589844 16.160156 C 34.964844 16.246094 35.351563 16.109375 35.59375 15.8125 L 39.84375 11.5625 C 40.15625 11.265625 40.246094 10.800781 40.0625 10.410156 C 39.875 10.015625 39.460938 9.789063 39.03125 9.84375 Z M 25 15 C 19.484375 15 15 19.484375 15 25 C 15 30.515625 19.484375 35 25 35 C 30.515625 35 35 30.515625 35 25 C 35 19.484375 30.515625 15 25 15 Z M 4.71875 24 C 4.167969 24.078125 3.78125 24.589844 3.859375 25.140625 C 3.9375 25.691406 4.449219 26.078125 5 26 L 11 26 C 11.359375 26.003906 11.695313 25.816406 11.878906 25.503906 C 12.058594 25.191406 12.058594 24.808594 11.878906 24.496094 C 11.695313 24.183594 11.359375 23.996094 11 24 L 5 24 C 4.96875 24 4.9375 24 4.90625 24 C 4.875 24 4.84375 24 4.8125 24 C 4.78125 24 4.75 24 4.71875 24 Z M 38.71875 24 C 38.167969 24.078125 37.78125 24.589844 37.859375 25.140625 C 37.9375 25.691406 38.449219 26.078125 39 26 L 45 26 C 45.359375 26.003906 45.695313 25.816406 45.878906 25.503906 C 46.058594 25.191406 46.058594 24.808594 45.878906 24.496094 C 45.695313 24.183594 45.359375 23.996094 45 24 L 39 24 C 38.96875 24 38.9375 24 38.90625 24 C 38.875 24 38.84375 24 38.8125 24 C 38.78125 24 38.75 24 38.71875 24 Z M 15 33.875 C 14.773438 33.90625 14.5625 34.019531 14.40625 34.1875 L 10.15625 38.4375 C 9.859375 38.679688 9.722656 39.066406 9.808594 39.441406 C 9.894531 39.8125 10.1875 40.105469 10.558594 40.191406 C 10.933594 40.277344 11.320313 40.140625 11.5625 39.84375 L 15.8125 35.59375 C 16.109375 35.308594 16.199219 34.867188 16.039063 34.488281 C 15.882813 34.109375 15.503906 33.867188 15.09375 33.875 C 15.0625 33.875 15.03125 33.875 15 33.875 Z M 34.6875 33.875 C 34.3125 33.941406 34.011719 34.214844 33.90625 34.578125 C 33.800781 34.945313 33.910156 35.335938 34.1875 35.59375 L 38.4375 39.84375 C 38.679688 40.140625 39.066406 40.277344 39.441406 40.191406 C 39.8125 40.105469 40.105469 39.8125 40.191406 39.441406 C 40.277344 39.066406 40.140625 38.679688 39.84375 38.4375 L 35.59375 34.1875 C 35.40625 33.988281 35.148438 33.878906 34.875 33.875 C 34.84375 33.875 34.8125 33.875 34.78125 33.875 C 34.75 33.875 34.71875 33.875 34.6875 33.875 Z M 24.90625 37.96875 C 24.863281 37.976563 24.820313 37.988281 24.78125 38 C 24.316406 38.105469 23.988281 38.523438 24 39 L 24 45 C 23.996094 45.359375 24.183594 45.695313 24.496094 45.878906 C 24.808594 46.058594 25.191406 46.058594 25.503906 45.878906 C 25.816406 45.695313 26.003906 45.359375 26 45 L 26 39 C 26.011719 38.710938 25.894531 38.433594 25.6875 38.238281 C 25.476563 38.039063 25.191406 37.941406 24.90625 37.96875 Z"></path>
                    </svg>
                    <svg class="moon" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 122.88 122.89" style="enable-background:new 0 0 122.88 122.89" xml:space="preserve"><g><path d="M49.06,1.27c2.17-0.45,4.34-0.77,6.48-0.98c2.2-0.21,4.38-0.31,6.53-0.29c1.21,0.01,2.18,1,2.17,2.21 c-0.01,0.93-0.6,1.72-1.42,2.03c-9.15,3.6-16.47,10.31-20.96,18.62c-4.42,8.17-6.1,17.88-4.09,27.68l0.01,0.07 c2.29,11.06,8.83,20.15,17.58,25.91c8.74,5.76,19.67,8.18,30.73,5.92l0.07-0.01c7.96-1.65,14.89-5.49,20.3-10.78 c5.6-5.47,9.56-12.48,11.33-20.16c0.27-1.18,1.45-1.91,2.62-1.64c0.89,0.21,1.53,0.93,1.67,1.78c2.64,16.2-1.35,32.07-10.06,44.71 c-8.67,12.58-22.03,21.97-38.18,25.29c-16.62,3.42-33.05-0.22-46.18-8.86C14.52,104.1,4.69,90.45,1.27,73.83 C-2.07,57.6,1.32,41.55,9.53,28.58C17.78,15.57,30.88,5.64,46.91,1.75c0.31-0.08,0.67-0.16,1.06-0.25l0.01,0l0,0L49.06,1.27 L49.06,1.27z"/></g></svg>
                </label>
            </div>
        </div>
    </header>
    <div id="sidebar">
        <div id="title">
            <h2>Lux<br>Lumen</h2>
            <h2>Art-Net<br>node</h2>
        </div>
        <div id="edit">
            <input type="checkbox" id="edit-switch" autocomplete="off">
            <label for="edit-switch">
                <?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
                <svg class="e-button" id="pen" viewBox="0 0 24 24" id="_24x24_On_Light_Edit" data-name="24x24/On Light/Edit" xmlns="http://www.w3.org/2000/svg">
                    <rect id="view-box" width="24" height="24" fill="none"/>
                    <path id="Shape" d="M.75,17.5A.751.751,0,0,1,0,16.75V12.569a.755.755,0,0,1,.22-.53L11.461.8a2.72,2.72,0,0,1,3.848,0L16.7,2.191a2.72,2.72,0,0,1,0,3.848L5.462,17.28a.747.747,0,0,1-.531.22ZM1.5,12.879V16h3.12l7.91-7.91L9.41,4.97ZM13.591,7.03l2.051-2.051a1.223,1.223,0,0,0,0-1.727L14.249,1.858a1.222,1.222,0,0,0-1.727,0L10.47,3.91Z" stroke="#FFF200" transform="translate(3.25 3.25)" fill="#FFF200"/>
                </svg>
            </label>
        </div>
        <nav>
            <ul id="node-list">
            </ul>
        </nav>
        <div class="info config">
            <h3 id="firmware">firmware: <span></span></h3>
            <h3 id="config">config: <span>V0.01</span></h3>
        </div>
    </div>
    <div id="main-config">
        <div class="universe card">
            <div class="card" id="tab">Universes</div>
            <ol id="universes">
            </ol>
            <div id="universe-filter-container">
                <div id="universe-filter">
                    <button class="e-button" id="decrement">-</button>
                    <button class="e-button" id="increment">+</button>
                </div>
            </div>
        </div>
        <!-- svg definition of the accolades -->
        <!-- end of accolade definition -->
        <div id="accolades">
        </div>
        <div id="fieldbusses">
        </div>
        </div>
    </div>
</body>
</html>
