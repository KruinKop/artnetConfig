<!DOCTYPE html>
<!-- saved from url=(0019)http://2.121.17.23/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Art-Net configurator</title>
<style>
    /* Resets all the style rules applied by browser 

   http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
    */

    html, body, div, span, applet, object, iframe,
    h1, h2, h3, h4, h5, h6, p, blockquote, pre,
    a, abbr, acronym, address, big, cite, code,
    del, dfn, em, img, ins, kbd, q, s, samp,
    small, strike, strong, sub, sup, tt, var,
    b, u, i, center,
    dl, dt, dd, ol, ul, li,
    fieldset, form, label, legend,
    table, caption, tbody, tfoot, thead, tr, th, td,
    article, aside, canvas, details, embed, 
    figure, figcaption, footer, header, hgroup, 
    menu, nav, output, ruby, section, summary,
    time, mark, audio, video {
    	margin: 0;
    	padding: 0;
    	border: 0;
    	font-size: 100%;
    	/* font: inherit; */
    	vertical-align: baseline;
    }
    /* HTML5 display-role reset for older browsers */
    article, aside, details, figcaption, figure, 
    footer, header, hgroup, menu, nav, section {
    	display: block;
    }
    body {
    	line-height: 1;
    }
    ol, ul {
    	list-style: none;
    }
    blockquote, q {
    	quotes: none;
    }
    blockquote:before, blockquote:after,
    q:before, q:after {
    	content: '';
    	content: none;
    }
    table {
    	border-collapse: collapse;
    	border-spacing: 0;
    }
    
    /* ============= Style rules defined by us ============== */
    /* ======= starting with some custom properties ========= */

    :root {
        /* font */
        --font-nav-title: 'Reddit', sans-serif;
        --font-regular: 'Roboto', sans-serif;

        /* font sizes */
        --font-size-xxl: 4rem;
        --font-size-xl: 2.5rem;
        --font-size-large: 2rem;
        --font-size-medium: 1.4rem;
        --font-size-small: 0.9rem;
        --font-size-xs: 0.7rem;

        /* spacing */
        --grid-nav-width: 200px;
        --banner-height: 85px;
        --padding-small: 15px;
        --padding-medium: 20px;
        --padding-large: 30px;
    }   

    body {
        /* colors */
        --ll-yellow: #FFF200;
        --ll-light-yellow: #F8EB00;
        --ll-yellow-font: #F8EB00;
        --ll-mustard: #B9AF00;
        --bg-coal: #363633;
        --bg-dmx-box: #2F2F2F;
        --bg-grey: #82827B;
        --bg-input-grey: #82827B;
        --bg-button-grey: #5d5d44;
        --bg-grey-focus: #777761;
        --bg-grey-pressed: #63635e;
        --bg-first-row: #454545;
        --bg-table-separator: #656565;
        --bg-card-grey: #4d4d4d;
        --bg-error-red: #8a3838;
        --bg-status-green: #2Aff00;

        background-color: var(--bg-coal);
        display: grid;
        grid-template-columns: var(--grid-nav-width) 1fr;
        grid-template-rows: var(--banner-height) calc(100vh - var(--banner-height) - var(--padding-small));
        /* used so that dragging the mouse over the screen doesn't cause selecting of elements */
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10 and IE 11 */
        user-select: none; /* Standard syntax */ 

        
        input[type=number]::-webkit-inner-spin-button {
            opacity: 1
        }

    }

    body.light {
        --ll-yellow: rgb(82, 82, 82);
        --ll-light-yellow: #4d4d4d;
        --ll-mustard: #efde89;
        --ll-yellow-font: #646464;
        --nav-font: #4d4d4d;
        --bg-coal: #f5f2ec;
        --bg-dmx-box: #6f5239;
        --bg-grey: #ebddc3;
        --bg-input-grey: #fdf4e3;
        --bg-button-grey: #f0f0e7;
        --bg-grey-focus: #e8ddb2;
        --bg-grey-pressed: #cdbd8c;
        --bg-table-separator: #cac1a2;
        --bg-first-row: #b7b39d;
        --bg-light-card-grey: #DDDDDD;
        --bg-light-address: #FDFFF9;
        --bg-card-grey: #d8ccb5;
        --bg-error-red: #d28383;
    }

    nav, .info, #banner span, #title {
        font-family: var(--font-regular);
    }

    #title h2:nth-child(2), h1 {
        color: var(--bg-coal);
    }

    #title h2 {
        font-weight: 400;
    }

    .info {
        color: var(--ll-light-yellow)
    }

    /*==================================== Banner ==================================== */
    
    header {
        display: grid;
        position: relative;
        grid-row: 1/2;
        grid-column: 1/3;
        grid-template-columns: subgrid;
        margin: var(--padding-small) var(--padding-small) 0 var(--padding-small);
        min-width: 620px;
        background-color: var(--ll-mustard); 
        border-radius: 20px;
        box-shadow: 5px 10px 15px rgba(0,0,0,0.5);
        z-index: 100;
    }

    .light header {
        box-shadow: 5px 10px 15px rgba(179, 179, 179, 0.5);
    }

    #banner {
        display: grid;
        column-gap: var(--padding-small);
        grid-column: 2/3;
        grid-template-columns: clamp(29px, 5vw, 50px) repeat(2, 40px) auto 50px var(--padding-small);
        align-items: center;
    }

    #eth1 {
        position: relative;
        grid-column: 2/3;
    }

    #eth2 {
        position: relative;
        grid-column: 3/4;
    }

    h1 {
        grid-row: 1;
        grid-column: 4/5;
        justify-self: center;
        position: relative;
        bottom: 2px;
        font-size: var(--font-size-xl);
        font-family: 'Courier New', Courier, monospace;
        font-weight: 400;
        color: #363633;
    }

    h3 {
        font-weight: 300;
        word-break: break-all;
    }

    /* ============= Dark mode switch ============== */

    #dark-mode-switch {
        grid-column: 5/6;
    }

    #dark-mode-switch label {
        width: 70px;
        height: 30px;
        position: relative;
        bottom: 4px;
        display: block;
        background-color: var(--bg-coal);
        border-radius: 200px;
        box-shadow: inset 0px 5px 15px rgba(0,0,0,0.4), inset 0px -5px 15px rgba(255,255,255,0.4);
        cursor: pointer;
        transition: 0.3s;
    }

    #dark-mode-switch label:after{
        content: "";
        width: 25px;
        height: 25px;
        position: absolute;
        top: 2.5px;
        left :2.5px;
        background: linear-gradient(180deg, #777, #3a3a3a);
        border-radius: 40px;
        box-shadow: 0px 5px 10px rgba(0,0,0,0.2);
        transition: 0.3s;
    }

    #dark-mode-switch input, #edit input {
        width: 0;
        height: 0;
        visibility: hidden;
    }

    #dark-mode-switch input:checked + label {
        background-color: var(--bg-coal);
    }

    #dark-mode-switch input:checked + label:after {
        left: calc(100% - 2.5px);
        transform: translateX(-100%);
        background: linear-gradient(270deg, var(--bg-grey-focus), var(--bg-card-grey));
    }

    #dark-mode-switch label:hover:after {
        width: 35px;
    }

    #dark-mode-switch label svg {
        position: absolute;
        width: 20px;
        top: 5px;
        z-index: 100;
    }

    #dark-mode-switch label svg.sun {
        width: 25px;
        left: 43px;
        top: 3px;
        fill: #7e7e7e;
        transition: 0.3s;
    }

    #dark-mode-switch label svg.moon {
        left: 5px;
        fill: #dbdbdb;
        transition: 0.3s;
    }

    #dark-mode-switch input:checked + label svg.sun {
        fill: #fff;
        transition: 0.3s;

    }

    #dark-mode-switch input:checked + label svg.moon {
        fill: #7e7e7e;
        transition: 0.3s;
    }

    /* ============= Edit mode switch ============== */

    .e-button {
        height: 25px;
        width: 25px;
        background-color: var(--bg-button-grey);
        border: 2px solid var(--ll-yellow);
        color: var(--ll-yellow);
        border-radius: 100%;
    }

    #pen {
        height: 20px;
        width: 20px;
        padding: 5px;
    }

    .e-button:hover{
        cursor: pointer;
        background-color: var(--bg-grey-focus);
    }

    .e-button:active {
        background-color: var(--bg-grey-pressed)
    }



    /*==================================== Navbar ==================================== */

    #sidebar {
        display: grid;
        grid-template-rows: 125px 10fr 1fr;
        grid-row: 1/2;
        grid-column: 1/2;
        margin: var(--padding-small) 0 var(--padding-small) var(--padding-small);
        height: calc(100vh - 2*var(--padding-small));
        min-height: calc(520px + var(--padding-large) + var(--banner-height) - var(--padding-small));
        min-width: 120px;
        background-color: var(--bg-grey);
        border-radius: 20px;
        z-index: 101;
    }

    #sidebar.light {
        background-color: var(--bg-light-grey);
    }

    nav {
        padding-top: 30px;
        grid-column: 1;
        grid-row: 2;      
        font-size: 2rem;
        overflow-y: auto;
        overflow-x: hidden;
        scrollbar-width: thin;
        scrollbar-color: var(--ll-light-yellow) var(--bg-card-grey);
        scrollbar-gutter: stable;
        direction: rtl;
        /* TODO make the scollbar look pretty */
        -webkit-mask-image: linear-gradient(to bottom, transparent 0, black var(--top-mask-size, 0), black calc(100% - var(--bottom-mask-size, 0)), transparent 100%);
        mask-image: linear-gradient(to bottom, transparent 0, black var(--top-mask-size, 0), black calc(100% - var(--bottom-mask-size, 0)), transparent 100%);
        --top-mask-size: 0px;
        --bottom-mask-size: 0px;
    }

    nav.is-top-overflowing {
      --top-mask-size: 48px !important;
    }

    nav.is-bottom-overflowing {
      --bottom-mask-size: 48px !important;
    }

    nav ul {
        direction: ltr;
    }

    #title {
        grid-column:1;
        grid-row: 1;
    }

    #title h2 {
        grid-row:1/2;
        font-size: var(--font-size-large);
        text-align: right;
        margin-right: 10px;
    }

    /* Lux-Lumen */
    #title h2:nth-child(1), #info {
        color: var(--ll-yellow);
    }

    .light #title h2:nth-child(1), .light #info {
        color: var(--ll-yellow-font);
    }

    /* Art-Net node */
    #title h2:nth-child(2) {
        position: relative;
        z-index: 101;
    }

    #edit {
        z-index: 1000;
        grid-column: 4;
        justify-self: center;
        align-self: end;
        grid-row: 1;
        position: relative;
        top: 20px;
        left: 130px;
    }

    #edit label {
        position: relative;
        bottom: 9px;
        left: 20px;
    }

    #node-list {
        display: flex;
        flex-direction: column;
    }

    .node {
        z-index: 101;
        font-size: var(--font-size-medium);
        padding: var(--padding-small) 0 var(--padding-small) var(--padding-small);
        color: var(--bg-coal);
        transition: margin-left 0.3s ease-out;
    }

    .light .node {
        color: var(--nav-font);
    }

    .node.disconnected h3 {
        opacity: 25%;
    }

    .node:not(.selected):hover {
        margin-left: 5px;
        cursor: pointer;
    }

    .info {
        display: none;
        font-size: var(--font-size-small);
    }

    .node-list #status {
        display: none;
    }

    .info li {
        margin-top: 0.5rem;
    }

    .info p {
        display: inline;
    }

    .info.config {
        font-size: var(--font-size-xs);
        flex-direction: column;
        display: flex;
        justify-content: center;
        align-items: center;
        grid-row: 3/4;
    }

    /* ============= Selected node ============== */

    .node.selected {
        position: relative;
        margin-left: var(--padding-small);
        border-radius: 10px 0px 0px 10px;
        background-color: var(--bg-coal);
        color: var(--ll-yellow);
        z-index: 5;
    }

    .node h2 {
        font-weight: 200;
    }

    .node.selected #name {
        word-break: break-all;
    }

    .node.selected.disconnected h3 {
        opacity: 100%;
    }

    .node.selected .info {
        margin-top: var(--padding-small);
        display: block;
    }

    .node.selected #top-curve {
        position: relative;
    }

    .node.selected #top-curve::before {
        position: absolute;
        content: "";
        left: var(--beforeLeft);
        bottom: 15px;
        width: 30px;
        height: 30px;
        background-color: var(--bg-coal);
    }

    .node.selected #top-curve::after {
        content: "";
        position: absolute;
        left: var(--afterLeft);
        bottom: 15px;
        width: 60px;
        height: 60px;
        background-color: var(--bg-grey);
        border-radius: 100%;
    }

    .node.selected #bottom-curve {
        position: relative;
    }

    .node.selected #bottom-curve::before {
        content: "";
        position: absolute;
        left: var(--beforeLeft);
        top: 15px;
        width: 30px;
        height: 30px;
        background-color: var(--bg-coal);
    }

    .node.selected #bottom-curve::after {
        content: "";
        position: absolute;
        left: var(--afterLeft);
        top: 15px;
        width: 60px;
        height: 60px;
        border-radius: 100%;
        background-color: var(--bg-grey);
    }

    .node.selected #status{
        float: left;
        margin-top: 9px;
        margin-right: 5px;
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background-color: var(--bg-status-green);
    }
    
    .node.disconnected #status{
        background-color: red;
    }

    .node form {
        cursor: default;
        /* margin-top: -20px; */
        min-width: 80px;
        height: 100%;
    }

    .node .form-label {
        font-size: var(--font-size-small);
    }

    input, select {
        color: (var(--ll-yellow));
        border: 2px solid var(--ll-yellow);
        border-radius: 5px;
        background-color: var(--bg-input-grey);
        z-index: 2000;
    }

    form input {
        margin-top: calc(var(--padding-small)/3);
        margin-bottom: calc(var(--padding-small)/2);
        width: 90%;
        min-width: 80px;
    }

    #submit-wrapper {
        margin-top: var(--padding-small);
        text-align: center;
    }

    #submit-wrapper input {
        cursor: pointer;
        margin-top: 0;
        width: 90px;
        border: none;
    }

    #submit-wrapper input:hover {
        background-color: var(--bg-grey-focus);
    }

    #submit-wrapper input:active {
        background-color: var(--bg-grey-pressed);
    }

    input::placeholder {
        color: var(--ll-yellow);
        opacity: 70%;
    }

    input.illegal {
        background-color: var(--bg-error-red);
    }

    /* ============= Center configuration ============== */

    #main-config {
        display: grid;
        grid-column: 2/3;
        grid-row: 2/3;
        grid-template-columns: calc(40px - var(--padding-medium)) clamp(60px, 10vw, 100px) calc(3*var(--padding-medium)) repeat(6,2fr); 
        grid-template-rows: subgrid;
        margin: var(--padding-large) var(--padding-small) 0;
        transition: opacity 500ms;
        font-family: var(--font-regular);
        min-height: 520px;
    }

    body.loading #main-config {
        opacity: 50%;
    }

    body.loading #main-config * {
        cursor: progress !important;
    }

    .range {
        background-color: var(--bg-input-grey);
    }

    .card {
        background-color: var(--bg-card-grey);
        border-radius: 25px;
        box-shadow: 0px 10px 15px 2px rgba(0,0,0,0.5);
    }

    #universe-container {
        position: relative;
        display: grid;
        grid-column: 2/3;
        grid-row: 1/7;
        grid-template-rows: subgrid;
        grid-template-columns: subgrid;
        border-radius: 0px 12px 12px 12px;
        color: var(--ll-yellow);
        box-shadow: 0px 10px 15px 2px rgba(0,0,0,0.5);
    }


    .light #universe-container {
        box-shadow: 5px 10px 15px rgba(179, 179, 179, 0.5);
    }
    
    #universe-container:before {
        top: -15px;
        position: absolute;
        justify-self: center;
        content: "";
        display: inline-block;
        width: 70%;
        height: 20px;
        background-color: var(--bg-dmx-box);
        border-radius: 5px;
        z-index: -1;
    }

    #universe-container:after {
        top: -50px;
        position: absolute;
        justify-self: center;
        content: "";
        display: inline-block;
        width: 40%;
        height: 50px;
        background-color: var(--ll-yellow);
        border-radius: 5px;
        z-index: -4;
        box-shadow: 5px 0px 15px 2px rgba(0,0,0,0.5) inset;
    }

    .light #universe-container:after {
        background-color: var(--ll-mustard);
    }

    #universes {
        display: grid;
        grid-column: 2/3;
        grid-row: 1/7;
        grid-template-rows: subgrid;
        grid-template-columns: subgrid;
        position: relative;
    }

    #universe-container #tab {
        display: inline-block;
        position: absolute;
        width: 51px;
        margin-left: -46px;
        top: 18.4px;
        content: "Universes";
        transform: rotate(-90deg);
        font-size: var(--font-size-small);
        padding: 7px;
        border-radius: 12px 12px 0px 0px;
        box-shadow: none;
    }

    #universes li {
        align-self: center;
        position: relative;
        text-align: center;
        margin: 5px;
        padding: 8px 0;
        font-size: clamp(var(--font-size-small), 2vw, var(--font-size-medium)); 
        border-radius: 10px;
        /* z-index: 2; */
        box-shadow: 0px 5px 15px 2px rgba(0,0,0,0.5);
    }

    .light #universes li {
        box-shadow: 0px 5px 15px 2px rgba(171, 171, 171, 0.5);
    }

    #universes li span {
        font-size: var(--font-size-small);
        position: absolute;
        padding: 5px;
        top: 60%;
        left: 75%;
        border-radius: 10px;
        z-index: 1;
    }

    #universes li.illegal, #universes li.illegal span, #universes li.illegal input:nth-of-type(1) {
        background-color: var(--bg-error-red);
    }

    #universes li input {
        width: clamp(70px, 9vw, 90px);
        position: relative;
        font-size: clamp(var(--font-size-small), 2vw, var(--font-size-medium)); 
        text-align: center;
    }

    #universes li input:first-child {
        position: relative;
        z-index: 999 !important;
    }

    #universes li input:last-child {
        position: absolute;
        width: 55px;
        /* height: 70%; */
        top: 95%;
        left: 60%;
        font-size: var(--font-size-small);
        /* z-index: -1000 !important; */
    }

    #universe-filter-container {
        padding-top: 10px;
        grid-row: 8;
        z-index: 10;
        width: 90%;
        margin: 0px auto 0px auto;
    }

    #universe-filter {
        display: flex;
        flex-direction: row;
        justify-content: space-around;
    }

    #universe-filter h3 {
        display: flex;
        padding-top: 3px;
        justify-content: center;
    }

    #accolades {
        display: grid;
        grid-column: 3/10;
        grid-row: 1/11;
        grid-template-columns: subgrid;
        grid-template-rows: subgrid;
        overflow-x: clip;
    }

    #accolades div {
        height: 104%;
        display: grid;
        grid-template-columns: subgrid;
        margin-bottom: -2.65px;
    }

    #accolades svg {
        height: 104%;
    }

    .accolade {
        position: relative; 
        grid-column: 1/8; 
        z-index: -10;
    }

    .accolade .info {
        display: block;
        fill: var(--ll-yellow);
        /* font-size: var(--font-size-xs); */
    }


    #fieldbusses{
        position: relative;
        display: grid;
        grid-template-rows: subgrid;
        grid-template-columns: subgrid;
        grid-row: 1/8;
        grid-column: 4/10;
    }
    
    .fieldbus.card {
        display: grid;
        grid-row: 1/8;
        grid-template-rows: subgrid;
        justify-self: end;
        width: 70%;
        max-width: 125px;
        min-width: 50px;
        color: var(--ll-yellow);
    }

    
    .address.range{
        position: relative;
        justify-self: center;
        grid-row: 1/7;
        width: 92%;
        border-radius: 25px;
        box-shadow: 0px -10px 35px 3px var(--bg-coal) inset;
        outline: 3px solid var(--bg-coal);
        outline-offset: -2px;
    }

    .light .address.range {
        box-shadow: 0px -10px 35px 3px rgb(237, 230, 219) inset;
    }

    .address.range h1, .fieldbus-name {
        position: absolute;
        left: 50%;
        width: 0;
        transform: rotate(-90deg);
        color: var(--bg-card-grey);
        font-family: var(--font-nav-title);
        font-size: 3rem;
        white-space: nowrap;
        opacity: 50%;
    }

    .light .address.range h1 {
        color: rgb(177, 177, 177);
    }

    .address.range div.patch {
        position: relative;
        background: var(--bg-coal);
        border-radius: 15px;
        outline: 3px solid var(--ll-yellow);
        outline-offset: -2px;
    }

    .light .address.range div.patch {
        background: rgb(255, 247, 199);
    }

    .draggable {
        cursor: move;
    }

    .address.range div.patch.top {
        background: linear-gradient(0deg, var(--bg-coal) 70%, var(--ll-mustard) 100%);
        transition: color 2s;
    }

    .address.range div.patch.mid {
        background: linear-gradient(0deg, var(--bg-coal) 0%, var(--ll-mustard) 50%, var(--bg-coal) 100%);
    }

    .address.range div.patch.bottom {
        background: linear-gradient(0deg, var(--ll-mustard) 0%, var(--bg-coal) 30%);
    }

    .address.range div.top-handle {
        cursor: n-resize;
        position: absolute;
        top: -16px;
        display: flex;
        justify-content: center;
        height: 20px;
        width: 100%; 
    }

    .address.range div.top-handle.light, .address.range div.bottom-handle.light {
        background-color: transparent;
        outline: transparent;
    }

    .address.range div.top-handle:after {
        content: "";
        width: 17%;
        height: 7px;
        position: relative;
        bottom: -9px;
        background-color: var(--ll-yellow);
        border-radius: 5px 5px 0px 0px;
    }

    .address.range div.bottom-handle {
        cursor: n-resize;
        position: absolute;
        bottom: -19.5px;
        display: flex;
        justify-content: center;
        height: 20px;
        width: 100%; 
    }

    .address.range div.bottom-handle:after {
        content: "";
        width: 17%;
        height: 7px;
        background-color: var(--ll-yellow);
        border-radius: 0px 0px 5px 5px;
    }

    .address-container {
        height: 100%;
        display: grid;
        grid-template-rows: repeat(3, 1fr);
    }

    .config .address-container {
        grid-template-rows: repeat(2, 1fr);
    }

    .config .address-container.overflow {
        grid-template-rows: 1fr;
    }

    #fieldbusses .patch.config {
        position: relative;
    }

    #fieldbusses h2 {
        height: fit-content;
        padding: 5px 5px 0px 5px;
        font-size: clamp(var(--font-size-xs), 1vw, var(--font-size-small)); 
        text-align: center;
        font-weight: 400;
    }

    #fieldbusses h2.stream {
        align-self: center;
    }

    #fieldbusses h2 input {
        position: absolute;
        left: 20%;
        width: clamp(55px, 4.5vw, 90px);
    }

    #fieldbusses .overflow h2 {
        position: absolute;
        width: 90%;
    }

    #fieldbusses .overflow h2.start{
        cursor: default;
        z-index: 101;
    }

    #fieldbusses .overflow h2.start {
        top: -35px;
    }

    #fieldbusses .overflow h2.configurable.start {
        top: -50px;
    }

    #fieldbusses h2.configurable.start {
        grid-row: 1;
        width: fit-content;
        justify-self: center;
    }

    #fieldbusses h2.configurable.stream {
        align-self: start;
        width: fit-content;
        justify-self: center;
        grid-row: 2;
        padding-top: 0px;
    }

    #fieldbusses .overflow h2.stream {
        grid-row: 1;
        margin-top: -5px;
        align-self: center;
    }

    #fieldbusses .overflow h2.configurable.stream {
        margin-top: -25px;
    }

    #fieldbusses .overflow.extreme h2.stream {
        bottom: -2.75em;
    }

    #fieldbusses .overflow.extreme h2.configurable.stream {
        bottom: -30px;
    }

    .address.range div.light{
        background-color: var(--bg-light-grey);
        outline: 3px solid var(--bg-card-grey);
    }
    
    .address.range div.light div:after{
        background-color: var(--bg-card-grey);
    }

    .fb-protocol.info {
        /* grid-row: 8; */
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        align-items: center;
        font-size: clamp(var(--font-size-xs), 1vw, var(--font-size-small));
    }

    .fb-protocol.info label {
        margin-top: 15px;
    }

    .fb-protocol.info select {
        margin-top: 5px;
        text-align: center;
        width: 90%;
    }

    .fb-protocol #ethernet {
        display: flex;
        justify-content: center;
        width: 70%;
        max-width: 3.5rem;
    }

    .rdm-button {
        z-index: 10000;
        position: relative;
        justify-self: end;
        font-family: 'Courier New', Courier, monospace;
        font-weight: 600;
        line-height: 25px;
        text-align: center;
    }

    .fieldbus .rdm-button {
        bottom: -55px;
        right: -10px;
    }

    #text-config-container {
        z-index: 2000;
        margin-right: var(--padding-large);
        grid-column: 2;
        align-self: end;
    }

    #text-config-container.card {
        min-width: 530px;
        position: relative;
        display: grid;
        grid-template-columns: 2fr 1fr;
        grid-template-rows: 6fr 1fr;
        grid-column: 2/8;
        align-self: inherit;
        color: var(--ll-yellow-font);
        min-width: 620px;
    }

    #text-config, .xml-text-button {
        cursor: pointer;
        font-size: var(--font-size-small);
        height: 50px;
        width: 90px;
        border: 2px solid var(--ll-yellow-font);
        border-radius: 10px;
        border-color: var(--ll-yellow-font);
        color: var(--ll-yellow-font);
    }

    .card #text-config {
        grid-row: 2;
        margin-bottom: var(--padding-medium);
        margin-left: var(--padding-medium);
        align-self: end;
    }

    #xml-text-area {
        display: none;
        resize: none;
        margin: var(--padding-medium) 0 0 var(--padding-medium);
        background-color: var(--bg-coal);
        color: var(--ll-yellow-font);
    }

    p#help-text {
        grid-column: 2;
        grid-row: 1;
        padding: var(--padding-medium);
        display: none;
        
    }

    #push{
        margin: 0 var(--padding-medium) var(--padding-medium) 0;
        align-self: end;
        justify-self: end;
    }

    #upload-container, #download-container {
        position: relative;
        text-decoration: none;
        grid-column: 2;
        grid-row: 1;
        align-self: end;
        left: var(--padding-medium)
    }

    #upload-container {
        padding: 2px;
        height: auto;
        width: 82px;
        height: 42px;
        line-height: 43px;
        text-align: center;
        margin-bottom: 60px;
    }

    #upload {
        display: none;
    }

    .xml-text-button {
        display: none;
    }

    .card #xml-text-area, .card p#help-text, .card .xml-text-button {
        display: inline-block;
    }

    /* ============= RDM-config ============== */

    #rdm-config {
        padding: var(--padding-large) var(--padding-small) 0 var(--padding-large);
        display: grid;
        grid-column: 2/3;
        grid-row: 2/3;
    }

    #rdm-config .card {
        width: fit-content;
        display: grid;
        grid-template-rows: 1fr 100px;
        min-height: calc(515px + 2*var(--padding-large) - var(--banner-height) + 2*var(--padding-small));
    }

    #rdm-table-container {
        min-width: 680px;
        margin-top: var(--padding-large);
        overflow-y: auto;
        overflow-x: auto;
        scrollbar-width: thin;
        scrollbar-color: var(--ll-light-yellow) var(--bg-card-grey);
        -webkit-mask-image: linear-gradient(to bottom, transparent 0, black var(--top-mask-size, 0), black calc(100% - var(--bottom-mask-size, 0)), transparent 100%);
        mask-image: linear-gradient(to bottom, transparent 0, black var(--top-mask-size, 0), black calc(100% - var(--bottom-mask-size, 0)), transparent 100%);
        --top-mask-size: 0px;
        --bottom-mask-size: 0px;
    }

    #rdm-table-container.is-top-overflowing {
      --top-mask-size: 48px !important;
    }

    #rdm-table-container.is-bottom-overflowing {
      --bottom-mask-size: 48px !important;
    }

    #rdm-config .rdm-button {
        grid-row: 2;
        align-self: end;
        bottom: -5px;
        right: -5px;
    }

    #rdm-table {
        border-collapse: separate;
        border-spacing: 0;
        font-family: var(--font-regular);
        color: var(--ll-yellow-font);
        margin: 0 0 var(--padding-large) var(--padding-large);
    }

    /* #rdm-table input {
        width: auto;
    } */

    #rdm-table tr td:first-of-type:hover{
        cursor:pointer;
    }

    #rdm-table tr:nth-child(odd):not(tr:first-child) {
        background-color: var(--bg-table-separator);
    }

    #rdm-table #headerRow {
        height: 2rem;
        font-size: 1.5rem;
        color: var(--ll-light-yellow);
    }

    #rdm-table #headerRow th {
        padding: 1rem;
    }

    /* UUID */
    #rdm-table #headerRow th:nth-child(1) {
        padding: 1rem 5rem;
    }
    /* Values */
    #rdm-table #headerRow th:nth-child(3) {
        padding: 1rem 5rem;
    }

    #rdm-table tr td:nth-child(3) {
        text-align: right;
    }

    #rdm-table td {
        padding:  0.25rem 1rem;
        position: relative;
    }

    #rdm-table td h3, .bikini-container {
        display: inline-block;
    }

    #rdm-table td h3 {
        padding-left: 1rem;
        font-weight: initial;
    }

    .bikini-container {
        position: absolute;
        left: 5px;
    }

    #rdm-table td .bikini-container.closed {
        transform: rotate(-90deg);
    }

    .lamp-container {
        position: absolute;
        height: 30px;
        width: 30px;
        display: inline-block;
        margin-left: 1rem;
        margin-top: -5px;
    }

    .lamp-container svg {
        margin-top: 3px;
        margin-left: 4px;
    }


    #headerRow th {
        background-color: var(--bg-first-row);
    }

    #headerRow th:first-of-type {
        border-top: 0px solid black;
        border-top-left-radius: 50px;
    }

    #rdm-table th:last-of-type {
        border-top-right-radius: 10px;
    }

    #personality-paragraph {
        display: inline-block;
    }

    select:has(+ #personality-paragraph) {
        width: 20%;
        margin-right: .56rem;
    }

    .fieldbus-name {
        padding-left: 2rem;
        grid-row: 2;
        grid-column: 1;
        align-self: center;
        position: unset;
        width: 100%;
        font-size: 5rem;
        color: var(--bg-coal);
        transform: none;
    }


    /* ============= Dynamic resizing ============== */
    
    @media screen and (max-width: 950px) {
        :root {
            --grid-nav-width: 21vw;
        }

        .address-container h3 {
            white-space: inherit;
        }

    }

    @media screen and (max-width: 780px) {
        #title {
            margin-top: 20px;
        } 

        #sidebar h2{
            font-size: 1.5rem;
        }

        nav h2:nth-child(1) {
            margin-top: 15px;
        }
        
        .node {
            font-size: var(--font-size-small);
            padding: calc(var(--padding-small) / 2) 0 calc(var(--padding-small) / 2) calc(var(--padding-small) / 2);
        } 

        .node.selected .info {
            display: none;
        } 

        .node.selected #status {
            margin-top: 6px;
            margin-right: 3px;
            width: 5px;
            height: 5px;
        }

        .node.selected #status.config {
            top: 7px
        }

        .node.selected #top-curve:before{
            bottom: 7.5px;
        }

        .node.selected #top-curve:after {
            bottom: 7.5px;
        }

        .node.selected #bottom-curve:before {
            top: 7px;
        }

        .node.selected #bottom-curve:after {
            top: 7.5px;
        }
    }

    @media screen and (max-width: 641px) {
        body {
            grid-template-columns: 135px 1fr;
        }
    }


</style><script>
    let nodeIp = "http://2.121.17.247"

    const SWITCHPARAMS = ["status", "rxByteCount", "txByteCount", "rxBroadcast", "txBroadcast", "rxUnicast", "txUnicast", "rxMulticast", "txMulticast", "rxPause", "txPause"]
    const ARTNETPARAMS = ["universe", "keep", "framecounter"];
    const FIELDBUSPARAMS = ["codec", "startAddress", "streamLength", "finetuningParams"];

    const REFRESHINTERVAL = 1200000;  

    class Installation {
        #customer;
        #nodes = [];
        #lightMode = false;
        // activeNode and activeNodeElement public property is available

        #maxShownUniverses = 10;
        #minShownUniverses = 4;
        #shownUniverses = 6;

        #rdmCounter = 0;
        #demoNumber = 1;

        // Immediately Invoked Async Function Expression zorgt ervoor dat we de nodes kunnen ophalen en nieuwe
        // object instanties kunnen aanmaken zonder then-chaining of extra async functies te gebruiken 
        // https://itnext.io/1-minute-to-become-a-better-developer-4-aeabd6586396
        constructor(customer){
            return (async () => {
                this.#customer = customer;
                await this.fetchNodes(true);
                // for (let i = 0; i < 1; i++) {
                //     let hexValue = i.toString(16);
                //     if (hexValue.length < 2) {
                //         hexValue = hexValue.padStart(2, '0');
                //     }
                //     this.addDemo(hexValue);
                // }
                // this.#prevNodes.push(this.#nodes);
                
                let demoNode = this.#nodes.find(n => n.mac.slice(0,13) === "7B:A6:80:7F:EC");
                if (!demoNode) this.addDemo(this.#demoNumber.toString(16).padStart(2, "0"));

                if (localStorage.getItem("configuration") === "enabled") {
                    this.config         = true;
                } else this.config      = false;
                this.body               = document.querySelector("body");
                this.configElement      = document.getElementById("main-config");
                this.rdmConfigElement   = document.getElementById("rdm-config");
                this.universesContainer = document.getElementById("universe-container");
                this.accoladesElement   = document.getElementById("accolades");  
                this.fieldbussesElement = document.getElementById("fieldbusses")
                this.textConfigElement  = document.getElementById("text-config-container");
                this.textConfig         = false;
                this.rdmConfig          = false;
                this.handlersSet        = false;
                this.rdm = new Rdm();
                this.fetchConfigInterval ??= setInterval(async () => {
                    await this.refreshPage();
                }, REFRESHINTERVAL);
                return this;
            })();
        }

        get nodes(){
            return this.#nodes;
        }

        get shownUniverses() {
            return this.#shownUniverses;
        }

        get maxShownUniverses() {
            return this.#maxShownUniverses;
        }

        get minShownUniverses() {
            return this.#minShownUniverses;
        }

        get rdmCounter() {
            let prevCount = this.#rdmCounter;
            this.#rdmCounter++;
            if (this.#rdmCounter > 255) this.#rdmCounter = 0;
            return prevCount.toString(16).toUpperCase();
        }

        set rdmCounter(rdc) {
            this.#rdmCounter = rdc;
        }

        set shownUniverses(su) {
            this.#shownUniverses = su;
        }

        changeShownUni(up){
            up? this.#shownUniverses++ : this.#shownUniverses--;
        }

        fetchNodes = async (init) => {
            this.#nodes = [];
            try {
                // production:          const response = await fetch(`${init? "" : "http://" + this.activeNode.ip}/xdev`, {signal: AbortSignal.timeout(2000)});
                // development:         const response = await fetch(`${nodeIp}/xdev`, {signal: AbortSignal.timeout(2000)});
                const response = await fetch(`${init? "" : "http://" + this.activeNode.ip}/xdev`, {signal: AbortSignal.timeout(2000)});
                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                let foundNodes = [];
                let devices = xmlDoc.getElementsByTagName("dev")[0].innerHTML.split(" ");
                let ip, node;
                for (let device of devices) {
                    ip = hexToIP(device);
                    try {
                        node = await new Node(ip, false);    
                    } catch(error) {
                        console.error(`there was an error fetching node with ip ${ip}\n ${error}`)
                        continue;
                    };
                    if (node !== undefined) {
                        node.setStatusInterval();
                        foundNodes.push(node);
                    }
                }
                let prevActiveNode = foundNodes.find(node => node.mac === localStorage.getItem("activeNode"));
                if (init && !localStorage.getItem("activeNode") || !prevActiveNode) {
                    foundNodes[0].active = true;
                    this.activeNode = foundNodes[0];
                    localStorage.setItem("activeNode", this.activeNode.mac);
                } else {
                    this.activeNode = prevActiveNode;
                }
                // COMMENTS
                this.activeNode.clearStatusInterval();
                this.activeNode.setFpsInterval();

                if (init) {
                    this.nodeOrder = foundNodes;
                    this.#nodes = foundNodes;
                } else {
                    this.nodeOrder.forEach((n) => {
                        let newNode = foundNodes.find((fn) => fn.ip === n.ip)
                        if (newNode) this.#nodes.push(newNode);
                    })
                }

            } catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");
                    return [];
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.error("Error fulfilling request: ", error);
                } else {
                    console.error("Failed to fetch Nodes:", error.message);
                }
            }
        }

        addDemo(mac){
            let universes = [];
            let fieldbusses = [];
            for (let i=0; i<10; i++){
                universes.push(new Universe(`inp${i+1}`, i, 512, 0));
            }
            for (let i=0; i<6; i++){
                fieldbusses.push(new Fieldbus(`out${i}`, 2, i == 0? 1 : (i*512)+1, 512, 0));
            }
            let demoNode = new NodeTemplate("127.0.0.1", null, "Demo", `7B:A6:80:7F:EC:${mac}`, {}, "255.255.255.0", universes, fieldbusses, ["Disabled", "Used-by-previous-channel", "DMX-512", "DMX-RDM"], "v3.1", new Configuration(null, true));
            demoNode.configuration.setXmlConfig(demoNode);
            if (demoNode.mac === localStorage.getItem("activeNode")) {
                this.nodes.map((node) => node.active = false);
                demoNode.active = true;
            }
            // demoNode.active = true; // Uncomment this line if there are no fysical nodes connected
            this.#nodes.push(demoNode);           
        }

        updateNav(){
            // before generating the new navigation, detach event listeners to the old node elements first
            let generateNode = (node, lm) => {
                let nodeElement;
                if (!this.config | node.active === false) {
                    nodeElement =   generateDomTree("li", null, {class: "node", id: node.UID}, [
                                        generateDomTree("div", null, {id: "top-curve"}), 
                                        generateDomTree("div", null, {id: "status"}),
                                        generateDomTree("h3", node.name, {id: "name"}),
                                        generateDomTree("ul", null, {class: `info ${lm} configurable`}, [
                                            generateDomTree("li", "IP: ", {class: "IP"}, [generateDomTree("p", node.ip)]),
                                            generateDomTree("li", "Netmask: ", {class: "netMask"}, [generateDomTree("p", node.netmask)]),
                                            generateDomTree("li", "MAC: ", {class: "mac"}, [generateDomTree("p", node.mac)])
                                        ]),
                                        generateDomTree("div", null, {id: "bottom-curve"})
                                    ])
                                    
                    
                } else {
                    nodeElement = generateDomTree("li", null, { class: "node", id: node.UID }, [
                                    generateDomTree("div", null, {id: "top-curve"}),
                                    generateDomTree("div", null, {class: "config", id: "status"}),
                                    generateDomTree("h3", node.name, {id: "name"}),
                                    generateDomTree("form", null, {class: "node-form"}, [
                                        generateDomTree("label", "Name:", {for: "new-name"}),
                                        generateDomTree("br"),
                                        generateDomTree("input", null, {type: "text", id: "new-name", value: node.name}),
                                        generateDomTree("br"),
                                        generateDomTree("label", "IP:", {class: "form-label", for: "new-ip"}),
                                        generateDomTree("br"),
                                                generateDomTree("input", null, {type: "text", id: "new-ip", value: node.ip}),
                                        generateDomTree("br"),
                                        generateDomTree("label", "Netmask:", {class: "form-label", for: "new-mask"}),
                                generateDomTree("br"),
                                        generateDomTree("input", null, {type: "text", id: "new-mask", value: node.netmask}),
                                        generateDomTree("br"),
                                        generateDomTree("div", null, {id: "submit-wrapper" }, [
                                            generateDomTree("input", null, {type: "submit", value: "Push to node"})
                                        ])
                                    ]),
                                    generateDomTree("div", null, {id: "bottom-curve"})
                                ]);
                }
                return nodeElement;
            }
            // Clearing the navigation and inserting new nodes
            let navBar = document.getElementById("node-list");
            let newNodeElement;
            navBar.innerHTML="";
            for (let node of this.#nodes) {
                newNodeElement = generateNode(node, this.lm);
                if (!node.online) newNodeElement.classList.add("disconnected");
                if (node.active) {
                    newNodeElement.classList.add("selected");
                    localStorage.setItem("activeNode", node.mac);
                    this.shownUniverses = this.activeNode.universes.length < this.shownUniverses ? this.activeNode.universes.length : this.shownUniverses; 
                    if (this.config) newNodeElement.children[2].hidden = true;
                }        
                navBar.appendChild(newNodeElement);
            };
            setCurvePosition();
            this.initialiseConfig();
        }
        // initialising the fieldbus containers for the draggable fields, this function gets called after updating the navigation and when the user changes the amount of shown universes
        initialiseConfig() {
            let fieldbussesElement = document.getElementById("fieldbusses");
            fieldbussesElement.innerHTML = '';
            fieldbussesElement.setAttribute('style', `grid-template-columns: repeat(${this.activeNode.fieldbusses.length}, 2fr)` )            
            let fbElement;
            let counter = 1;
            for (const FB of this.activeNode.fieldbusses) {
                fbElement =  generateDomTree("div", null, { id: `fb-${counter}`, class: "fieldbus card" }, [
                                    generateDomTree("div", null, { class: "address range" }, [
                                        generateDomTree("h1", `FIELDBUS ${counter}`),
                                        generateDomTree("div", null, { id: `address-block-${counter}`, class: "patch" }, [
                                            generateDomTree("div", null, { class: "top-handle draggable" }),
                                            generateDomTree("div", null, { class: "address-container draggable" }, [
                                                generateDomTree("h2", "start: ", { class: "draggable start" }, [
                                                    generateDomTree("span")
                                                ]),
                                                generateDomTree("h2", null, { class: "draggable stream" })]),
                                            generateDomTree("div",null, { class: "bottom-handle draggable" })
                                        ])
                                ]), 
                                generateDomTree("div", null, { class: "fb-protocol info" }),
                                generateDomTree("div", "i", {class: "rdm-button e-button", style: "visibility: hidden"}, null)])
                fieldbussesElement.appendChild(fbElement);
                counter++;    
            }

            this.showActiveNode();
        }

        showActiveNode() {
            let main                = document.getElementById("main-config");
            let uniC                = document.querySelector("#universe-container");
            let uni                 = document.getElementById("universes");
            let uniFilter           = document.querySelector("#universe-filter-container");
            let textC               = document.querySelector("#text-config-container");
            let firmwareVersion     = document.querySelector("#firmware span");
            let configVersion       = document.querySelector("#config span");
            
            let activeNodeElement  = document.getElementById(`${this.activeNode.UID}`);  
            let universesElement   = document.getElementById("universes");

            let ePort2 = document.getElementById("eth2");
            if (Object.keys(this.activeNode.switch).length === 0) {
                ePort2.hidden = true;
            } else {
                ePort2.hidden = false;
            }

            const requiredUniverses = this.activeNode.fieldbusses.reduce((maxUniverses, fieldbus) => {
                const endAddress = (fieldbus.startAddress + fieldbus.streamLength) -1;
                const universesForFieldbus = Math.ceil(endAddress / 512);
                return Math.max(maxUniverses, universesForFieldbus);
            }, 0);

            if (installation.shownUniverses < requiredUniverses) {
                installation.shownUniverses = requiredUniverses;
            }

            universesElement.innerHTML = '';
            main.style.gridTemplateRows     = `repeat(${installation.shownUniverses}, 1fr) 25px 75px`; 
            firmwareVersion.innerHTML       = this.activeNode.firmware;

            let counter = 1;
            for (const UNI of this.activeNode.universes) {
                if (counter <= installation.shownUniverses) {
                    let u = document.createElement("li");
                    u.style.padding = "0px"
                    u.classList.add("range");
                    if (this.lm) u.classList.add("light");
                    if (this.config) {
                        // let inputU = document.createElement("input");
                        let inputU = generateDomTree("input", null, {id: `universe-${counter}`, universe: UNI.id, type: "number", value: UNI.universe, min: 1, max: 32468 });
                        let inputK = generateDomTree("input", null, {id: `keep-${counter}`, universe: UNI.id, type: "number", value: UNI.keep, min: 1, max: 512});
                        u.appendChild(inputU);
                        u.appendChild(inputK);
                    } else {
                        u.innerHTML = `${UNI.universe}<span class="range ${this.lm}">${UNI.keep}</span>`
                        u.style.padding = "0.5rem"
                    }
                    universesElement.appendChild(u);
                }        
                counter++;
            }

            uniC.style.gridRow          = `1/${installation.shownUniverses+2}`;
            uni.style.gridRow           = fieldbusses.style.gridRow = `1/${installation.shownUniverses+3}`;
            uniFilter.style.gridRow     = textC.style.gridRow = `${installation.shownUniverses+2}`;
            
            if (!this.textConfig) {
                textC.style.gridRow = `${installation.shownUniverses+2}`;
            } else {
                this.fieldbussesElement.style.gridTemplateColumns = "subgrid";
                this.fieldbussesElement.style.gridColumn = "8/10"
            }

            counter = 1;
            let fieldbusElement, addressRange, addressBlock, startElement, streamElement, codecElement;
            let start, newStartElement, stream, newStreamElement;
            let rj45, labelElement, selectElement;

            for (const FB of this.activeNode.fieldbusses) {
                fieldbusElement  = document.getElementById(`fb-${counter}`);
                addressRange     = document.querySelector(`#fb-${counter} .address.range`);
                addressBlock     = document.querySelector(`#address-block-${counter}`);
                startElement     = document.querySelector(`#fb-${counter} .address-container h2.start`);
                streamElement    = document.querySelector(`#fb-${counter} .address-container h2.stream`);
                codecElement     = document.querySelector(`#fb-${counter} .fb-protocol`);
                // fb.patch = document.querySelector(".patch");

                if (FB.codec === 0) {
                    addressBlock.hidden = true;
                } else addressBlock.hidden = false;

                if (this.activeNode.codecs[FB.codec].toLowerCase().includes("rdm")) {
                    fieldbusElement.querySelector(".rdm-button").style.visibility = "visible";
                } else {
                    fieldbusElement.querySelector(".rdm-button").style.visibility = "hidden";
                }

                if (this.textConfig) {
                    fieldbusElement.style.position = "relative";
                    fieldbusElement.style.zIndex = `${1000 + this.activeNode.fieldbusses.length-(counter-1)}`;
                    fieldbusElement.style.gridColumn = "1";
                    fieldbusElement.style.justifySelf = "center";
                    fieldbusElement.style.left = `${(counter-2)*(this.fieldbussesElement.clientWidth/7.5)}px`;
                    fieldbusElement.style.marginRight = `${10/this.activeNode.fieldbusses.length}px`;
                }

                // setting all the gridRows
                fieldbusElement.style.gridRow = `1/${installation.shownUniverses+3}`
                if (FB.codec === 1) {
                    fieldbusElement.style.gridRow = `${installation.shownUniverses+1}/${installation.shownUniverses+3}`
                    FB.addressRange.hidden = true;
                    // adding arrow pointing to the previous channel
                    // check if the arrow hasn't been added before
                    if (!document.getElementById("arrowSvg")) {
                        const arrowTemplate = document.getElementById("arrow-template");

                        const clone = arrowTemplate.content.cloneNode(true);
                        const svg = clone.querySelector("svg");
                        
                        let arrow = document.createElement("div");
                        arrow.id = "arrowSvg"
                        arrow.appendChild(svg);
                        FB.fieldbusElement.appendChild(arrow);
                        arrow.style.width = "55%"
                        arrow.style.alignSelf = "end";
                        arrow.style.justifySelf = "center"
                        arrow.style.gridColumn = "1";
                        arrow.style.gridRow = "1";

                    }
                } else {
                    let arrow = document.querySelector(`#fb-${counter} #arrowSvg`);
                    if (arrow) {
                        arrow.parentNode.removeChild(arrow);
                    }
                    fieldbusElement.style.gridRow = `1/${installation.shownUniverses+3}`
                    addressRange.hidden = false;
                }

                addressRange.style.gridRow   = `1/${installation.shownUniverses+1}`;
                codecElement.style.gridRow   = `${installation.shownUniverses+1}/${installation.shownUniverses +3}`;

                if (this.config) {
                    addressBlock.classList.add("config");
                    newStartElement    =   generateDomTree("h2", null, {class: "configurable start"}, [
                                            generateDomTree("label", "start: ", {for: `startAddress-fb${counter}`, class: "draggable"}, [
                                                generateDomTree("br"),
                                                generateDomTree("input", null, {id: `startAddress-fb${counter}`, fieldbus: FB.id, type: "number", min: "1", max: `${(this.shownUniverses*512)-1}`, value: `${FB.startAddress}`}, null)])]);
                    newStreamElement   =   generateDomTree("h2", null, {class: "configurable stream"}, [
                                            generateDomTree("label", "length: ", {for: `streamLength-fb${counter}`, class: "draggable"}, [
                                                generateDomTree("br"),
                                                generateDomTree("input", null, {id: `streamLength-fb${counter}`, fieldbus: FB.id, type: "number", min: "1", max: `${(this.shownUniverses*512)-1}`, value: `${FB.streamLength}`}, null)])]);
                } else {
                    addressBlock.classList.remove("config");
                    newStartElement    =   generateDomTree("h2", "start: ", { class: "draggable non-configurable start" }, [
                                            generateDomTree("span", FB.startAddress)]);
                    newStreamElement   =   generateDomTree("h2", "length: ", { class: "draggable non-configurable stream" }, [
                                            generateDomTree("span", FB.streamLength, {class: "draggable"})]);
                }

                FB.addressHeight = addressRange.getBoundingClientRect()["height"]*(FB.streamLength/(512*installation.shownUniverses));

                startElement.replaceWith(newStartElement);
                streamElement.replaceWith(newStreamElement);

                // Updating all the fb.addressblock heights and startpositions
                // Height = streamlength, top = startaddres
                start   = String((FB.startAddress/(512*installation.shownUniverses))*100)+"%";
                stream  = String((FB.streamLength/(512*installation.shownUniverses))*100)+"%";
                
                addressBlock.style.height = stream;
                addressBlock.style.top = start;
                
                startElement    = document.querySelector(`#fb-${counter} .address-container h2.start`);
                streamElement   = document.querySelector(`#fb-${counter} .address-container h2.stream`);
                
                if (FB.codec !== 0 && FB.codec !== 1) checkOverflow(addressBlock, !this.config, FB.addressHeight);

                const ACTIVECODEC = this.activeNode.codecs[FB.codec].split(" ")[0];

                labelElement = generateDomTree("label", null,  {for: `fb-${counter}-codec`});
                    labelElement.innerHTML = "Codec: "
                    const selectElement = generateDomTree("select", null, {name: "codec", id: `fb-${counter}-codec`});
                    let option, content;
                    for (let i=0; i<this.activeNode.codecs.length; i++) {
                        option = document.createElement("option", {value: `${this.activeNode.codecs[i].split(" ")[0]}`});
                        content = document.createTextNode(`${this.activeNode.codecs[i].split(" ")[0]}`);
                        if (this.activeNode.codecs[i].split(" ")[0] === ACTIVECODEC) {
                            option.selected = true;
                        }
                        option.appendChild(content);
                        selectElement.appendChild(option);
                    }
                labelElement.appendChild(selectElement);
                
                rj45 = generateDomTree("div", null, { id: "ethernet" })
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.setAttribute("viewBox", "0 0 512 490.43");
                svg.setAttribute("width", "60%")
                
                const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
                use.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#ethernet-port");

                svg.appendChild(use);
                rj45.appendChild(svg)
        
                codecElement.innerHTML = '';
                if (this.config) {
                    codecElement.appendChild(labelElement);
                } else {
                    let h2 = generateDomTree("h2", "Codec: ");
                    let h3 = generateDomTree("h3", ACTIVECODEC);
                    codecElement.appendChild(h2);
                    codecElement.appendChild(h3);
                }
                if (FB.codec !== 1) codecElement.appendChild(rj45);
                
                counter++;
            };

            this.accoladesElement.innerHTML = "";
       
            counter = 1;
            const braceColor = this.lm ? "rgb(77,77,77)" : "#FFF200";
            const template = document.getElementById("brace-template");
            const className = this.lm;
            let vb, clone, svg;

            for (const UNI of this.activeNode.universes) {
                if (counter <= installation.shownUniverses) {
                    // Clone the template content
                    clone = template.content.cloneNode(true);
                    svg = clone.querySelector("svg");
                    vb = Math.round(55 - this.shownUniverses * Math.pow(2, 0.8));
                    svg.setAttribute("viewBox", `${vb} 0 2000 72`);
                
                    // Replace color placeholders
                    svg.innerHTML = svg.innerHTML
                        .replaceAll("__COLOR__", braceColor)
                        .replace("__CLASS__", className)
                        .replace("__FS__", this.shownUniverses * Math.pow(2, 0.8)+"px");
  
                    // const a = document.createElement("div");
                    // a.style.marginLeft = `${this.#accMargin}px`;
                    svg.id = `accolade-${counter}`;
                    svg.classList.add("accolade");
                    // a.appendChild(svg);
                    
                    this.accoladesElement.appendChild(svg);
                }
                counter++;
            };
            
            // mark double universes in red
            this.checkDoubleUnis();

            if (this.textConfig) {
                    this.textConfigElement.style.gridRow = `1/${this.shownUniverses+3}`
                }
        
            // if (this.config) {
            //     // setting the event listener for the form
            //     let forms = document.getElementsByClassName("node-form");
            //     let form = activeNodeElement.children[3];
            //     Array.from(forms).forEach((form) => {
            //         form.removeEventListener("submit", this.activeNode.processForm);
            //     })
            //     form.addEventListener("submit", this.activeNode.processForm);
            // }
            
            if (this.body.classList.contains("loading")) {
                this.body.classList.remove("loading");
            }

            if (this.activeNode.online) {
                this.addEventHandlers();
                this.body.classList.remove("loading");               
            } else {
                this.removeEventHandlers();
                this.body.classList.add("loading");
            }
        }

        checkDoubleUnis() {
            let unis = document.querySelectorAll("#universes li");
            let uni;
            let keep;
            
            unis.forEach((uni) => uni.classList.remove("illegal"));
            
            let uniArr = [];
            for (const uni of unis) {
                this.config? uniArr.push(uni.children[0].value) : uniArr.push((uni.innerHTML).split("<")[0]);
            }
            let dupObj = {};
            uniArr.forEach((element, index, array) => {
                dupObj[element] = Array.from(array.entries()).reduce((indices, [i, e]) => {
                    if (element === e) {
                        indices.push(i);
                    }
                    return indices;
                }, []);
            });
            
            const setDuplicateError = (i) => {
                let uni = document.querySelector(`#universes li:nth-child(${i+1})`);
                uni.classList.add("illegal")
            }

            for (const duplicates of Object.values(dupObj)){
                if (duplicates.length === 2) {
                    setDuplicateError(duplicates[1])
                }
                else if (duplicates.length > 2) {
                    duplicates.shift();
                    for (const i in duplicates) {
                        setDuplicateError(duplicates[i])
                    }
                }           
            }
        }

        eventInit = () => {
            window.onresize = (e) => {
                // calculating the height of the accolades
                setCurvePosition();
         
                if (this.textConfig) {
                    let fieldbusContainers = document.querySelectorAll(".fieldbus");
                    for (let i=0; i<fieldbusContainers.length; i++) {
                        fieldbusContainers[i].style.left = `${(i-1)*(this.fieldbussesElement.clientWidth/7.5)}px`;  
                    }
                }

                this.activeNode.fieldbusses.forEach((fb) => {
                    if (fb.addressRange) {
                        fb.addressHeight = fb.addressRange.getBoundingClientRect()["height"]*(fb.streamLength/(512*installation.shownUniverses));
                        if (fb.codec !== 0 && fb.codec !== 1) checkOverflow(fb.addressBlock, !this.config, fb.addressHeight);
                    }
                })
            }
            
            const dmSwitch          = document.querySelector("#dark-mode-switch input");
            const configSwitch      = document.getElementById("edit-switch");
            const savedDarkMode     = localStorage.getItem("darkMode");

            if (this.config) {
                configSwitch.checked    = true;
            } else configSwitch.checked = false;

            if (savedDarkMode === "enabled") {
                dmSwitch.checked    = true;
            } else dmSwitch.checked = false;

            this.switchDarkMode(dmSwitch);
            dmSwitch.addEventListener("change", (e) => {
                this.switchDarkMode(dmSwitch)
            });

            const uniButtons    = document.querySelectorAll("#universe-filter .e-button");
            const accolades     = document.querySelectorAll("#accolades div");
            for (const button of uniButtons) {
                button.addEventListener("click", () => {
                    if (button.id === "increment") {
                        if (this.shownUniverses < this.activeNode.universes.length) {
                            this.changeShownUni(true);
                        }
                    } else if (button.id === "decrement") {
                        if (this.shownUniverses > this.minShownUniverses) {
                            let overLap = false;
                            for (const fb of this.activeNode.fieldbusses) {
                                if ((fb.startAddress + fb.streamLength)-1 > (this.shownUniverses-1) * 512) {
                                    overLap = true;
                                }
                            }
                            if (!overLap) {
                                this.changeShownUni(false);
                            }        
                        }
                    }
                    this.initialiseConfig();
                })
            }

            let editButton = document.getElementById("edit-switch");
            editButton.addEventListener("change", (e) => {
                const checkBox = document.getElementById("edit-switch");
                if (checkBox.checked) {
                    this.config = true;
                    localStorage.setItem("configuration", "enabled");
                    this.updateNav();
                } else {
                    this.config = false;
                    localStorage.setItem("configuration", "disabled");
                    this.updateNav();
                }

                if (this.rdmConfig) {
                    this.rdmTable.toggleInput();
                }
                
                if (this.textConfig) {
                    this.textConfigElement.style.gridRow = `1/${this.shownUniverses+3}`
                }
                setCurvePosition();    
            })

            this.textConfigButton = document.getElementById("text-config");
            this.textConfigButton.addEventListener("click", this.switchTextConfig);
            document.querySelector("#rdm-config .rdm-button").addEventListener(("click"), this.toggleRdmConfig);
            // navigation
            document.getElementById("sidebar").addEventListener(("click"), this.handleNavClick);
            document.getElementById("sidebar").addEventListener(("submit"), this.activeNode.processForm)
            this.addEventHandlers();

        }
        
        // TODO add touch input
        addEventHandlers() {
            if (!this.handlersSet) {
                this.configElement.addEventListener("click", this.handleFbEvent);
                this.configElement.addEventListener("mousedown", this.handleFbEvent);
                this.configElement.addEventListener("change", this.handleFbEvent);
                this.configElement.addEventListener("input", this.handleFbEvent);
                this.configElement.addEventListener("focusin", this.handleFbEvent);
                this.configElement.addEventListener("focusout", this.handleFbEvent);
                this.configElement.addEventListener("keydown", this.handleFbEvent);
                this.configElement.addEventListener("mousemove", this.handleFbEvent);
                this.configElement.addEventListener("mouseup", this.handleFbEvent);
                this.handlersSet = !this.handlersSet;
            }
        }

        removeEventHandlers() {
            if (this.handlersSet) {
                this.configElement.removeEventListener("click", this.handleFbEvent);
                this.configElement.removeEventListener("mousedown", this.handleFbEvent);
                this.configElement.removeEventListener("change", this.handleFbEvent);
                this.configElement.removeEventListener("input", this.handleFbEvent);
                this.configElement.removeEventListener("focusin", this.handleFbEvent);
                this.configElement.removeEventListener("focusout", this.handleFbEvent);
                this.configElement.removeEventListener("keydown", this.handleFbEvent);
                this.configElement.removeEventListener("mousemove", this.handleFbEvent);
                this.configElement.removeEventListener("mouseup", this.handleFbEvent);
                this.handlersSet = !this.handlersSet;
            }
        }

        switchTextConfig = (e) => {
            this.textConfig = !this.textConfig;
            let fieldbusContainers = document.querySelectorAll(".fieldbus");
            if (this.textConfig) {
                clearInterval(installation.fetchConfigInterval);
                installation.fetchConfigInterval = undefined;
                this.universesContainer.style.display = "none";
                this.accoladesElement.style.display = "none";
                this.fieldbussesElement.style.gridTemplateColumns = "subgrid";
                this.fieldbussesElement.style.gridColumn = "8/10";
                for (let i=0; i < this.activeNode.fieldbusses.length; i++) {
                    fieldbusContainers[i].style.position = "relative";
                    fieldbusContainers[i].style.zIndex = `${1000 + this.activeNode.fieldbusses.length-i}`;
                    fieldbusContainers[i].style.gridColumn = "1";
                    fieldbusContainers[i].style.justifySelf = "center";
                    fieldbusContainers[i].style.left = `${(i-1)*(this.fieldbussesElement.clientWidth/7.5)}px`;
                    fieldbusContainers[i].style.marginRight = `${10/this.activeNode.fieldbusses.length}px`;
                }
                this.textConfigElement.classList.add("card");
                this.textConfigElement.style.gridRow = `1/${installation.shownUniverses+3}`
                this.textArea = document.getElementById("xml-text-area");
                if (isDemo(this.activeNode.mac)) {
                    this.activeNode.configuration.setXmlConfig(this.activeNode);
                    this.textArea.value = this.activeNode.configuration.textConfig;
                } 
                else {
                    this.textArea.value = this.activeNode.configuration.textConfig;
                }          
                this.textArea.hidden = false;

            } else {
                this.universesContainer.style.display = "grid";
                this.accoladesElement.style.display = "grid";
                this.textConfigElement.classList.remove("card");
                this.fieldbussesElement.setAttribute('style', `grid-template-columns: repeat(${this.activeNode.fieldbusses.length}, 2fr)` )
                this.fieldbussesElement.style.gridRow = `1/${this.shownUniverses+3}`
                for (let i=0; i < this.activeNode.fieldbusses.length; i++) {
                    fieldbusContainers[i].style.position = "relative";
                    fieldbusContainers[i].style.zIndex = `${this.activeNode.fieldbusses.length-i}`;
                    fieldbusContainers[i].style.gridColumn = `${i + 1}`;
                    fieldbusContainers[i].style.left = "0px";
                    fieldbusContainers[i].style.justifySelf = "end";
                    fieldbusContainers[i].style.marginRight = "0px";
                }
                let accDiv = document.querySelector(".accolade");
                let accHeight = accDiv.getBoundingClientRect()["height"];
                for(let i = 0; i < this.accoladesElement.children.length; i++) {
                    this.accoladesElement.children[i].children[0].style.height = accHeight;
                }
                installation.fetchConfigInterval ??= setInterval(async () => {
                    await this.refreshPage();
                }, REFRESHINTERVAL);
            }

            // adding event listeners for the buttons
            this.textConfigElement.addEventListener("click", this.handleTextConfig);
            this.fileInput = document.getElementById("upload");
            this.fileInput.addEventListener("change", this.handleUpload);
            this.textArea.addEventListener("input", this.handleTextInput);
        }

        handleUpload = (e) => {
            const conf = this.fileInput.files[0];
            const reader = new FileReader();

            reader.onload = () => {
                const result = reader.result;
                this.textArea.value = result;
            }

            reader.onerror = function () {
                console.error('error reading the file');
            }

            reader.readAsText(conf, 'utf-8');
        }

        handleTextConfig = (e) => {
            switch(e.target.id) {
                case "download":
                    console.log("downloading");
                    const fileURL = URL.createObjectURL(this.activeNode.configuration.textConfigBlob);
                    e.target.parentElement.href = fileURL;
                    break;
                case "push":
                    if (!isDemo(this.activeNode.mac)) {
                        this.activeNode.configuration.postXmlConfig(this.textArea.value, true);
                    } else {
                        console.log("generating config object");
                        this.activeNode.configuration.generateConfigObject(this.textArea.value);
                        this.activeNode.initialiseNode(true);
                        this.updateNav();
                        // this.navSwitcher();
                    }
                    break;
                default:
                    break;
            }
        }

        handleTextInput = (e) => {
            this.activeNode.configuration.generateTextBlob(e.target.value);
        }

        handleFbEvent = (e) => {
            e.stopPropagation();
            if (e.type === "click" && e.target.classList.contains("rdm-button")) {
                this.toggleRdmConfig(e);
            }
            if (e.target.classList.contains("e-button") 
                                || e.target.tagName === "OPTION"
                                || e.target.id === "edit-switch" 
                                || this.rdmConfig) {
                return;
            }

            if (e.key === "Enter") {
                e.preventDefault();
                let elements = document.querySelectorAll("input");
                let illegalChecker = () => {
                    for (const element of elements) {
                        if (document.activeElement === element) {
                            return element.classList.contains("illegal") ? true : false;
                        }
                    }
                }

                if (!illegalChecker()) {
                    let param = e.target.id.split("-")[0];
                    if (this.target && this.target[param] !== parseInt(e.target.value)) {
                        this.target[param] = parseInt(e.target.value);
                        this.activeNode.configuration.handleInputChange(this.target);
                    }
                    this.inputSelection = false;
                }
            }

            if (e.type === "focusin" && (e.target.id !== "text-config" 
                                            && e.target.closest("div").id !== "text-config-container"
                                            && e.target !== undefined)
                                            && e.target.name !== "codec") {
                clearInterval(installation.fetchConfigInterval);;
                e.target.id.split('-')[1][0] === "f" ?
                    this.target = this.activeNode.fieldbusses.find((fb) => fb.id === e.target.getAttribute("fieldbus")) : 
                    this.target = this.activeNode.universes.find((uni) => uni.id === e.target.getAttribute("universe"));
                this.inputSelection = true;
                e.target.select();
            }
            // ======================== UNIVERSES =======================

            if (e.type === "input" && (e.target.id.split("-")[0] === "universe" || e.target.id.split("-")[0] === "keep")) {
                if (!this.target) this.target = this.activeNode.universes.find((uni) => uni.id === e.target.getAttribute("universe"));
                let min, max;
                if (e.target.id.split("-")[0] === "universe") {
                    min = 1, max = 32767;
                } else min = 500, max = 512;
                let inputValue = e.target.value;
                if (inputValue < min || inputValue > max) {
                    e.target.classList.add("illegal");
                }
                else {
                    e.target.classList.remove("illegal");
                }                    
                installation.checkDoubleUnis();
            }
            
            if (e.type === "focusout") {
                if (e.target.classList.contains("illegal")) {
                    e.target.value = this.activeNode.universes.find((uni) => uni.id === e.target.getAttribute("universe"))[e.target.id];
                    e.target.classList.remove("illegal");
                } else {
                    if (this.target && !e.target.classList.contains("illegal")) {
                        let param = e.target.id.split("-")[0];
                        if (this.target[param] !== parseInt(e.target.value)) {
                            this.target[param] = parseInt(e.target.value);
                            this.activeNode.configuration.handleInputChange(this.target);
                        }                            
                    }
                    this.inputSelection = false;
                }
            }
            
            if (e.type === "change" && e.target.id.split("-")[2] !== "codec") {
                e.target.select();
                // if (e.target.classList.contains("illegal")) {
                //     return;
                // }
                // let param = e.target.id.split("-")[0];
                // this.target[param] = parseInt(e.target.value);
                return;
            }
            // ======================== FIELDBUSSES =======================
            if ((e.target.classList.contains("draggable") || e.target.tagName === "SELECT" && e.type === "change" || e.target.tagName === "INPUT" && e.target.hasAttribute("fieldbus")) && e.type !== "mousemove") {
                this.targetFb = e.target.closest(".fieldbus").id.slice(-1)-1;
                this.targetFb = this.activeNode.fieldbusses.find((fb) => fb.id === `out${this.targetFb}`);
                if (e.type === "input") {
                    if (!this.target) this.target = this.activeNode.fieldbusses.find((fb) => fb.id === e.target.getAttribute("fieldbus"));
                    let inputStream = e.target.closest(".address-container").querySelector(".stream input").value;
                    let inputStart  = e.target.closest(".address-container").querySelector(".start input").value;
                    let min = 1, max = e.target.id.split("-")[0] === "startAddress" ? installation.shownUniverses*512 - inputStream : installation.shownUniverses*512 - inputStart +1;
                    let inputValue = e.target.value;
                    if (inputValue < min || inputValue > max) {
                        e.target.classList.add("illegal");
                    }
                    else {
                        e.target.classList.remove("illegal");
                    }
                }
                if (e.type === "focusout") {
                    if (e.target.classList.contains("illegal")) {
                        e.target.value = this.activeNode.fieldbusses.find((fb) => fb.id === e.target.getAttribute("fieldbus"))[e.target.id];
                        e.target.classList.remove("illegal");
                    } else {
                        this.activeNode.configuration.handleInputChange(this.target);
                    }
                    this.inputSelection = false;
                    this.targetFb = undefined;
                    return
                }
                if (e.type === "change" && e.target.id.split("-")[2] !== "codec") {
                    e.target.select();
                    if (e.target.classList.contains("illegal")) {
                        return;
                    }
                    let param = e.target.id.split("-")[1];
                    this.target[param] = parseInt(e.target.value);
                    return;
                }
            }            

            if (this.targetFb !== undefined && !this.inputSelection) {
                switch(e.type) {
                    case "mousedown":
                        this.targetFb.setStart(e);
                        break;
                    case "change":
                        this.targetFb.handleCodecChange(e);
                        this.targetFb = undefined;
                        break;
                    case "mousemove":
                        this.targetFb.setMove(e);
                        break;
                    case "mouseup":
                        this.targetFb.updateValues(e);
                        this.targetFb = undefined;
                        break;
                    default:
                        break;
                }
            }
        }

        handleNavClick = (e) => {
            if (e.target.classList.contains("scrollContainer")  || e.target.closest("div").id === "title" 
                                                                || e.target.closest("div").classList.contains("info")
                                                                || e.target.id === "node-list") {
                return
            }
            else if ((e.target.classList.contains("node") || e.target.closest("li").classList.contains("node")) && !e.target.closest("li").classList.contains("selected")) {
                let nodeElement = e.target.closest("li");
                // resetting the nodes to their inactive state and resetting their intervals
                this.#nodes.map((node) => {
                    node.active = false;  
                });

                if (this.rdmConfig) {
                    this.rdmConfigElement.style.visibility = "hidden";
                    this.configElement.style.display = "grid";
                    this.rdmConfig = false;
                }

                if (!nodeElement.classList.contains("selected")) {
                    this.activeNode.clearFpsInterval();
                    this.activeNode.setStatusInterval();
                    this.activeNode.active = false;

                    let node = this.#nodes.find((n) => n.UID === nodeElement.id);
                    node.active = true;
                    this.activeNode = node;
                    // COMMENTS
                    this.activeNode.setFpsInterval();
                    this.activeNode.clearStatusInterval();       
                }
                this.updateNav();
                setCurvePosition();
                if (this.textConfig) {
                    let fieldbusContainers                              = document.querySelectorAll(".fieldbus");
                    this.textArea.value                                 = this.activeNode.configuration.textConfig;
                    this.textConfigElement.style.gridRow                = `1/${this.shownUniverses+3}`
                    this.universesContainer.style.display               = "none";
                    this.accoladesElement.style.display                 = "none";
                    this.fieldbussesElement.style.gridTemplateColumns   = "subgrid";
                    this.fieldbussesElement.style.gridColumn            = "8/10";
                    for (let i=0; i < fieldbusContainers.length; i++) {
                        fieldbusContainers[i].style.position                = "relative";
                        fieldbusContainers[i].style.zIndex                  = `${1000 + fieldbusContainers.length-i}`;
                        fieldbusContainers[i].style.gridColumn              = "1";
                        fieldbusContainers[i].style.justifySelf             = "center";
                        fieldbusContainers[i].style.left                    = `${(i-1)*(this.fieldbussesElement.clientWidth/7.5)}px`;
                        fieldbusContainers[i].style.marginRight             = `${10/fieldbusContainers.length}px`;
                    }
                }
            }
        }

        toggleRdmConfig = async (e) => {
            let targetFb    = e.target.closest(".fieldbus");
            let mainConfig  = document.getElementById("main-config");
            let rdmConfig   = document.getElementById("rdm-config");
            this.rdmConfig  = !this.rdmConfig;
            if (this.rdmConfig) {
                document.querySelector("#rdm-config h1").innerHTML = "FIELDBUS " + targetFb.id.split("-")[1];
                let fieldbusNr = targetFb.id.split("-")[1];
                this.targetFb = this.activeNode.fieldbusses.find((fb) => fb.id === `out${fieldbusNr-1}`);
                // fetching all the devices
                await this.showRdmConfig(fieldbusNr);
                this.removeEventHandlers();
                this.addRdmEvents();
                mainConfig.style.display = "none";
                rdmConfig.style.visibility = "visible";


            } else {
                this.targetFb.rdmDevices = [];
                this.targetFb = undefined;
                mainConfig.style.display = "grid";
                rdmConfig.style.visibility = "hidden";
                this.removeRdmEvents();
                this.showActiveNode();
                this.addEventHandlers();
            }      
        }

        async showRdmConfig(fieldbus) {
            try {
                this.rdmTable = await new Table(document.getElementById("rdm-table-container"), this.targetFb.rdmDevices, fieldbus-1);
                const response = await fetch(`${nodeIp}/xtod`, {signal: AbortSignal.timeout(2000)});
                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                let rdmConfig = Configuration.parseConfig(xmlDoc);
                let rdmUUIDs = rdmConfig[`out${fieldbus-1}`].split(" ");
                for (let i = 0; i < rdmUUIDs.length; i++) {
                    if (rdmUUIDs[i]) {
                        let rdmDevice = new RdmDevice(rdmUUIDs[i], fieldbus-1);
                        let lastDevice = i === rdmUUIDs.length-1? true : false;
                        this.targetFb.updateRdmDevices(rdmDevice, lastDevice);   
                        await installation.rdmTable.updateRow();
                    };                  
                }        
            }
                // let devices = xmlDoc.getElementsByTagName("dev")[0].innerHTML.split(" ");               
            catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");    
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.error(error);
                } else {
                    console.error("Failed to generate table:", error.message);
                } 
            }
        }

        addRdmEvents() {
            this.rdmConfigElement.addEventListener("click", this.handleRdmEvents);
            this.rdmConfigElement.addEventListener("change", this.handleRdmEvents);
            this.rdmConfigElement.addEventListener("input", this.handleRdmEvents);
            this.rdmConfigElement.addEventListener("focusin", this.handleRdmEvents);
            this.rdmConfigElement.addEventListener("focusout", this.handleRdmEvents);
            this.rdmConfigElement.addEventListener("keydown", this.handleRdmEvents);
        }

        removeRdmEvents() {
            this.rdmConfigElement.removeEventListener("click", this.handleRdmEvents);
            this.rdmConfigElement.removeEventListener("change", this.handleRdmEvents);
            this.rdmConfigElement.removeEventListener("input", this.handleRdmEvents);
            this.rdmConfigElement.removeEventListener("focusin", this.handleRdmEvents);
            this.rdmConfigElement.removeEventListener("focusout", this.handleRdmEvents);
            this.rdmConfigElement.removeEventListener("keydown", this.handleRdmEvents);
        }

        handleRdmEvents = async (e) => {
            this.min;
            this.max;
            let res;
            let fbId;
            let targetDevice
            switch (e.type) {
                case "click":
                    try {
                        fbId = this.targetFb.id.slice(3); 
                        if((e.target.innerText === e.target.closest("tr").dataset.devid || e.target.classList.contains("bikini")) && !installation.rdm.filtered) {
                            installation.rdmTable.toggleParameters(e)
                        } else if (e.target.closest("div").classList.contains("lamp-container") || e.target.id.split("-")[0] === "lamp") {
                            let targetRow = e.target.closest("tr");
                            let targetUUID = targetRow.dataset.devid;
                            if (e.target.id === "lamp-icon-on" || e.target.closest("div").id === "lamp-icon-on") {
                                installation.rdm.sendRdmPacket(installation.activeNode.ip, fbId, targetUUID, "SET", "1000", 0);
                            } else {
                                installation.rdm.sendRdmPacket(installation.activeNode.ip, fbId, targetUUID, "SET", "1000", 1);
                            }
                            //Updating the row from where the identify happened
                            this.rdmTable.updateLamp(targetRow);
                        }
                    } catch (error) {}
                    break;
                case "focusin":
                    try {
                        e.target.select();
                        this.target = e.target.parentElement.previousSibling;
                        if (this.target.innerHTML === "DMX address") {
                            this.min = 1, this.max = 512;
                        } else if (this.target.innerHTML === "Name") {
                            this.min = 1, this.max = 32;
                        }
                        break;
                    } catch (e) {
                        break;
                    }
                    
                case "input":
                    if (e.target.tagName === "SELECT") break;
                    let param = e.target.closest("td").previousSibling.innerHTML;
                    if (param === "DMX address") {
                        if (e.inputType === "insertReplacementText") {
                            e.target.select();
                        }       
                        if (e.target.value > this.max || e.target.value < this.min) {
                            e.target.classList.add("illegal");
                        } else if (e.target.classList.contains("illegal")) {
                            e.target.classList.remove("illegal");
                        }
                    } else if (param === "Name") {
                        if (e.target.value.length > this.max || e.target.value < this.min) {
                            e.target.classList.add("illegal");
                        } else if (e.target.classList.contains("illegal")) {
                            e.target.classList.remove("illegal");
                        }
                    }
                    
                    break;
                case "focusout":
                case "keydown":
                    fbId = this.targetFb.id.slice(3); 
                    targetDevice = this.targetFb.rdmDevices.find(dev => dev.UUID ===  e.target.closest("tr").dataset.devid);
                    let targetRow = e.target.closest("tr").children[1].innerHTML
                    if ((e.key === "Enter" || e.type === "focusout") && !e.target.classList.contains("illegal") && e.target.tagName !== "SELECT") {
                        switch (targetRow) {
                            case "Name":
                                console.log("Updating name");
                                res = await installation.rdm.sendRdmPacket(this.activeNode.ip, fbId, e.target.closest("tr").dataset.devid, "SET", "0082", e.target.value);
                                let newName = await installation.rdm.sendRdmPacket(this.activeNode.ip, fbId, e.target.closest("tr").dataset.devid, "GET", "0082");
                                newName = installation.rdm.decodeRdmPacket(newName, "0082", "GET");
                                targetDevice.deviceLabel = newName;
                                break;
                            case "DMX address":
                                console.log("Updating address")
                                res = await installation.rdm.sendRdmPacket(this.activeNode.ip, fbId, e.target.closest("tr").dataset.devid, "SET", "00F0", e.target.value);
                                let newAddress = await installation.rdm.sendRdmPacket(this.activeNode.ip, fbId, e.target.closest("tr").dataset.devid, "GET", "00F0", e.target.value);
                                newAddress = installation.rdm.decodeRdmPacket(newAddress, "00F0", "GET")
                                targetDevice.startAddress = newAddress;
                                break;
                            default:
                                break;
                        }

                        // Refresh the device where the update happened
                        let rdmDevice = e.target.closest("tr").dataset.devid;
                        let index = this.targetFb.rdmDevices.findIndex(dev => dev.UUID === rdmDevice);
                        if (index !== -1) {
                            const newDevice = await new RdmDevice(rdmDevice, fbId);
                            this.targetFb.rdmDevices[index] = newDevice;
                        }                     
                        // Finding the first row that holds the UUID and removing it + all the child-rows
                        let deviceRows = document.querySelectorAll(`[data-devid="${rdmDevice}"]`)
                    }
                case "change":
                    targetDevice = this.targetFb.rdmDevices.find(dev => dev.UUID ===  e.target.closest("tr").dataset.devid);
                    if (e.target.id === "param-dropdown" || e.target.tagName !== "SELECT") break
                    fbId = this.targetFb.id.slice(3); 
                    console.log("Changing personality");
                    res = await installation.rdm.sendRdmPacket(this.activeNode.ip, fbId, e.target.closest("tr").dataset.devid, "SET", "00E0", e.target.value.slice(-1));
                    let newPersonality = await installation.rdm.sendRdmPacket(this.activeNode.ip, fbId, e.target.closest("tr").dataset.devid, "GET", "00E0");
                    newPersonality = installation.rdm.decodeRdmPacket(newPersonality, "00E0", "GET");
                    targetDevice.personality = newPersonality;
                    break;
                default:
                    break;
            }
        }

        switchDarkMode(sw) {
            let accolades = document.querySelectorAll(".accolade path");
            let buttonSvgs = document.querySelector("#edit svg path");
            let body = document.querySelector("body");

            if (sw.checked === true) {
                this.lm = "light";
                localStorage.setItem("darkMode", "enabled");
                body.classList.add("light");
                for (const accolade of accolades) {
                    accolade.style.stroke = "#4d4d4d";
                }
                buttonSvgs.style.stroke = "#4d4d4d";
                buttonSvgs.style.fill = "#4d4d4d";
            } else {
                this.lm = "";
                localStorage.setItem("darkMode", "disabled");
                for (const accolade of accolades) {
                    accolade.style.stroke = "#FFF200"
                }
                buttonSvgs.style.stroke = "#FFF200";
                buttonSvgs.style.fill = "#FFF200";
                body.classList.remove("light");
            }
        }

        async refreshPage() {
            let demoNodes = [];
            for (const NODE of this.#nodes) {
                NODE.clearIntervals();
                if (isDemo(NODE.mac)) demoNodes.push(NODE);
            }
            await this.fetchNodes(false);
            let nodeIps = this.#nodes.map(node => node.ip);
            demoNodes.forEach((node) => {
                if(!nodeIps.includes(node.ip)) {
                    this.#nodes.push(node);
                }
            });
            performance.clearResourceTimings();
            this.updateNav();
        }
    }

    class Node {
        #ip;
        #name;
        #mac;
        #switch = {};
        #netmask;
        #configuration;
        #universes = [];
        #fieldbusses = [];
        #codecs = [];
        #firmware;
        #lastUpdate;
        #online = true;
        #active = false;

        #timestamp;
        #prevTimestampOff = null;
        #prevTimestampOn = null;

        constructor(ip, skipConfig = false) {
            this.#ip = ip;
            
            if (!skipConfig) {
                return (async () => {
                    try {
                        this.#configuration = await new Configuration(ip);
                        if (this.#configuration) {    
                            this.initialiseNode();
                            console.log("initialisation complete")
                            return this;
                        }
                    } catch(error) {
                        console.error(error);
                    }
                    
                })();
            }
        }

        get ip() {
            return this.#ip;
        }

        get name() {
            return this.#name;
        }

        get mac() {
            return this.#mac;
        }

        get UID() {
            return this.#mac.replaceAll(":", "");
        }

        get netmask() {
            return this.#netmask;
        }

        get universes() {
            return this.#universes;
        }

        get fieldbusses() {
            return this.#fieldbusses;
        }

        get configuration(){
            return this.#configuration;
        }

        get codecs() {
            return this.#codecs;
        }

        get firmware() {
            return this.#firmware;
        }
        
        get active() {
            return this.#active;
        }

        get online() {
            return this.#online;
        }

        get switch() {
            return this.#switch;
        }

        
        set ip(ip) {
            let reIP = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

            if (!reIP.test(ip)) {
                console.log("Invalid IP format");
                return;
            }

            let ipParts = ip.split('.').map(Number);
            let maskParts = this.#netmask.split('.').map(Number);

            let broadcastParts = ipParts.map((octet, index) => octet | (255 - maskParts[index]));

            if (ipParts.every((octet, index) => octet === broadcastParts[index])) {
                console.log("This is a broadcast address and is not allowed.");
                return;
            }

            console.log("This is a valid IP address.");
            this.#ip = ip;
        }

        set name(name){
            if (typeof name !== "string" || name.trim().length === 0) {
                console.log("Invalid name: must be a non-empty string.");
                return;
            }
            this.#name = name.trim();
        }

        set mac(mac){
            let reMAC = /^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$/;
            if (!reMAC.test(mac)) {
                console.log("Invalid MAC address: must be in the format XX:XX:XX:XX:XX:XX.");
                return;
            }
            this.#mac = mac.toUpperCase();
        }

        set switch(sw){
            this.#switch = sw;
        }

        set firmware(fw) {
            this.#firmware = fw;
        }

        set netmask(nm){
            let reNetmask = /^(255|254|252|248|240|224|192|128|0)\.((255|254|252|248|240|224|192|128|0)\.){2}(255|254|252|248|240|224|192|128|0)$/;
            if (!reNetmask.test(nm)) {
                console.log("Invalid netmask: must be a valid subnet mask.");
                return;
            }
            this.#netmask = nm;
        }

        set universes(un){
            if (!Array.isArray(un) || un.length !== 10 || !un.every(u => u instanceof Universe)) {
                console.log("Invalid universes: must be an array of 10 Universe objects.");
                return;
            }
            this.#universes = un;
        }

        set fieldbusses(fb){
            if (!Array.isArray(fb) || fb.length !== 6 || !fb.every(f => f instanceof Fieldbus)) {
                console.log("Invalid fieldbusses: must be an array of 6 Fieldbus objects.");
                return;
            }
            this.#fieldbusses = fb;
        }

        set codecs(c){
            this.#codecs = c;
        }

        set active(a) {
            this.#active = a;
        }

        set configuration(c) {
            this.#configuration = c;
        }

        setFpsInterval = () => {
            this.fpsInterval = setInterval(async() => {
                if (!isDemo(this.mac)) {           
                try {
                    const response = await fetch(`http://${this.ip}/xart`, {signal: AbortSignal.timeout(5000)});
                    if (!response.ok) {
                        throw new Error(`Response status: ${response.status}`);
                    }
                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                    let parsedXart = Configuration.parseConfig(xmlDoc);
                    let newTime = new Date().getTime();
                    if (this.#lastUpdate > 0) {
                        let delta = newTime - this.#lastUpdate;
                        for (let uni = 0; uni < this.#universes.length; uni++) {
                            let fps = 0;
                            let AnIn = parseInt(((parsedXart[`in${uni}`]).split(" "))[0])
                            let AnOut = (parseInt(this.#universes[uni]["framecounter"]))
                            fps = (AnIn + 8192 - AnOut)%8192;
                            fps = Math.trunc(Math.round(fps/(delta/10000))/10);
                            let fpsElement = document.querySelector(`#accolade-${uni+1} text`);
                            if (fpsElement) fpsElement.innerHTML = `${fps}fps`;                     
                            // Updating the universes with the latest received framecounter
                            this.#universes[uni]["framecounter"] = ((parsedXart[`in${uni}`]).split(" "))[0]
                        }
                    }
                
                    if (!this.#online) this.setStatus(true);
                    this.#lastUpdate = newTime;
                
                } 
                catch (error) {
                    if (error.name === "TimeoutError") {
                        console.error("Request timed out");
                        if (this.#online) this.setStatus(false);
                    } else if (error.name === "AbortError") {
                        console.error("Fetch aborted by user");
                    } else if (error.name === "TypeError") {
                        console.error(error);
                    } else {
                        console.error("Failed to update fps:", error.message);
                    }
                }
            }}, 1000);      
        }

        clearFpsInterval = () => {
            clearInterval(this.fpsInterval);       
            this.fpsInterval = null;  
        }

        setStatusInterval = () => {
            this.statusInterval = setInterval(async () => {
            if (!isDemo(this.mac) && this.active === false) {
                try {
                    const response = await fetch(`http://${this.ip}/xart`, {signal: AbortSignal.timeout(2000)});
                    if (!response.ok) {
                        throw new Error(`Response status: ${response.status}`);
                    }
                    this.setStatus(true);               
                } 
                catch (error) {
                    if (error.name === "TimeoutError") {
                        console.error("Request timed out");
                        this.setStatus(false);     
                    } else if (error.name === "AbortError") {
                        console.error("Fetch aborted by user");
                    } else if (error.name === "TypeError") {
                        console.error(error);
                    } else {
                        console.error("Failed to update fps:", error.message);
                    }
                }
            }    
            }, 100000);
        }

        clearStatusInterval = () => {
            clearInterval(this.statusInterval);
            this.statusInterval = null;
        }

        clearIntervals = () => {
            clearInterval(this.fpsInterval);
            clearInterval(this.statusInterval);
            this.fpsInterval = this.statusInterval = null;
        }

        // setting the status indicator of the disconnected nodes, debounce to make sure there is no
        // flickering
        setStatus = (o) => {
            let node = document.getElementById(this.UID);
            this.#timestamp = new Date().getTime();
            if (o) {
                if (this.#prevTimestampOn === null) {
                    this.#prevTimestampOn = this.#timestamp;
                }
                if ((this.#timestamp-this.#prevTimestampOn) > 1) {
                    this.#online = o;
                    node.classList.remove("disconnected");
                    installation.body.classList.remove("loading");
                    this.#prevTimestampOn = new Date().getTime();
                    this.#prevTimestampOff = null;
                    installation.addEventHandlers();
                }         
            } else {
                if (this.#prevTimestampOff === null) {
                    this.#prevTimestampOff = this.#timestamp;
                }
                if ((this.#timestamp-this.#prevTimestampOff) > 1) {
                    this.#online = o;
                    node.classList.add("disconnected");
                    if (this.mac === installation.activeNode.mac) {
                        installation.body.classList.add("loading");
                    }
                    this.#prevTimestampOff = new Date().getTime();
                    this.#prevTimestampOn = null;
                    installation.removeEventHandlers();
                }         
            }  
        }

        initialiseNode = (demo = false) => {
            if (this.#configuration !== null) {
                this.#name = this.#configuration.name;
                if (!demo) {
                    this.#mac = this.#configuration.mac;
                    if (localStorage.getItem("activeNode") === this.#mac) {
                        this.#active = true;
                    }
                }

                try {
                    this.#switch = this.#configuration.switch;
                } catch(error) {
                    console.log("Node found without switch");
                }
                
                this.#netmask = this.#configuration.mask;
                this.#firmware = this.#configuration.firmware;

                let counter = 0;
                let fbIndex = 0;
                let resetFb = false;
                let artnet = [];
                // let codecs = [];
                for (const [key, value] of Object.entries(this.#configuration.fieldbus)) {
                    let params = [];
                    for (let v of Object.values(value)) {
                        params.push(v);
                    }
                    this.#fieldbusses.push(new Fieldbus(key, ...params)) 

                    counter++;
                }

                for (const [key, value] of Object.entries(this.#configuration.artnet)) {
                    let params = [];
                    for (let v of Object.values(value)){
                        params.push(v);
                    }
                    this.#universes.push(new Universe(key, ...params));
                }
                
                for (const value of Object.values(this.#configuration.codec)) {
                    this.#codecs.push(value);
                }
                // this.#codecs = codecs;                          
            }
        }

        processForm = (e) => {
            e.preventDefault();
            e.stopPropagation();
            let name = document.getElementById("new-name");
            let mask = document.getElementById("new-mask");
            let ip = document.getElementById("new-ip");
            this.name = name.value;
            this.netmask = mask.value;
            this.ip = ip.value;
            if (!isDemo(this.mac)) this.configuration.handleFormChange(this);
        }
    }

    class NodeTemplate extends Node {
        constructor(ip, oldNode, name, mac, sw, nm, un, fb, c, fw, config){
            super(ip, true, oldNode);
            this.name = name;
            this.mac = mac;
            this.switch = sw;
            this.netmask = nm;
            this.universes = un;
            this.fieldbusses = fb;
            this.codecs = c;
            this.firmware = fw;
            this.configuration = config;
        }
    }

    class Universe {
        #id;
        #universe;
        #keep;
        #framecounter;

        #paramBytes = 4;

        constructor(id, universe, keep, framecounter) {
            this.#id = id;
            this.#universe = universe;
            this.#keep = keep;
            this.#framecounter = framecounter;
        }

        get id() {
            return this.#id;
        }

        get universe() {
            return this.#universe;
        }

        get keep() {
            return this.#keep;
        }

        get framecounter() {
            return this.#framecounter
        }

        set framecounter(f) {
            this.#framecounter = f;
        }

        set universe(u) {
            this.#universe = u;
        }

        set keep(k) {
            this.#keep = k;
        }
    }

    class Fieldbus {
        #id;
        #codec;
        #startAddress;
        #streamLength;
        #finetuningParams;
        #rdmDevices = [];
        #foundUUIDs = []

        constructor(id, codec, startAddress, streamLength, finetuningParams) {
            this.#id = id;
            this.#codec = codec;
            this.#startAddress = startAddress;
            this.#streamLength = streamLength;
            this.#finetuningParams = finetuningParams;
        }

        get id () {
            return this.#id;
        }

        get codec() {
            return this.#codec;
        }

        get startAddress() {
            return this.#startAddress;
        }

        get streamLength() {
            return this.#streamLength;
        }

        get finetuningParams() {
            return this.#finetuningParams;
        }

        get rdmDevices() {
            return this.#rdmDevices;
        }

        set streamLength(s) {
            this.#streamLength = s;
        }

        set startAddress(s) {
            this.#startAddress = s;
        }

        set codec(c) {
            this.#codec = c;
        }

        set rdmDevices(r) {
            this.#rdmDevices = r;
        }

        updateRdmDevices(r, ld) {
            this.#foundUUIDs.push(r.UUID);        
            // first checking if the device is already present. If it is check for changed values and update them accordingly, if it isn't
            // add the device to the list.
            let originalDevice = this.#rdmDevices.find(rd => {
                rd.UUID === r.UUID;
            })
            if (originalDevice) {
                if (originalDevice.UIObject["DMX address"] !== r.UIObject["DMX address"]) originalDevice.UIObject["DMX address"] = r.UIObject["DMX address"];
                if (originalDevice.UIObject["Footprint"] !== r.UIObject["Footprint"]) originalDevice.UIObject["Footprint"] = r.UIObject["Footprint"];
                if (originalDevice.UIObject["DMX address"] !== r.UIObject["Personality"]) originalDevice.UIObject["Personality"] = r.UIObject["Personality"];
            } else {
                this.#rdmDevices.push(r);
            }

            // checking if there is a difference between all te found devices and the devices in the list. If there are less devices found, delete these from the list.
            if (ld) {
                for (const rdv of this.#rdmDevices) {
                    if (!this.#foundUUIDs.includes(rdv.UUID)) {
                        let deviceIndex = this.#rdmDevices.indexOf(rdv);
                        this.#rdmDevices.splice(deviceIndex, 1);
                    }
                }
            }
        }

        setStart = (e) => {
            clearInterval(installation.fetchConfigInterval);
            switch (e.target.classList[0]) {
                case "top-handle": 
                    this.start = "top"
                    e.target.closest(".patch").classList.add("top");
                    break;
                case "address-container":
                case "draggable":
                    if (e.target.offsetParent.classList.contains("overflow") && e.target.tagName === "H3") break;
                    this.start = "patch";
                    e.target.closest(".patch").classList.add("mid");
                    break;
                case "bottom-handle":
                    this.start = "bottom"
                    e.target.closest(".patch").classList.add("bottom");
                    break;
                default:
                    return;
            }
            this.startedDrag = true;
            this.startCoord = e.clientY;
            this.targetFb = e.target.closest(".fieldbus").id;
        }

        setMove = (e) => {
            if (this.startedDrag) {
                this.startedMove = true;
                let changePatch = (newRange = undefined, newStart = undefined) => {
                    let patch = document.querySelector(`#${this.targetFb} .address.range .patch`);
                    let start = document.querySelector(`#${this.targetFb} .address.range h2.start`);
                    let stream = document.querySelector(`#${this.targetFb} .address.range h2.stream`);
                    if (newRange !== undefined) {
                        this.newRange = Math.floor(newRange);
                        let rangeElement;
                        let status = !document.querySelector(".patch").classList.contains("config");
                        if (status) {
                            rangeElement = document.querySelector(`#${this.targetFb} .address-container h2.stream span`);
                            rangeElement.innerHTML = this.newRange;
                        } else {
                            rangeElement = document.querySelector(`#${this.targetFb} .address-container h2.stream input`);
                            rangeElement.value = this.newRange;
                        }
                        patch.style.height = String((this.newRange/(512*installation.shownUniverses))*100)+"%";

                        checkOverflow(patch, status);
                    }
                    if (newStart !== undefined) {
                        this.newStart = Math.floor(newStart);
                        patch.style.top = String((newStart/(512*installation.shownUniverses))*100)+"%";
                        let startElement;
                        if (!document.querySelector(".patch").classList.contains("config")) {
                            startElement = document.querySelector(`#${this.targetFb} .address-container h2.start span`);
                            startElement.innerHTML = this.newStart;
                        } else {
                            startElement = document.querySelector(`#${this.targetFb} .address-container h2.start input`);
                            startElement.value = this.newStart;
                        }    
                    }
                }

                const threshold = 50;
                let newRange = 0;
                let newStart = 0;
                let dif = 0;
                const addressRange = document.querySelector(`#fb-${parseInt(this.#id.split("out")[1])+1} .address.range`);
                const addressesPerPixel = (512*installation.shownUniverses)/addressRange.getBoundingClientRect()["height"];

                switch (this.start) {
                    case "top":
                        const offsetTop = this.startCoord-e.clientY;
                        newStart = this.#startAddress - (offsetTop*addressesPerPixel);
                        newRange = this.#streamLength + (offsetTop*addressesPerPixel);
                        for (let i=0; i<= installation.shownUniverses; i++) {
                            dif = newStart - (512*i);
                            if (dif > -threshold && dif < threshold) {
                                let hop = (512*i) - newStart;
                                newStart = 512*i+1;
                                newRange = newRange - hop -1 ;
                                break;
                            }
                        }

                        if (newRange < 1) {
                            newRange = 1;
                            newStart = this.#startAddress + this.#streamLength - 2;
                        }

                        if (newStart < 1) {
                            newStart = 1;
                            newRange = this.#startAddress + this.#streamLength -1 ;
                        }
                        changePatch(newRange, newStart);
                        break;
                    case "bottom":
                        const offsetBottom = this.startCoord-e.clientY;
                        newRange = this.#streamLength - (offsetBottom*addressesPerPixel);
                        // snapping to full universes
                        for (let i=0; i<= installation.shownUniverses; i++) {
                            dif = (512*i-(this.#startAddress+newRange));
                            if (dif < threshold && dif > -threshold){
                                newRange = (512*i)-(this.#startAddress-1)
                                break;
                            }
                        }
                        // bottom and top limits
                        if (this.startAddress + newRange > 512*installation.shownUniverses) newRange = (512*installation.shownUniverses)-(this.#startAddress-1);
                        if (newRange < 1) newRange = 1;
                        changePatch(newRange);
                        break;  
                    case "patch":
                        const offset = this.startCoord-e.clientY;
                        newStart = this.#startAddress - (offset*addressesPerPixel);
                        for (let i=0; i<= installation.shownUniverses; i++) {
                            dif = newStart - (512*i);
                            if (dif > -threshold && dif < threshold) {
                                newStart = (512*i) + 1;
                                break;
                            }          
                        }
                        if (newStart < 1) newStart = 1;
                        else if (newStart + this.#streamLength > 512*installation.shownUniverses) newStart = (512*installation.shownUniverses) - this.#streamLength;
                        changePatch(undefined, newStart);
                        break
                    default:
                        break;           
                }
            }
        }

        updateValues = (e) => {
            if (e.target.tagName === "INPUT" && !this.startedMove) {
                return;
            }
            let fbs = document.querySelectorAll(".patch");
            fbs.forEach((fb) => fb.classList.remove("top", "mid", "bottom"));

            this.start = '';
            this.startedDrag = this.startedMove = false;   
            if (this.newRange !== undefined) this.#streamLength = this.newRange;
            if (this.newStart !== undefined) this.#startAddress = this.newStart;
            
            if (!isDemo(installation.activeNode.mac)) {
                installation.activeNode.configuration.handleInputChange(this);
            }
        }

        handleCodecChange = (e) => {
                let target = e.target;
                let value = target.value;

                this.codec = target.selectedIndex;

                if (!isDemo(installation.activeNode.mac)) {
                    installation.activeNode.configuration.handleInputChange(this, true);
                } else installation.showActiveNode();
            }
    }

    class RdmDevice {
        #parentFbId;
        #UUID;
        #deviceLabel = "";
        #deviceModelDescription;
        #rdmProtocolVersion;
        #deviceModelId;
        #productCategory;
        #softwareVersion;
        #footprint;
        #personality;
        #startAddress;
        #subDevCount;
        #sensorCount;
        #personalityDescription = [];
        #UIObject = {};

        constructor(id, fb) {
                this.#parentFbId = fb;
                this.#UUID = id;
                this.#UIObject = {
                    "Name": {
                        "Value": "-",
                        "Type": "String"
                    },
                    "DMX address": {
                        "Value": "-",
                        "Type": "Integer"
                    },
                    "Footprint": {
                        "Value": "-",
                        "Type": "Integer"
                    },
                    "Personality": {
                        "Value": "-/-",
                        "Type": "Integer"
                    }
                };
                this.infoFetched = false;
                this.personalityDescriptionRes = [];
        }

        // Getters
        get UUID() {
            return this.#UUID;
        }
        get rdmProtocolVersion() {
            return this.#rdmProtocolVersion;
        }
        get deviceModelId() {
            return this.#deviceModelId;
        }
        get productCategory() {
            return this.#productCategory;
        }
        get softwareVersion() {
            return this.#softwareVersion;
        }
        get footprint() {
            return this.#footprint;
        }
        get personality() {
            return this.#personality;
        }
        get startAddress() {
            return this.#startAddress;
        }
        get subDevCount() {
            return this.#subDevCount;
        }
        get sensorCount() {
            return this.#sensorCount;
        }
        get UIObject() {
            return this.#UIObject;
        }
        get deviceLabel() {
            return this.#deviceLabel;
        }
        get personalityDescription() {
            return this.#personalityDescription;
        }
        get parentFbId() {
            return this.#parentFbId;
        }
        
        set deviceLabel(dl) {
            this.#deviceLabel = dl;
            this.#UIObject["Name"]["Value"] = dl;
            // Also updating the referenced table
            installation.rdmTable.rdmInfo[this.#UUID] = this.#UIObject;
        }
        
        set startAddress(sa) {
            this.#startAddress = sa;
            this.#UIObject["DMX address"]["Value"] = sa;
            installation.rdmTable.rdmInfo[this.#UUID] = this.#UIObject;
        }
        
        set personality(p) {
            this.#personality = `${p[0]} of ${p[1]}`
            this.#UIObject["Personality"]["Value"] = `${p[0]} of ${p[1]}`;
            installation.rdmTable.rdmInfo[this.#UUID] = this.#UIObject;
        }
        
        getPersonalityDescription(p) {
            let personality = this.#personalityDescription.find(pers => pers[0] === p);
            return personality? personality : null; 
        }

        personalityDescriptionSet() {
            return this.#personalityDescription.length? true : false;
        }

        parseDeviceParameters(params, targetParam) {
            let parameters = installation.rdm.decodeRdmPacket(params, "0060", "GET");

            let targetFootprint, targetPersonality, targetDmx;
            switch(targetParam) {
                case "Footprint":
                    targetFootprint = 
                        installation.config?    installation.rdm.table.querySelector(`.Footprint[data-devid="${this.UUID}"] input`)
                                                : installation.rdm.table.querySelector(`.Footprint[data-devid="${this.UUID}"] td:nth-of-type(3)`);
                    break;
                case "DMX address":
                    targetDmx = 
                        installation.config?    installation.rdm.table.querySelector(`.DMX-address[data-devid="${this.UUID}"] input`)
                                                : installation.rdm.table.querySelector(`.DMX-address[data-devid="${this.UUID}"] td:nth-of-type(3)`);                      
                    break;
                case "Personality":
                    targetPersonality = 
                        installation.config?    installation.rdm.table.querySelector(`.Personality[data-devid="${this.UUID}"] select`)
                                                : installation.rdm.table.querySelector(`.Personality[data-devid="${this.UUID}"] td:nth-of-type(3)`);
                    break;
                case "Name":
                    break;
                default:
                    targetFootprint =           installation.rdm.table.querySelector(`.Footprint[data-devid="${this.UUID}"] td:nth-of-type(3)`);
                    targetDmx = 
                        installation.config?    installation.rdm.table.querySelector(`.DMX-address[data-devid="${this.UUID}"] input`)
                                                : installation.rdm.table.querySelector(`.DMX-address[data-devid="${this.UUID}"] td:nth-of-type(3)`);                           
                    targetPersonality = 
                        installation.config?    installation.rdm.table.querySelector(`.Personality[data-devid="${this.UUID}"] select`)
                                                : installation.rdm.table.querySelector(`.Personality[data-devid="${this.UUID}"] td:nth-of-type(3)`);
            };
            this.#rdmProtocolVersion                        = `v${parameters[0][0]}.${parameters[0][1]}`
            this.#deviceModelId                             = parameters[1];
            this.#productCategory                           = parameters[2];
            this.#softwareVersion                           = parameters[3];
            this.#footprint                                 = parameters[4];
            this.#UIObject["Footprint"]["Value"]            = parameters[4];
            if (targetFootprint && (targetParam === "Footprint" || !targetParam)) {
                targetFootprint.innerHTML = parameters[4];
            } 
            // installation.config? targetFootprint.value = parameters[4] : targetFootprint.innerHTML = parameters[4];
            
            this.#personality                               = `${parameters[5][0]}/${parameters[5][1]}`
            this.#UIObject["Personality"]["Value"]          = `${parameters[5][0]}/${parameters[5][1]}`
            if (targetPersonality && installation.config && (targetParam === "Personality" || !targetParam)) {
                installation.rdmTable.fillDropDown(targetPersonality, `${parameters[5][1]}`, this, `${parameters[5][0]}`)
                targetPersonality.nextSibling.innerHTML = ` of ${parameters[5][1]}`
            }
            else if (targetPersonality && targetParam === "Personality" || !targetParam) targetPersonality.innerHTML = `${parameters[5][0]} of ${parameters[5][1]}`
            
            this.#startAddress                              = parameters[6];
            this.#UIObject["DMX address"]["Value"]          = parameters[6];
            if (targetDmx && installation.config && (targetParam === "Dmx address" || !targetParam)) {
               targetDmx.value = parameters[6] 
            } else if (targetDmx && (targetParam === "DMX address" || !targetParam)) targetDmx.innerHTML = parameters[6];
            // installation.config? targetDmx.value = parameters[6] : targetDmx.innerHTML = parameters[6];
            this.#subDevCount                               = parameters[7];
            this.#sensorCount                               = parameters[8];
            
            return this.infoFetched = true;
        }
        
        async fetchLabel() {
            installation.rdm.sendRdmPacket(installation.activeNode.ip, this.#parentFbId, this.#UUID, "GET", "0082")
            .then(res => {
                if (res && !res.includes("<fault>")) {
                    this.#deviceLabel = installation.rdm.decodeRdmPacket(res, "0082", "GET");
                    this.#UIObject["Name"]["Value"] = this.#deviceLabel;
                    let targetName = undefined;
                    let counter = 0;
                    const updateLabel = () => {
                        do { 
                            console.log("setting targetName");
                            if (installation.config) {      
                                targetName = document.querySelector(`.Name[data-devid="${this.UUID}"] input`);  
                                if (targetName) targetName.value = this.#deviceLabel;
                            } else {
                                targetName = document.querySelector(`.Name[data-devid="${this.UUID}"] td:nth-of-type(3)`);       
                                if (targetName) targetName.innerHTML = this.#deviceLabel;
                            }
                            counter ++;
                            if (!targetName) {
                                console.log("trying again in 500ms");
                                setTimeout(updateLabel, 500);
                            } else {
                                console.log(targetName);
                            }
                        } while (targetName === undefined && counter < 5)
                    }
                    updateLabel();
                    return this.#deviceLabel;
                }                
            })
            .catch(error => {
                console.error(error);
            });       
        }

        fetchSupportedParameters = async (targetParam = null) => {
            // checking for other supported parameters
                installation.rdm.sendRdmPacket(installation.activeNode.ip, this.#parentFbId, this.#UUID, "GET", "0050")
                .then(res => {
                    if (res && !res.includes("<fault>")) {
                        this.supportedParameters = installation.rdm.decodeRdmPacket(res, "0050", "GET");
                        this.updatePersonalityDescription(targetParam);
                    } else this.supportedParameters = null;
                })
                .catch (error => {
                    console.error(error);
                });
        }

        updatePersonalityDescription = (targetParam = null) => {
            if (this.supportedParameters && this.supportedParameters.includes("00E1")) {
                // DMX personality description is supported
                // personality is defined as x of y, first check if the personality is of the correct type and then extract the last digit
                if (typeof this.#personality === "string") {
                    for (let i = 1; i < parseInt(this.#personality.slice(-1))+1; i++) {
                        installation.rdm.sendRdmPacket(installation.activeNode.ip, this.#parentFbId, this.#UUID, "GET", "00E1", i.toString(16).padStart(2,"0")).then(res => {
                            if (res && (targetParam === "Personality" || targetParam === null)) this.setResult(res)
                            else if (targetParam !== "Personality") this.personalityDescriptionRes.push(res);
                        });
                    }
                }

            }
        }

        setResult(res) {
            let personalityDescription = installation.rdm.decodeRdmPacket(res, "00E1", "GET");
            console.log(personalityDescription);
            let selectedPersonality = false;
            if (this.#personality[0] == personalityDescription[0]) {
                this.#personality = `${this.#personality.split("/")[0]}/${this.#personality.split("/")[1]}/${personalityDescription[2]}`
                this.#UIObject["Personality"]["Value"] = this.#personality;
                selectedPersonality = true;
            }
            this.#personalityDescription.push(personalityDescription);
            // injecting the descripion in the UI
            let data;
            if (installation.config) {
                data = installation.rdm.table.querySelector(`.Personality[data-devid="${this.UUID}"] select`);
                // TODO:
                // Uncaught (in promise) TypeError: can't access property "children", data is null
                let oldOption = data.children[personalityDescription[0] -1];
                let option = document.createElement("option", {value: personalityDescription[0] -1})
                let pIndex = parseInt(personalityDescription[0]-1);
                selectedPersonality? option.selected = true : option.selected = false;
                const CONTENT = document.createTextNode(`${personalityDescription[2]} ${personalityDescription[0]}`);
                option.appendChild(CONTENT);
                data.replaceChild(option, oldOption);              
            } else {
                if (selectedPersonality) {
                    console.log(installation.rdm.table.querySelector(`.Personality[data-devid="${this.UUID}"]`));
                    data = installation.rdm.table.querySelector(`.Personality[data-devid="${this.UUID}"] td:nth-of-type(3)`);    
                    data.innerHTML = `${personalityDescription[2]} ${personalityDescription[0]}`;
                    let p = document.createElement("p");
                    p.id = "personality-paragraph";
                    console.log(this.personality.split("/")[1])
                    p.innerHTML = `&nbspof ${this.personality.split("/")[1]}` 
                    data.appendChild(p);       
                }
            }
        }
    }

    class Rdm {
        #pidmap = {
            // DEVICE_INFO
            "0060": {
                "response": {
                    "PD": [[8,8], 16, 16, 32, 16, [8,8], 16, 16, 8]
                }
            },
            // DEVICE_LABEL
            "0082": {
                "response": {
                    "PDL": "variable"
                }
            },
            // IDENTIFY_DEVICE
            "1000": {
                "response": {
                    "PDL": "01"
                }
            },
            // DMX_START_ADDRESS
            "00F0": {
                "response": {
                    "PDL": "02"
                }
            },
            // DMX_PERSONALITY
            "00E0": {
                "response": {
                    "PD": [8,8]
                }
            },
            // SUPPORTED_PARAMETERS
            "0050": {
                "response": {
                    "PDL": "variable",
                    "PD": 16
                }
            },
            // DMX_PERSONALITY_DESCRIPTION
            "00E1": {
                "controller": {
                    "PDL": "01"
                },
                "response": {
                    "PDL": "variable"
                }
            },


        }

        constructor(){}
        // PDL is the amount of bytes being sent in hex format. 

        sendRdmPacket = async (nodeIp, fbId, destinationUID, getSet, param, data = null) => {
            if (getSet === "SET") {
                let hexData = "";
                switch(param) {
                    // DMX_START_ADDRESS
                    case "00F0": 
                        this.pd = Number(data).toString(16).padStart(4,"0").toUpperCase();
                        break;
                    // DEVICE_LABEL
                    case "0082":
                        for (let i=0; i<data.length; i++) {
                            hexData+=data.charCodeAt(i).toString(16);
                        } 
                        this.pdl = (hexData.length/2).toString(16).padStart(2,"0").toUpperCase();
                        this.pd = hexData.toUpperCase();
                        break;
                    // IDENTIFY_DEVICE
                    case "1000":
                    // DMX_PERSONALITY
                    case "00E0":
                        hexData = data.toString(16).padStart(2, "0");
                        this.pd = hexData.toUpperCase();
                        break;
                    default:
                        break;
                }
            } else {
                this.pdl = this.#pidmap?.param?.controller?.PDL 
                this.pdl = this.pdl ? this.pdl : "00";
                if (!data) {
                    this.pd = this.#pidmap?.param?.controller?.PD 
                    this.pd = this.pd ? this.pd : "";
                } else {
                    this.pd = data
                }
                
            }

            // calculating the position of the checksum high based of data length and data === this.#pidmap[getSet][param]["controller"]["PDL"].length/2 + 
            let ML = 24 + this.pd.length/2
            ML = ML.toString(16).padStart(2, "0").toUpperCase();
            let payload = 
    `CC01${ML}${destinationUID}033A87654321${installation.rdmCounter.padStart(2, "0")}00000000${getSet === "GET"? 20 : 30}${param}${this.pdl}${this.pd}`
            // console.log(payload);
            let finalCS;
            let CS = (function () {
                let byteArr = []
                for (let i=0; i < payload.length; i+=2) {
                    byteArr.push(payload.substring(i,i+2))
                }
                const intArr = byteArr.map((h) => parseInt(h,16));
                let intCS = intArr.reduce((acc, cv) => {return acc + cv}, 0);
                finalCS = intCS.toString(16).padStart(4, '0');
            })();
            payload = `<rdm${fbId}>` + payload + finalCS.toUpperCase() + `</rdm${fbId}>`;
            console.log(payload);

            try {
                const response = await fetch(`http://${installation.activeNode.ip}/xrdm`, {
                    signal: AbortSignal.timeout(5000),
                    method:'POST',      
                    body: `${payload}`
                })

                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }

                const xmlText = await response.text();
                return xmlText;
            }

            catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.error("Error fulfilling request: ", error);
                } else {
                    console.error("Failed to post XML configuration:", error.message);
                }
            }
        }

        decodeRdmPacket(packet, param, getSet) {
            if (!packet) return;
            let parameters = [];
            let startBit = "<rdmX>".length + 48;
            let eop = packet.indexOf("</rdm") - 4;
            let payload = packet.slice(startBit,eop);
            switch (this.#pidmap[param]["response"]["PDL"]) {
                case "variable":
                    // DEVICE_LABEL
                    if (param === "0082") return hexToAscii(payload);
                    // SUPPORTED_PARAMETERS
                    else if (param === "0050") return hexToArr(payload, this.#pidmap[param]["response"]["PD"]);
                    // DMX_PERSONALITY_DESCRIPTION
                    else if (param === "00E1") return hexToPersonality(payload);              
                    break;
                case "01": 
                    return payload === "01" ? true : false;
                    break;
                default:
                    if (typeof this.#pidmap[param]["response"]["PD"] === "object") {
                        let paramCounter = 0;
                        let subCounter = 0;
                        let isArr = false;
                        if (typeof this.#pidmap[param]["response"]["PD"][paramCounter] === "object") isArr = true;
                        let subParams = [];
                        paramCounter = 0;
                        for (let i = 0; i < this.#pidmap[param]["response"]["PD"].length; i++) {
                            if (typeof this.#pidmap[param]["response"]["PD"][i] === "object") {
                                for (let j=0; j < this.#pidmap[param]["response"]["PD"][i].length; j++) {
                                    let dataLength = this.#pidmap[param]["response"]["PD"][i][j]/4;
                                    subParams.push(parseInt(payload.slice(paramCounter, paramCounter + dataLength), 16));
                                    paramCounter+=dataLength;
                                }
                                parameters.push(subParams);
                                subParams=[];
                                continue;
                            }
                            let dataLength = this.#pidmap[param]["response"]["PD"][i]/4;
                            parameters.push(parseInt(payload.slice(paramCounter, paramCounter + dataLength), 16));
                            paramCounter+=dataLength;
                        }
                        return(parameters);
                        break;
                    } else {
                        return hexToDec(payload);
                    }   
            }
        }
    }

    

    class Configuration {
        #xmlConfig;
        #configObject;
        #textConfig;
        #textConfigBlob;

        // look up table for the amount of hex characters per parameter
        #ioHexCount = {
            "artnet": {
                "universe": 4,
                "keep": 4,
            },
            "fieldbus": {
                "codec": 2,
                "startAddress": 4,
                "streamLength": 4,
            }
            
        }

        constructor(ip, skipConfig = false){
            if (!skipConfig) {
                return( async () => {
                    try {
                        this.#xmlConfig = await this.fetchXmlConfig(ip);
                    }
                    catch (error) {
                        console.error(error)
                    }
                    if (this.#xmlConfig) {
                        this.#configObject = Configuration.parseConfig(this.#xmlConfig);
                        // filling a text config blob for download with XML button
                        this.#textConfigBlob = new Blob([this.generateTextConfig()], {type: 'text/plain'});    
                        return this;
                    }
                })();
            }           
        }

        get xmlConfig(){
            return this.#xmlConfig;
        }

        get textConfig() {
            return this.#textConfig;
        }

        get configObject(){
            return this.#configObject;
        }

        get name() {
            return dig(this.#configObject, "name");
        }

        get mac() {
            return hexToMac(dig(this.#configObject, "mac"));
        }

        get mask() {
            return hexToIP(dig(this.#configObject, "mask"));
        }

        get switch() {
            return this.convertObjectAndMap(SWITCHPARAMS, "switch")
        }

        get fieldbus() {
            return this.convertObjectAndMap(FIELDBUSPARAMS, "fieldbus");
        }

        get artnet() {
            return this.convertObjectAndMap(ARTNETPARAMS, "artnet");
        }

        get codec() {
            return this.#configObject["codec"];
        }

        get firmware() {
            return this.#configObject["sys"]["fw"];
        }

        get textConfigBlob() {
            return this.#textConfigBlob;
        }

        async fetchXmlConfig(ip) {
            try {
                const response = await fetch(`http://${ip}/xml`, {signal: AbortSignal.timeout(2000)});
                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                return xmlDoc;
            } 
            catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.log("One or more nodes were found where CORS is not enabled, please contact system administrator Jeff Van Themsche")
                } else {
                    console.error("Failed to fetch XML configuration:", error.message);
                }
            }
        }

        async postXmlConfig(xml, xmlConfig = false) {
            installation.removeEventHandlers();
            installation.body.classList.add("loading");

            let trimmedXml = "";
            if (xmlConfig) {
                 // Deleting the codec from the xml
                let startIndex = xml.indexOf("<codec>");
                let stopIndex = xml.indexOf("</codec>");
                let newXml = xml.substring(0, startIndex)+xml.substring(stopIndex+8);

                let xmlArr = newXml.split("\n");
                let tagFound = false;
                for (const line of xmlArr) {
                    let trimmedLine = line.trim();
                    trimmedXml+=trimmedLine;
                }
            }  
               
            try {
                const response = await fetch(`http://${installation.activeNode.ip}/xml`, {
                    signal: AbortSignal.timeout(2000),
                    method: "POST",
                    body: xmlConfig? trimmedXml: xml
                })

                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                let responseObj = Configuration.parseConfig(xmlDoc);
                console.log("Changed parameters: " + hexToDec(responseObj["changed"]));
                let errPos = hexToDec(responseObj["fault"])
                console.log("Fault detected at: " + errPos);
                if (errPos !== 0) {
                    let errString = "";
                    for (let i = errPos - 10; i < errPos + 10; i++) {
                        if (i !== errPos) {
                            errString += trimmedXml[i];
                        } else {
                            errString += " >>> ";
                            errString += trimmedXml[i];
                            errString += " <<< "
                        }            
                    }
                    console.log(errString);
                }

                await installation.refreshPage();

                if (!response.ok) {
                    throw new Error(`Response status: ${response.status}`);
                }
            }
            
            catch (error) {
                if (error.name === "TimeoutError") {
                    console.error("Request timed out");
                } else if (error.name === "AbortError") {
                    console.error("Fetch aborted by user");
                } else if (error.name === "TypeError") {
                    console.error("Error fulfilling request: ", error);
                } else {
                    console.error("Failed to post XML configuration:", error.message);
                }
            }
        }

        handleFormChange(n) {
            let xmlText = '<node>\n';
            xmlText += `\t<sys>\n`;
            xmlText += `\t\t<ip>${ipToHex(n.ip)}</ip>\n`;
            xmlText += `\t\t<mask>${ipToHex(n.netmask)}</mask>\n`;
            xmlText += `\t\t<name>${n.name}</name>\n`;
            xmlText += `\t</sys>\n`;
            xmlText += '</node>';
            this.postXmlConfig(xmlText);
        }

        handleInputChange(io, codec = false) {   
            let xmlText = '<node>'
            io.id[0] === "i"? xmlText += '<artnet>' : xmlText += '<fieldbus>';
            xmlText += `<${io.id}>`
            io.id[0] === "i"? xmlText += hexConverter(this.#ioHexCount["artnet"], io.universe, io.keep) : xmlText += 
                !codec? hexConverter(this.#ioHexCount["fieldbus"], io.codec, io.startAddress, io.streamLength) : hexConverter(this.#ioHexCount["fieldbus"], io.codec);
            xmlText += `</${io.id}>`
            io.id[0] === "i"? xmlText += '</artnet>' : xmlText += '</fieldbus>';
            xmlText += '</node>';
            this.postXmlConfig(xmlText);
        }

        convertObjectAndMap(mapParams, tag) {
            let convertedObject = {};
            for (const [key,value] of Object.entries(dig(this.#configObject, tag))){
                convertedObject[key] = {}
                let params = value.split(" ");
                for (let i = 0; i < params.length; i++) {
                    convertedObject[key][mapParams[i]] = parseInt(params[i], 16);
                }
            }
            return convertedObject;
        }

        static parseConfig(xmlObj) {
            let config = {};
            
            // Recursive function that traverses over each node and fills a config object
            function traverseConfig(xmlNode, config) {
                if (xmlNode !== null && typeof xmlNode === 'object') {
                    for (let i = 0; i < xmlNode.childNodes.length; i++) {
                        const childNode = xmlNode.childNodes.item(i);
                        if (childNode.nodeType === 1) {
                            if (childNode.childElementCount > 0) {
                                config[childNode.nodeName] = {};
                                traverseConfig(childNode, config[childNode.nodeName]);
                            } else {
                                config[childNode.nodeName] = childNode.textContent.trim();
                            }
                        }
                    }
                }
            }

            traverseConfig(xmlObj.documentElement, config);
            return config;
        }

        generateConfigObject(xmlText) {
            let parser = new DOMParser();
            let xmlObj = parser.parseFromString(xmlText, "text/xml");
            this.#configObject = Configuration.parseConfig(xmlObj);
            this.generateTextConfig();
        }

        generateTextConfig() {
            let xmlText = "<node>\n";
            // Filling the textConfig with information from the fetched object
            function traverseObject(configObject, lvl = 1) {
                if (configObject !== null && typeof configObject === 'object') {
                    for (const [key, value] of Object.entries(configObject)) {
                        if (typeof value === 'object') {
                            xmlText += `${'  '.repeat(lvl)}<${key}>\n`;
                            traverseObject(value, lvl + 1);
                            xmlText += `${'  '.repeat(lvl)}</${key}>\n`;
                        } else {
                            xmlText += `${'  '.repeat(lvl)}<${key}>${value}</${key}>\n`;
                        }
                    }
                }
            }
        
            traverseObject(this.#configObject);
            xmlText += "</node>";
            this.#textConfig = xmlText;
            this.#textConfigBlob = new Blob([xmlText], {type: 'text/plain'});
            return xmlText;
        }

        setXmlConfig(node) {
            let xmlText  = '<node>\n'
            xmlText     += `  <sys>\n`
            xmlText     += `    <ip>${ipToHex(node.ip)}</ip>\n`
            xmlText     += `    <mask>${ipToHex(node.netmask)}</mask>\n`
            // xmlText     += `    <mac>${macToHex(node.mac)}</mac>\n`
            xmlText     += `    <name>${node.name}</name>\n`
            xmlText     += `  </sys>\n`
            xmlText     += '  <artnet>\n'
            node.universes.forEach((uni) => {
                xmlText += `    <${uni.id}>${hexConverter(this.#ioHexCount["artnet"],uni.universe, uni.keep)}</${uni.id}>\n`
            })
            xmlText += '  </artnet>\n'
            xmlText += '  <fieldbus>\n'
            node.fieldbusses.forEach((fieldbus) => {
                xmlText += `    <${fieldbus.id}>${hexConverter(this.#ioHexCount["fieldbus"],fieldbus.codec, fieldbus.startAddress, fieldbus.streamLength)}</${fieldbus.id}>\n`
            })
            xmlText += '  </fieldbus>\n'
            xmlText += '</node>'
            this.#textConfig = xmlText;
            this.#textConfigBlob = new Blob([xmlText], {type: 'text/plain'});
            return xmlText;
        }

        generateTextBlob(xmlText) {
            this.#textConfigBlob = new Blob([xmlText], {type: 'text/plain'});
        }
    }

    class Table {
        #rows
        #fieldbus
        
        constructor(parentNode, rdmDevices, fieldbus) {
            return (async () => {
                this.rdmHeader = ["Device", "Parameters", "Values"];
                this.filters = [];
                this.#rows = rdmDevices;
                this.rowCount = 0;
                this.#fieldbus = fieldbus;
                this.rdmInfo = {};
                this.lampOnTemplate = document.querySelector("#lamp-on-template");
                this.lampOffTemplate = document.querySelector("#lamp-off-template");
                // rdmDevices.forEach(dev => {
                //     this.rdmInfo[dev.UUID] = dev.UIObject;
                // })
                this.parentNode = parentNode;
                this.generateBaseTable(true);
                // this.addRowEvents();

                
                return this;
            })();
        }

        setFirstColumn = (closed, dataCell, deviceUUID) => {
            // Inserting list arrow
            const bikiniButton = document.getElementById("bikini-button-template");
            const clone = bikiniButton.content.cloneNode(true);
            if (closed !== null) {
                let svg = clone.querySelector("svg");
                svg.classList.add("bikini");
                let bikiniContainer = document.createElement("div");
                bikiniContainer.classList.add("bikini-container", closed? "closed" : "open");
                bikiniContainer.appendChild(svg);
                dataCell.appendChild(bikiniContainer)
            }          
            let id = document.createElement("h3");
            id.innerHTML = deviceUUID;
            dataCell.appendChild(id);
            this.addLampIcon(deviceUUID, dataCell);
        }

        updateRow = () => {
            let rdmDevice = this.#rows[this.rowCount];
            this.rdmInfo[rdmDevice.UUID] = rdmDevice.UIObject;
            let dataRow = document.createElement("tr");
            dataRow.openedRow = false;
            dataRow.dataset.devid = rdmDevice.UUID;
            for (let i = 0; i < this.rdmHeader.length; i++) {
                let dTd = document.createElement("td");
                if (i == 0) {
                    this.setFirstColumn(true, dTd, rdmDevice.UUID);                   
                } else dTd.innerHTML = null;
                dataRow.appendChild(dTd);
            }
            this.table.appendChild(dataRow);
            this.updateFilters();
            this.rowCount++;
        }

        addLampIcon = async (UUID, target) => {
            let lampClone = this.lampOffTemplate.content.cloneNode(true);
            const svg = lampClone.querySelector("svg");
            let lampContainer = document.createElement("div");
            lampContainer.id = "lamp-icon-off";
            lampContainer.classList.add("lamp-container");
            lampContainer.appendChild(svg)
            target.appendChild(lampContainer);
            const res = await installation.rdm.sendRdmPacket(installation.activeNode.ip, this.#fieldbus, UUID, "GET", "1000");
            let lampOn = installation.rdm.decodeRdmPacket(res, "1000", "GET");
            let newLampContainer = document.createElement("div");
            lampClone = lampOn? this.lampOnTemplate.content.cloneNode(true) : this.lampOffTemplate.content.cloneNode(true);
            const svg2 = lampClone.querySelector("svg");
            newLampContainer.id = lampOn? "lamp-icon-on" : "lamp-icon-off";
            newLampContainer.classList.add("lamp-container");
            newLampContainer.appendChild(svg);
            target.replaceChild(newLampContainer, lampContainer);
            
        }

        updateFilters = () => {
            let filterItem;
            for (const KEY of Object.keys(this.rdmInfo)){
                for(const KEY2 of Object.keys(this.rdmInfo[KEY])){
                    if(!this.filters.includes(KEY2)){
                        this.filters.push(KEY2)
                        filterItem = document.createElement("option");
                        filterItem.value = KEY2;
                        filterItem.innerHTML = KEY2;
                        this.paramDD.appendChild(filterItem);
                    }
                }
            }
        }

        fillDropDown(dd, options, targetDevice, param) {
            for (let i = 1; i <= options; i++) {
                const OPTION = document.createElement("option", {value: i});
                if (param == i) {
                    OPTION.selected = true;
                }
                const CONTENT = document.createTextNode(targetDevice.getPersonalityDescription(i)? `${targetDevice.getPersonalityDescription(i)[2]} ${targetDevice.getPersonalityDescription(i)[0]}` : i);
                OPTION.appendChild(CONTENT);
                dd.appendChild(OPTION);
            }
        }

        setValueField = (param, paramDescription, targetElement, targetDevice) => {
            targetElement.innerHTML = "";   
            let inputField = document.createElement("input");
            let dropDown;
            let p = document.createElement("p");
            p.id = "personality-paragraph";
            if (param['Type'] === "Integer") {
                targetDevice.personalityDescriptionSet? p.innerHTML = param["Value"] : p.innerHTML = param["Value"].substr(-1);
                if(paramDescription === "Personality") {
                    dropDown = generateDomTree("select", null, {name: "personality"});
                    this.fillDropDown(dropDown, parseInt(param["Value"].split("/")[1]), targetDevice, parseInt(param["Value"].split("/")[0]))
                } else {
                    inputField.type = "number";
                    inputField.value = parseInt(param["Value"]);         
                }  
            } else inputField.value = param["Value"]      
            if (paramDescription === "Personality") {
                targetElement.appendChild(dropDown);
                if (targetDevice.personalityDescriptionSet) {
                    let pList = param["Value"].split("/")[1];
                    p.innerHTML = ` of ${pList? pList : ""}`
                    targetElement.appendChild(p);
                    dropDown.style.width = "63%";
                }

            } else targetElement.appendChild(inputField);
        }

        generateBaseTable(init) {
            if (installation.rdm.table !== undefined && init) {
                this.parentNode.removeChild(installation.rdm.table);
            }
            this.table = document.createElement("table");
            this.table.id = "rdm-table"
            let headerRow = document.createElement("tr");
            headerRow.id = "headerRow";
            let counter = 0;
            for (const HEADER of this.rdmHeader) {
                let hTd = document.createElement("th");     
                hTd.innerHTML = HEADER;
                // param filter
                if (counter == 1) {
                    hTd.innerHTML += "<br>"
                    this.paramDD = document.createElement("select");
                    this.paramDD.addEventListener("change", this.applyFilter)
                    this.paramDD.id = "param-dropdown";
                    let filterItem = document.createElement("option");
                    filterItem.innerHTML = "--No filter--"
                    this.paramDD.appendChild(filterItem);
                    hTd.appendChild(this.paramDD);
                }
                headerRow.appendChild(hTd)
                counter++;
            }
            this.table.appendChild(headerRow);
            this.parentNode.appendChild(this.table);
            installation.rdm.table = document.getElementById("rdm-table");
        }

        toggleParameters = async (e) => {
            if (e.target.classList.contains("lamp-container")) return;
            let targetRow = e.target.closest("tr");
            let parentNode = targetRow.parentNode;
            let targetDevice = this.#rows.find(dev => dev.UUID == targetRow.dataset.devid);

            if (targetRow.openedRow === false) {
                // fetching all the needed info first
                if (!targetDevice.deviceLabel) targetDevice.fetchLabel();
                if (!targetDevice.infoFetched) installation.rdm.sendRdmPacket(installation.activeNode.ip, targetDevice.parentFbId, targetDevice.UUID, "GET", "0060")
                .then(res => {
                    if (res && !res.includes("<fault>")) return targetDevice.parseDeviceParameters(res);   
                })
                .then(res => {
                    if (!res) return;
                    targetDevice.fetchSupportedParameters();    
                })
                .catch(error => {
                    console.error(error);
                });

                let counter = 0;
                let openedRowIsSet = false;
                for (const [KEY, PARAM] of Object.entries(this.rdmInfo[targetRow.dataset.devid])) {
                    let dataRow = document.createElement("tr");
                    if (!openedRowIsSet) {
                        openedRowIsSet = !openedRowIsSet;
                        dataRow.openedRow = true;
                    }
                    dataRow.dataset.devid = e.target.closest("tr").dataset.devid;
                    dataRow.classList.add(KEY.replace(" ", "-"));

                    // ========== UUID  ============
                    let data = document.createElement("td");
                    if (counter == 0) {
                        // data.innerHTML = e.target.innerHTML
                        this.setFirstColumn(false, data, dataRow.dataset.devid);
                    } else {
                        data.innerHTML = "";
                    };
                    dataRow.appendChild(data);

                    // ============ Parameters =============
                    data = document.createElement("td");
                    data.innerHTML = KEY;
                    dataRow.appendChild(data);

                    // =============== Values ==============
                    let p = document.createElement("p");
                    p.id = "personality-paragraph"
                    data = document.createElement("td");
                    data.classList.add("parameter-values");
                    if (installation.config && KEY !== "Footprint") {
                        this.setValueField(PARAM, KEY, data, targetDevice);
                    } else if (PARAM) {
                        console.log(PARAM)
                        if (KEY === "Personality") {
                            let persArr = PARAM["Value"].split("/");
                            data.innerHTML = targetDevice.personalityDescriptionSet()? `${persArr[2]} ${persArr[0]}` : `${persArr[0]}`
                            p.innerHTML = `&nbspof ${persArr[1]}`;
                            data.appendChild(p);
                        } else data.innerHTML = PARAM["Value"];
                    }            
                    dataRow.appendChild(data);
                    installation.rdm.table.insertBefore(dataRow, targetRow);
                    counter++;
                }
                installation.rdm.table.removeChild(targetRow);
            } else {
                for (let i = 0; i < Object.keys(this.rdmInfo[targetRow.dataset.devid]).length-1; i++) {
                    let nr = targetRow.nextSibling;
                    installation.rdm.table.removeChild(nr);
                }
                let dataWithoutUID = targetRow.querySelectorAll("td:not(:first-child)");
                for (const DATA of dataWithoutUID) {
                    DATA.innerHTML = "";
                }
                targetRow.openedRow = false;
                targetRow.querySelector("td:last-child").classList.remove("parameter-values");
                targetRow.querySelector(".bikini-container").classList.toggle("closed");
            }

            // setting scroll classes
            setClasses(this.parentNode);
            this.personalityDescription = undefined;
        }

        applyFilter = async (e) => {
            let oldTable = document.querySelector("#rdm-table");
            let dataWithoudHeader = installation.rdm.table.querySelectorAll("tr:not(:first-child)");
            const PARAM = e.target.value;
            // fetching all the info
            for (const targetDevice of this.#rows) {
                if (!targetDevice.infoFetched && PARAM !== "Name") installation.rdm.sendRdmPacket(installation.activeNode.ip, targetDevice.parentFbId, targetDevice.UUID, "GET", "0060")
                .then(res => {
                    console.log("parsing device parameters")
                    if (res && !res.includes("<fault>")) return targetDevice.parseDeviceParameters(res, PARAM);   
                })
                .then(res => {
                    if (PARAM === "Personality" && !res.personalityDescriptionSet) {
                        res.fetchSupportedParameters();
                    }
                })
                .catch(error => {
                    console.error(error);
                })
                
                if(!targetDevice.personalityDescriptionSet && PARAM === "Personality") targetDevice.fetchSupportedParameters()
                

                if (!targetDevice.deviceLabel && PARAM === "Name") targetDevice.fetchLabel();
            }

            if (PARAM === "--No filter--") {  
                for (const row of dataWithoudHeader) {
                    oldTable.removeChild(row);
                }
                    for (const DEVID of Object.keys(this.rdmInfo)) {
                    let dataRow = document.createElement("tr");
                    dataRow.dataset.devid = DEVID;
                    for (let i = 0; i < this.rdmHeader.length; i++) {
                        let dTd = document.createElement("td");
                        if (i === 0) {
                            dataRow.openedRow = false;
                            this.setFirstColumn(true, dTd, DEVID);
                        } else dTd.innerHTML = null;
                        dataRow.appendChild(dTd);
                    }
                    oldTable.appendChild(dataRow);
                }
                installation.rdm.filtered = false;
            } 
            else {
                for (const row of dataWithoudHeader) {
                    oldTable.removeChild(row);
                }

                for (const [KEY, VALUE] of Object.entries(this.rdmInfo)) {
                    let row = document.createElement("tr");
                    row.dataset.devid = KEY;
                    row.classList.add(PARAM.replace(" ", "-"));
                    let targetDevice = this.#rows.find(dev => dev.UUID == KEY);
                    let p = document.createElement("p");
                    p.id = "personality-paragraph"
                    if (Object.hasOwn(VALUE, PARAM)) {
                        let nData = document.createElement("td");
                        let pData = document.createElement("td");
                        let vData = document.createElement("td");
                        this.setFirstColumn(null, nData, KEY);
                        pData.innerHTML = PARAM;
                        vData.classList.add("parameter-values");
                        if (PARAM === "Personality") {
                            let persArr = VALUE[PARAM]["Value"].split("/");
                            p.innerHTML = `&nbspof ${persArr[1]}`;
                            vData.innerHTML = targetDevice.personalityDescriptionSet? `${persArr[2]} ${persArr[0]}` : `${persArr[0]}`
                            vData.appendChild(p);
                        } else {
                            vData.innerHTML = VALUE[PARAM]["Value"];
                        }
                            
                        if (installation.config && PARAM !== "Footprint") {
                                this.setValueField(VALUE[PARAM], e.target.value, vData, targetDevice);
                        } 
                        row.appendChild(nData);
                        row.appendChild(pData);
                        row.appendChild(vData);
                        installation.rdm.table.appendChild(row);

                        if (PARAM === "Personality" && targetDevice.infoFetched && !targetDevice.personalityDescription.length) {
                            // this means the user has previously added a filter before the personality, resulting in the description not being fetched
                            for (const RES of targetDevice.personalityDescriptionRes) {
                                targetDevice.setResult(RES);
                            }
                        }
                    }
                }
                installation.rdm.filtered = true;
            }
        }

        toggleInput = () => {
            let values = installation.rdm.table.querySelectorAll(".parameter-values");
            let targetDevice;
            let prevRdmDevice;
            let prevRowId;
            if (installation.config) {
                for (const VAL of values) {
                    if (VAL.previousSibling.innerHTML === "Footprint") continue;
                    let targetRow = VAL.parentElement;
                    targetDevice = this.#rows.find(dev => dev.UUID == targetRow.dataset.devid);
                    if ((prevRdmDevice !== targetDevice) && targetDevice) {
                        prevRdmDevice = targetDevice; 
                    }
                    const PARAM = prevRdmDevice.UIObject[targetRow.children[1].innerHTML];
                    let targetElement = targetRow.children[2];
                    if (targetElement.innerHTML !== undefined) {
                        this.setValueField(PARAM, targetRow.children[1].innerHTML, targetElement, targetDevice);
                    }   
                }
            } else {
                for (const VAL of values) {
                    let targetRow = VAL.parentElement;
                    targetDevice = this.#rows.find(dev => dev.UUID == targetRow.dataset.devid);
                    if ((prevRdmDevice !== targetDevice) && targetDevice) {
                        prevRdmDevice = targetDevice; 
                        prevRowId = targetRow.dataset.devid  
                    }
                    let targetElement = targetRow.children[2];
                    if (targetElement.innerHTML !== "") {
                        if (targetElement.previousSibling.innerHTML === "Personality") {
                            let personalityArr = this.rdmInfo[prevRowId][targetRow.children[1].innerHTML]["Value"].split("/");
                            targetElement.innerHTML = `${personalityArr[2]} ${personalityArr[0]} of ${personalityArr[1]}`;
                        } else targetElement.innerHTML = this.rdmInfo[prevRowId][targetRow.children[1].innerHTML]["Value"];
                    }    
                }
            }
        }

        updateLamp = async (targetRow) => {
            let oldLamp = targetRow.children[0].querySelector(".lamp-container");
            let lampOn;
            let lampClone;
            let lampContainer;
            if (oldLamp.id === "lamp-icon-on") {
                lampOn = false;
            } else lampOn = true;
            lampClone = lampOn? this.lampOnTemplate.content.cloneNode(true) : this.lampOffTemplate.content.cloneNode(true);
            let svg = lampClone.querySelector("svg");
            lampContainer = document.createElement("div");
            lampContainer.id = lampOn? "lamp-icon-on" : "lamp-icon-off";
            lampContainer.classList.add("lamp-container");
            lampContainer.appendChild(svg)
            targetRow.children[0].replaceChild(lampContainer, oldLamp);

            // getting the real value and updating it
            let res = await installation.rdm.sendRdmPacket(installation.activeNode.ip, this.#fieldbus, targetRow.dataset.devid, "GET", "1000");
            if (res) lampOn = installation.rdm.decodeRdmPacket(res, "1000", "GET");
            lampClone = lampOn? this.lampOnTemplate.content.cloneNode(true) : this.lampOffTemplate.content.cloneNode(true);
            svg = lampClone.querySelector("svg");
            lampContainer = document.createElement("div");
            lampContainer.id = lampOn? "lamp-icon-on" : "lamp-icon-off";
            lampContainer.classList.add("lamp-container");
            lampContainer.appendChild(svg)
            oldLamp = targetRow.children[0].querySelector(".lamp-container");
            targetRow.children[0].replaceChild(lampContainer, oldLamp);
        }
    }

    // Helper functie om de gewenste value te verkrijgen vanuit een object
    // https://www.30secondsofcode.org/js/s/get-nested-object-value/#search-for-a-deeply-nested-property-in-an-object


    const dig = (obj, target) => 
                target in obj ? obj[target] : Object.values(obj).reduce((acc, val) => {
                    if (acc !== undefined) return acc;
                    if (typeof val === 'object') return dig(val, target);
                }, undefined);

    // Checking if a key is present within an object
    const checkObjectKey = (obj, key) => {
        if (!obj || typeof obj !== "object") return false;
        return Object.keys(obj).includes(key);
    }

    function hexToDec(hex) {
        let dec = 0;
        for (let i = 0; i < hex.length; i+=2) {
            dec += parseInt(hex.substring(i, i+2), 16);
        }
        return dec;
    }

    function hexToIP(hex){
        let ip = "";
        for(let i = 0; i < hex.length; i+=2){
            ip += parseInt(hex.substring(i, i+2), 16);
            if(i < hex.length - 2){
                ip += ".";
            }
        }
        return ip;
    }

    function ipToHex(ip) {
        let hex = "";
        const octets = ip.split('.');
        for (let i = 0; i < octets.length; i++) {
            let hexValue = parseInt(octets[i]).toString(16).toUpperCase();
            if (hexValue.length < 2) {
                // hexValue = '0' + hexValue; // Ensure two-character hexadecimal
                hexValue = hexValue.padStart(2, '0');
            }
            hex += hexValue;
        }
        return hex;
    }

    function hexToMac(mac){
        let macAddress = "";
        for(let i = 0; i < mac.length; i+=2){
            macAddress += mac.substring(i, i+2);
            if(i < mac.length - 2){
                macAddress += ":";
            }
        }
        return macAddress;
    }

    function macToHex(mac) {
        let hex = "";
        const parts = mac.split(':');
        for (let i = 0; i < parts.length; i++) {
            hex += parts[i].toUpperCase();
        }
        return hex;
    }

    // function demoHexConverter(...params) {
    //     return params.map(param => param.toString(16).toUpperCase()).join(' ');
    // }

    function hexConverter(io, ...params) {
      const widths = Object.values(io);            // e.g. [4,4] or [2,4,4]
      const out = new Array(widths.length);

      for (let i = 0; i < widths.length; i++) {
        const p = params[i] ?? 0;                  // default to 0 if missing
        out[i] = Number(p).toString(16)
          .toUpperCase()
          .padStart(widths[i], '0');
      }
      return out.join(' ');
    }

    function hexToAscii(str) {
        let hex = str.toString();
        let rString = "";
        for (let i=0; i<hex.length; i+=2) {
            rString += String.fromCharCode(parseInt(hex.substr(i,2), 16))
        }
        return rString;
    }

    function hexToArr(payload, bits) {
        let arr = [];
        for (let i=0; i < payload.length; i+=(bits/4)) {
            arr.push(payload.slice(i, i+(bits/4)));
        }
        return arr;
    }

    function hexToPersonality(payload) {
        let arr = [];
        arr.push(parseInt(payload.slice(0,2), 16));
        arr.push(parseInt(payload.slice(2,6), 16))
        let personalityString = payload.slice(6).toString();
        let newString = "";
        for(let i = 0; i < personalityString.length; i+=2) {
            newString += String.fromCharCode(parseInt(personalityString.substr(i,2), 16));
        };
        arr.push(newString);
        return arr;      
    }

    function generateDomTree(tag, value=null, attributes=null, children=null, listeners=null) {
        let root = document.createElement(tag);
        value? root.textContent = value : root.textContent = "";
        if (attributes) {
            for (const [key, value] of Object.entries(attributes)) {
                root.setAttribute(key, value);
            }
        }
        if (children) {
            Array.from(children).forEach((childNode) => root.appendChild(childNode));
        }
        if (listeners) {
            for (const [e, f] of Object.entries(listeners)) {
            root.addEventListener((e), f);
            }
        }
        return root;
    }
  
    function checkOverflow(patchContainer, status, ah = null) {
        let patch = patchContainer.querySelector(".address-container");
        let start = patch.querySelector(".start");
        let stream = patch.querySelector(".stream");
        let input;
        let inputHeight = 0;
        let offset = 5;
        if (!status) {
            input = start.querySelector("input");
            inputHeight = input.clientHeight;
        }

        if (start.clientHeight + stream.clientHeight + 2 * inputHeight >= (ah? ah : patch.clientHeight) - offset) {
            patch.classList.add("overflow");
        } else if (!patch.classList.contains("extreme")) {
            patch.classList.remove("overflow");
        }

        if (patch.classList.contains("overflow")) {
            if (stream.clientHeight + inputHeight >= (ah? ah : patch.clientHeight) - offset) {
                patch.classList.add("extreme");
            } else patch.classList.remove("extreme");
        }
    }

    function setCurvePosition() {
        let circleDiameter = 60;
        let nodeSelected = document.querySelector(".node.selected");
        let topCurve = nodeSelected.querySelector("#top-curve");
        let bottomCurve = nodeSelected.querySelector("#bottom-curve");
        let cs = getComputedStyle(nodeSelected)
        let paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
        let borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);
        
        // Element width and height minus padding and border
        let elementWidth = nodeSelected.offsetWidth - paddingX - borderX;
        let beforeLeft= Math.round(elementWidth-(circleDiameter/2)) + "px";
        let afterLeft = Math.round(elementWidth-circleDiameter) + "px";
        
        topCurve.style.setProperty("--beforeLeft", beforeLeft);
        topCurve.style.setProperty("--afterLeft", afterLeft);
        bottomCurve.style.setProperty("--beforeLeft", beforeLeft);
        bottomCurve.style.setProperty("--afterLeft", afterLeft);
    }

    function isDemo(demoMac) {
        if (demoMac.substring(0, 15) === "7B:A6:80:7F:EC:") {
            return true;
        } return false;
    }

    function setClasses(el) {
        const isScrollable = el.scrollHeight > el.clientHeight;

        // GUARD: If element is not scrollable, remove all classes
        if (!isScrollable) {
          el.classList.remove('is-bottom-overflowing', 'is-top-overflowing');
          return;
        }

        // Otherwise, the element is overflowing!
        // Now we just need to find out which direction it is overflowing to (can be both).
        // One pixel is added to the height to account for non-integer heights.
        const isScrolledToBottom = el.scrollHeight < el.clientHeight + el.scrollTop + 1;
        const isScrolledToTop = isScrolledToBottom ? false : el.scrollTop === 0;
        el.classList.toggle('is-bottom-overflowing', !isScrolledToBottom);
        el.classList.toggle('is-top-overflowing', !isScrolledToTop);
    }

    
    // =========================== Program entry point =========================
                                                                               
    let installation;                                                         
                                                                               
    async function intitialise(init) {
        installation = await new Installation("Lux-Lumen");
        installation.updateNav();
        if (init) installation.eventInit();  
    }
        
    document.addEventListener("DOMContentLoaded", async () => {
        await intitialise(true);
        // setting the buffer size for the resource timing used for fetching status and fps
        // buffer is also cleared in the refreshPage function
        performance.setResourceTimingBufferSize(100);

        // setting scroll fade
        let scrollContainers = document.querySelectorAll(".scrollContainer");
        for (const CONT of scrollContainers) {
            CONT.addEventListener('scroll', (e) => {
                const el = e.currentTarget;
                setClasses(el);
            });
            setClasses(CONT);
        }
        
        setCurvePosition();     

        // testing
        // let listItems = document.querySelectorAll("nav li")
        // for (let i = 0; i < 1000; i++) {
        //     for (const item of listItems) {
        //         if
        //     }
        // }

    })
    
</script></head>


<body>
    <header>
        <div id="banner">
            <!-- svg definition of the ethernet ports -->
            <svg xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 490.43">
                <defs>
                    <symbol id="ethernet-port">
                        <path fill-rule="nonzero" d="M29.08 0h453.85c8.04 0 15.28 3.33 20.5 8.55 5.26 5.27 8.57 12.64 8.57 20.53v432.27c0 7.94-3.33 15.23-8.59 20.49-5.25 5.25-12.54 8.59-20.48 8.59H29.08c-7.89 0-15.26-3.31-20.53-8.58C3.33 476.63 0 469.4 0 461.35V29.08c0-8.05 3.3-15.3 8.54-20.54l2.18-1.91A28.741 28.741 0 0 1 29.08 0z"></path>
                        <path fill="#CCC" d="M29.08 21.98h453.85c3.9 0 7.09 3.35 7.09 7.1v432.27c0 3.75-3.34 7.1-7.09 7.1H29.08c-3.75 0-7.1-3.19-7.1-7.1V29.08c0-3.91 3.19-7.1 7.1-7.1z"></path>
                        <path fill-rule="nonzero" d="M82.08 65.09h348.08c6.53 0 12.4 2.71 16.62 6.93 4.27 4.27 6.95 10.25 6.95 16.65v239.14h-70.87v48.58h-40.95v46.95H171.27v-46.95h-40.94v-48.58H58.5V88.67c0-6.54 2.67-12.42 6.92-16.66 4.3-4.28 10.23-6.92 16.66-6.92z"></path>
                        <path fill="#fff" d="M82.08 81.57h348.08c3.9 0 7.1 3.35 7.1 7.1v222.66h-70.88v48.59h-40.95v46.94H187.75v-46.94H146.8v-48.59H74.98V88.67c0-3.91 3.19-7.1 7.1-7.1z"></path>
                        <path fill-rule="nonzero" d="M365.43 297.06h71.83c9.09 0 16.47 7.38 16.47 16.48v46.38c0 9.09-7.38 16.47-16.47 16.47h-71.83c-9.09 0-16.48-7.38-16.48-16.47v-46.38c0-9.1 7.39-16.48 16.48-16.48z"></path>
                        <path fill="#fff" d="M437.26 313.54h-71.83v46.38h71.83z"></path>
                        <path fill-rule="nonzero" d="M74.98 297.06h71.82c9.1 0 16.48 7.38 16.48 16.48v46.38c0 9.09-7.38 16.47-16.48 16.47H74.98c-9.1 0-16.48-7.38-16.48-16.47v-46.38c0-9.1 7.38-16.48 16.48-16.48z"></path>
                        <path fill="#fff" d="M74.98 313.54h71.82v46.38H74.98z"></path>
                        <rect x="109.2" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"></rect>
                        <rect x="153.91" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"></rect>
                        <rect x="198.62" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"></rect>
                        <rect x="243.33" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"></rect>
                        <rect x="288.03" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"></rect>
                        <rect x="332.74" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"></rect>
                        <rect x="377.45" y="110.21" width="25.59" height="46.75" rx="3.44" ry="3.44"></rect>
                    </symbol>
                </defs>
            </svg>
            <!-- end of ehternet port definition -->
            <div id="eth1">
                <span>ETH1</span>
                <svg viewBox="0 0 512 490.43">  
                    <use href="#ethernet-port"></use>
                </svg>
            </div>
            <div id="eth2" hidden="">
                <span>ETH2</span>
                <svg viewBox="0 0 512 490.43">  
                    <use href="#ethernet-port"></use>
                </svg>
            </div>
            <h1>Configurator</h1>
            <div id="edit">
                <input type="checkbox" id="edit-switch" autocomplete="off">
                <label for="edit-switch">
                    <!--?xml version="1.0" encoding="utf-8"?--><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
                    <svg height="100%" class="e-button" id="pen" viewBox="0 0 24 24" data-name="24x24/On Light/Edit" xmlns="http://www.w3.org/2000/svg">
                        <rect id="view-box" width="24" height="24" fill="none"></rect>
                        <path id="Shape" d="M.75,17.5A.751.751,0,0,1,0,16.75V12.569a.755.755,0,0,1,.22-.53L11.461.8a2.72,2.72,0,0,1,3.848,0L16.7,2.191a2.72,2.72,0,0,1,0,3.848L5.462,17.28a.747.747,0,0,1-.531.22ZM1.5,12.879V16h3.12l7.91-7.91L9.41,4.97ZM13.591,7.03l2.051-2.051a1.223,1.223,0,0,0,0-1.727L14.249,1.858a1.222,1.222,0,0,0-1.727,0L10.47,3.91Z" stroke="#FFF200" transform="translate(3.25 3.25)" fill="#FFF200" style="stroke: rgb(255, 242, 0); fill: rgb(255, 242, 0);"></path>
                    </svg>
                </label>
            </div>
            <div id="dark-mode-switch">
                <input type="checkbox" id="switch">
                <label for="switch">
                    <!--?xml version="1.0" encoding="utf-8"?-->
                    <svg class="sun" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 50 50">
                        <path d="M 24.90625 3.96875 C 24.863281 3.976563 24.820313 3.988281 24.78125 4 C 24.316406 4.105469 23.988281 4.523438 24 5 L 24 11 C 23.996094 11.359375 24.183594 11.695313 24.496094 11.878906 C 24.808594 12.058594 25.191406 12.058594 25.503906 11.878906 C 25.816406 11.695313 26.003906 11.359375 26 11 L 26 5 C 26.011719 4.710938 25.894531 4.433594 25.6875 4.238281 C 25.476563 4.039063 25.191406 3.941406 24.90625 3.96875 Z M 10.65625 9.84375 C 10.28125 9.910156 9.980469 10.183594 9.875 10.546875 C 9.769531 10.914063 9.878906 11.304688 10.15625 11.5625 L 14.40625 15.8125 C 14.648438 16.109375 15.035156 16.246094 15.410156 16.160156 C 15.78125 16.074219 16.074219 15.78125 16.160156 15.410156 C 16.246094 15.035156 16.109375 14.648438 15.8125 14.40625 L 11.5625 10.15625 C 11.355469 9.933594 11.054688 9.820313 10.75 9.84375 C 10.71875 9.84375 10.6875 9.84375 10.65625 9.84375 Z M 39.03125 9.84375 C 38.804688 9.875 38.59375 9.988281 38.4375 10.15625 L 34.1875 14.40625 C 33.890625 14.648438 33.753906 15.035156 33.839844 15.410156 C 33.925781 15.78125 34.21875 16.074219 34.589844 16.160156 C 34.964844 16.246094 35.351563 16.109375 35.59375 15.8125 L 39.84375 11.5625 C 40.15625 11.265625 40.246094 10.800781 40.0625 10.410156 C 39.875 10.015625 39.460938 9.789063 39.03125 9.84375 Z M 25 15 C 19.484375 15 15 19.484375 15 25 C 15 30.515625 19.484375 35 25 35 C 30.515625 35 35 30.515625 35 25 C 35 19.484375 30.515625 15 25 15 Z M 4.71875 24 C 4.167969 24.078125 3.78125 24.589844 3.859375 25.140625 C 3.9375 25.691406 4.449219 26.078125 5 26 L 11 26 C 11.359375 26.003906 11.695313 25.816406 11.878906 25.503906 C 12.058594 25.191406 12.058594 24.808594 11.878906 24.496094 C 11.695313 24.183594 11.359375 23.996094 11 24 L 5 24 C 4.96875 24 4.9375 24 4.90625 24 C 4.875 24 4.84375 24 4.8125 24 C 4.78125 24 4.75 24 4.71875 24 Z M 38.71875 24 C 38.167969 24.078125 37.78125 24.589844 37.859375 25.140625 C 37.9375 25.691406 38.449219 26.078125 39 26 L 45 26 C 45.359375 26.003906 45.695313 25.816406 45.878906 25.503906 C 46.058594 25.191406 46.058594 24.808594 45.878906 24.496094 C 45.695313 24.183594 45.359375 23.996094 45 24 L 39 24 C 38.96875 24 38.9375 24 38.90625 24 C 38.875 24 38.84375 24 38.8125 24 C 38.78125 24 38.75 24 38.71875 24 Z M 15 33.875 C 14.773438 33.90625 14.5625 34.019531 14.40625 34.1875 L 10.15625 38.4375 C 9.859375 38.679688 9.722656 39.066406 9.808594 39.441406 C 9.894531 39.8125 10.1875 40.105469 10.558594 40.191406 C 10.933594 40.277344 11.320313 40.140625 11.5625 39.84375 L 15.8125 35.59375 C 16.109375 35.308594 16.199219 34.867188 16.039063 34.488281 C 15.882813 34.109375 15.503906 33.867188 15.09375 33.875 C 15.0625 33.875 15.03125 33.875 15 33.875 Z M 34.6875 33.875 C 34.3125 33.941406 34.011719 34.214844 33.90625 34.578125 C 33.800781 34.945313 33.910156 35.335938 34.1875 35.59375 L 38.4375 39.84375 C 38.679688 40.140625 39.066406 40.277344 39.441406 40.191406 C 39.8125 40.105469 40.105469 39.8125 40.191406 39.441406 C 40.277344 39.066406 40.140625 38.679688 39.84375 38.4375 L 35.59375 34.1875 C 35.40625 33.988281 35.148438 33.878906 34.875 33.875 C 34.84375 33.875 34.8125 33.875 34.78125 33.875 C 34.75 33.875 34.71875 33.875 34.6875 33.875 Z M 24.90625 37.96875 C 24.863281 37.976563 24.820313 37.988281 24.78125 38 C 24.316406 38.105469 23.988281 38.523438 24 39 L 24 45 C 23.996094 45.359375 24.183594 45.695313 24.496094 45.878906 C 24.808594 46.058594 25.191406 46.058594 25.503906 45.878906 C 25.816406 45.695313 26.003906 45.359375 26 45 L 26 39 C 26.011719 38.710938 25.894531 38.433594 25.6875 38.238281 C 25.476563 38.039063 25.191406 37.941406 24.90625 37.96875 Z"></path>
                    </svg>
                    <svg class="moon" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 122.88 122.89" style="enable-background:new 0 0 122.88 122.89" xml:space="preserve"><g><path d="M49.06,1.27c2.17-0.45,4.34-0.77,6.48-0.98c2.2-0.21,4.38-0.31,6.53-0.29c1.21,0.01,2.18,1,2.17,2.21 c-0.01,0.93-0.6,1.72-1.42,2.03c-9.15,3.6-16.47,10.31-20.96,18.62c-4.42,8.17-6.1,17.88-4.09,27.68l0.01,0.07 c2.29,11.06,8.83,20.15,17.58,25.91c8.74,5.76,19.67,8.18,30.73,5.92l0.07-0.01c7.96-1.65,14.89-5.49,20.3-10.78 c5.6-5.47,9.56-12.48,11.33-20.16c0.27-1.18,1.45-1.91,2.62-1.64c0.89,0.21,1.53,0.93,1.67,1.78c2.64,16.2-1.35,32.07-10.06,44.71 c-8.67,12.58-22.03,21.97-38.18,25.29c-16.62,3.42-33.05-0.22-46.18-8.86C14.52,104.1,4.69,90.45,1.27,73.83 C-2.07,57.6,1.32,41.55,9.53,28.58C17.78,15.57,30.88,5.64,46.91,1.75c0.31-0.08,0.67-0.16,1.06-0.25l0.01,0l0,0L49.06,1.27 L49.06,1.27z"></path></g></svg>
                </label>
            </div>
        </div>
    </header>
    <div id="sidebar">
        <div id="title">
            <h2>Lux<br>Lumen</h2>
            <h2>Art-Net<br>node</h2>
        </div>
        <nav class="scrollContainer">
            <ul id="node-list"><li class="node selected" id="0023C4001117"><div id="top-curve" style="--beforeLeft: 115px; --afterLeft: 85px;"></div><div id="status"></div><h3 id="name">v3</h3><ul class="info undefined configurable"><li class="IP">IP: <p>2.121.17.23</p></li><li class="netMask">Netmask: <p>255.0.0.0</p></li><li class="mac">MAC: <p>00:23:C4:00:11:17</p></li></ul><div id="bottom-curve" style="--beforeLeft: 115px; --afterLeft: 85px;"></div></li><li class="node" id="0023C40011F7"><div id="top-curve"></div><div id="status"></div><h3 id="name">Artnet node V3</h3><ul class="info undefined configurable"><li class="IP">IP: <p>2.121.17.247</p></li><li class="netMask">Netmask: <p>255.0.0.0</p></li><li class="mac">MAC: <p>00:23:C4:00:11:F7</p></li></ul><div id="bottom-curve"></div></li><li class="node" id="7BA6807FEC01"><div id="top-curve"></div><div id="status"></div><h3 id="name">Demo</h3><ul class="info undefined configurable"><li class="IP">IP: <p>127.0.0.1</p></li><li class="netMask">Netmask: <p>255.255.255.0</p></li><li class="mac">MAC: <p>7B:A6:80:7F:EC:01</p></li></ul><div id="bottom-curve"></div></li></ul>
        </nav>
        <div class="info config">
            <h3 id="firmware">firmware: <span>v4.2</span></h3>
            <h3 id="config">config: <span>V0.01</span></h3>
        </div>
    </div>
    <div id="main-config" style="grid-template-rows: repeat(6, 1fr) 25px 75px;">
        <div id="universe-container" class="card" style="grid-row: 1 / 8;">
            <div class="card" id="tab">Art-Net</div>
            <ol id="universes" style="grid-row: 1 / 9;"><li class="range" style="padding: 0.5rem;">0<span class="range undefined">512</span></li><li class="range" style="padding: 0.5rem;">1<span class="range undefined">512</span></li><li class="range" style="padding: 0.5rem;">2<span class="range undefined">512</span></li><li class="range" style="padding: 0.5rem;">3<span class="range undefined">512</span></li><li class="range" style="padding: 0.5rem;">4<span class="range undefined">512</span></li><li class="range" style="padding: 0.5rem;">5<span class="range undefined">512</span></li></ol>
            <div id="universe-filter-container" style="grid-row: 8;">
                <div id="universe-filter">
                    <button class="e-button" id="decrement">-</button>
                    <button class="e-button" id="increment">+</button>
                </div>
            </div>
        </div>
        <!-- svg definition of the accolades -->
        <template id="brace-template"></template>
        <!-- end of accolade definition -->
        <div id="accolades"><svg viewBox="45 0 2000 72" xmlns="http://www.w3.org/2000/svg" id="accolade-1" class="accolade">
                    <path d="M61.4 1.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M61.4 70.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M5 36.2H46.5M61.4 70.7C54.3 70.7 50 67.3 50 59.9c0-8.3 5-11.1 6.7-15.6 2.7-7.1-5-8.2-10.2-8.1M61.4 1.7C54.3 1.7 50 5.2 50 12.6c0 8.3 5 11 6.7 15.6 2.7 7-5 8.1-10.2 8" fill="none" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <text class="info undefined" x="60px" y="40px" style="font-size: 10.44660675955349px">0fps</text>
                </svg><svg viewBox="45 0 2000 72" xmlns="http://www.w3.org/2000/svg" id="accolade-2" class="accolade">
                    <path d="M61.4 1.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M61.4 70.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M5 36.2H46.5M61.4 70.7C54.3 70.7 50 67.3 50 59.9c0-8.3 5-11.1 6.7-15.6 2.7-7.1-5-8.2-10.2-8.1M61.4 1.7C54.3 1.7 50 5.2 50 12.6c0 8.3 5 11 6.7 15.6 2.7 7-5 8.1-10.2 8" fill="none" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <text class="info undefined" x="60px" y="40px" style="font-size: 10.44660675955349px">33fps</text>
                </svg><svg viewBox="45 0 2000 72" xmlns="http://www.w3.org/2000/svg" id="accolade-3" class="accolade">
                    <path d="M61.4 1.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M61.4 70.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M5 36.2H46.5M61.4 70.7C54.3 70.7 50 67.3 50 59.9c0-8.3 5-11.1 6.7-15.6 2.7-7.1-5-8.2-10.2-8.1M61.4 1.7C54.3 1.7 50 5.2 50 12.6c0 8.3 5 11 6.7 15.6 2.7 7-5 8.1-10.2 8" fill="none" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <text class="info undefined" x="60px" y="40px" style="font-size: 10.44660675955349px">0fps</text>
                </svg><svg viewBox="45 0 2000 72" xmlns="http://www.w3.org/2000/svg" id="accolade-4" class="accolade">
                    <path d="M61.4 1.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M61.4 70.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M5 36.2H46.5M61.4 70.7C54.3 70.7 50 67.3 50 59.9c0-8.3 5-11.1 6.7-15.6 2.7-7.1-5-8.2-10.2-8.1M61.4 1.7C54.3 1.7 50 5.2 50 12.6c0 8.3 5 11 6.7 15.6 2.7 7-5 8.1-10.2 8" fill="none" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <text class="info undefined" x="60px" y="40px" style="font-size: 10.44660675955349px">0fps</text>
                </svg><svg viewBox="45 0 2000 72" xmlns="http://www.w3.org/2000/svg" id="accolade-5" class="accolade">
                    <path d="M61.4 1.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M61.4 70.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M5 36.2H46.5M61.4 70.7C54.3 70.7 50 67.3 50 59.9c0-8.3 5-11.1 6.7-15.6 2.7-7.1-5-8.2-10.2-8.1M61.4 1.7C54.3 1.7 50 5.2 50 12.6c0 8.3 5 11 6.7 15.6 2.7 7-5 8.1-10.2 8" fill="none" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <text class="info undefined" x="60px" y="40px" style="font-size: 10.44660675955349px">0fps</text>
                </svg><svg viewBox="45 0 2000 72" xmlns="http://www.w3.org/2000/svg" id="accolade-6" class="accolade">
                    <path d="M61.4 1.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M61.4 70.7H2637.1" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <path d="M5 36.2H46.5M61.4 70.7C54.3 70.7 50 67.3 50 59.9c0-8.3 5-11.1 6.7-15.6 2.7-7.1-5-8.2-10.2-8.1M61.4 1.7C54.3 1.7 50 5.2 50 12.6c0 8.3 5 11 6.7 15.6 2.7 7-5 8.1-10.2 8" fill="none" stroke="#FFF200" stroke-width="2" style="stroke: rgb(255, 242, 0);"></path>
                    <text class="info undefined" x="60px" y="40px" style="font-size: 10.44660675955349px">0fps</text>
                </svg></div>
        <!-- svg definition of the used-by-prev channel arrow-->
        <template id="arrow-template"></template>
        <div id="fieldbusses" style="grid-template-columns: repeat(4, 2fr); grid-row: 1 / 9;"><div id="fb-1" class="fieldbus card" style="grid-row: 1 / 9;"><div class="address range" style="grid-row: 1 / 7;"><h1>FIELDBUS 1</h1><div id="address-block-1" class="patch" style="height: 16.6667%; top: 0.032552%;"><div class="top-handle draggable"></div><div class="address-container draggable"><h2 class="draggable non-configurable start">start: <span>1</span></h2><h2 class="draggable non-configurable stream">length: <span class="draggable">512</span></h2></div><div class="bottom-handle draggable"></div></div></div><div class="fb-protocol info" style="grid-row: 7 / 9;"><h2>Codec: </h2><h3>WS2811</h3><div id="ethernet"><svg viewBox="0 0 512 490.43" width="60%"><use href="#ethernet-port"></use></svg></div></div><div class="rdm-button e-button" style="visibility: hidden">i</div></div><div id="fb-2" class="fieldbus card" style="grid-row: 1 / 9;"><div class="address range" style="grid-row: 1 / 7;"><h1>FIELDBUS 2</h1><div id="address-block-2" class="patch" hidden="" style="height: 16.6667%; top: 16.6992%;"><div class="top-handle draggable"></div><div class="address-container draggable"><h2 class="draggable non-configurable start">start: <span>513</span></h2><h2 class="draggable non-configurable stream">length: <span class="draggable">512</span></h2></div><div class="bottom-handle draggable"></div></div></div><div class="fb-protocol info" style="grid-row: 7 / 9;"><h2>Codec: </h2><h3>disabled</h3><div id="ethernet"><svg viewBox="0 0 512 490.43" width="60%"><use href="#ethernet-port"></use></svg></div></div><div class="rdm-button e-button" style="visibility: hidden">i</div></div><div id="fb-3" class="fieldbus card" style="grid-row: 1 / 9;"><div class="address range" style="grid-row: 1 / 7;"><h1>FIELDBUS 3</h1><div id="address-block-3" class="patch" hidden="" style="height: 16.6667%; top: 33.3659%;"><div class="top-handle draggable"></div><div class="address-container draggable"><h2 class="draggable non-configurable start">start: <span>1025</span></h2><h2 class="draggable non-configurable stream">length: <span class="draggable">512</span></h2></div><div class="bottom-handle draggable"></div></div></div><div class="fb-protocol info" style="grid-row: 7 / 9;"><h2>Codec: </h2><h3>disabled</h3><div id="ethernet"><svg viewBox="0 0 512 490.43" width="60%"><use href="#ethernet-port"></use></svg></div></div><div class="rdm-button e-button" style="visibility: hidden">i</div></div><div id="fb-4" class="fieldbus card" style="grid-row: 1 / 9;"><div class="address range" style="grid-row: 1 / 7;"><h1>FIELDBUS 4</h1><div id="address-block-4" class="patch" style="height: 16.6667%; top: 66.6992%;"><div class="top-handle draggable"></div><div class="address-container draggable"><h2 class="draggable non-configurable start">start: <span>2049</span></h2><h2 class="draggable non-configurable stream">length: <span class="draggable">512</span></h2></div><div class="bottom-handle draggable"></div></div></div><div class="fb-protocol info" style="grid-row: 7 / 9;"><h2>Codec: </h2><h3>DMX-512</h3><div id="ethernet"><svg viewBox="0 0 512 490.43" width="60%"><use href="#ethernet-port"></use></svg></div></div><div class="rdm-button e-button" style="visibility: hidden">i</div></div></div>
        <div id="text-config-container" style="grid-row: 8;">
            <textarea id="xml-text-area" spellcheck="false"></textarea>
            <p id="help-text">
                Editing the node parameters is possible by directly editing the fields within the tags. The values are in hex format where 2 characters represent a byte. 2 bytes after each other are MSB. different parameters are separated by a space.
                <br><br>
                It’s possible to change only 1 parameter by giving the tag and it’s value eg. &lt;out3&gt; 02 &lt;/out3&gt; wil set the third output to the second protocol.
            </p>
            <button class="card xml-text-button" id="push">push to node</button>
            <label id="upload-container" for="upload" class="card xml-text-button">
                Open file
            </label>
            <input id="upload" type="file">
            <a id="download-container" download="XML.conf" href="http://2.121.17.23/">
                <button class="card xml-text-button" id="download">download config file</button>
            </a>
            <button class="card" id="text-config">text config</button>
        </div>
    </div>
    <div id="rdm-config" style="visibility: hidden">
        <template id="lamp-on-template"></template>
        <template id="lamp-off-template"></template>
        <template id="bikini-button-template"></template>
        <div class="card">
            <div id="rdm-table-container" class="scrollContainer"></div>
            <div class="rdm-button e-button">i</div>
            <h1 class="fieldbus-name">FIELDBUS #</h1>
        </div>
    </div>


</body></html>